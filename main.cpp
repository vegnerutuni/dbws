// https://github.com/vegnerutuni/dbws

#include <iostream>
#include <iomanip>
#include <string>
#include <math.h>
#include <cmath>
#include <vector>
#include <set>
#include <fstream>
#include <time.h>
#include <map>
#include <bitset>
#include <stack>

using namespace std;



// Define a versão do programa

const string versao = "6.0";


/*
             PARAMETER INCLUDE FILE
    In order to get DBWS working with other parameters
     (e.g. IDSZ, IRS, NATS, MSZ, NOV) you can easily change
    desired PARAMETERs in this file and next recompile the
    the source code

  */

const int IDSZ=8000;    // maximum number of data points in tape 4

const int IRS=4096;     // maximum number of reflections in the pattern

const int NATS=128;     // maximum number of atoms in the problem

const int MSZ=64;       // maximum number of refinable parameters (matrix size)

const int NOV=512;      // maximum number of Bragg reflections contributing to one step

/*
       dimension of the table FINAL(nfinal) in COMMON/ALLP/
        It must be equal to (#atoms*11 + #phases*27 + 11), at least,
        where #atoms & #phases are actually numbers of atoms
        and phases in the input control file for the current refinement.
    Previous declaration FINAL(8*MSZ,2) caused error in case of many atoms.

 */

const int NFINAL=1635;




// Define pi/180. Lembre que pi = 3.1415... é definido em math.h

const double _pi_180  = M_PI / 180.0;

const double _180_pi  = 180.0 / M_PI;

const double M_PI_2_3 = 1.5 * M_PI;

const double _180_pi_sqr = _180_pi*_180_pi;


const double C0 = 4*M_LN2;          // 4*ln(2)

const double C0_1 = sqrt(C0/M_PI);

const double _4_SQRT2_1 = 4.0*(sqrt(2.0)-1);// 4(sqrt(2)-1)

const double _4_SQRT223_1 = 4.0*(sqrt( pow(2.0,2.0/3.0) )-1);// 4(sqrt(2^(2/3))-1)


// Converte graus decimais em graus radianos
double degtorad(const double deg)
{
    return deg * _pi_180;
}

// Converte graus radianos em graus decimais
double radtodeg(const double rad)
{
    return _180_pi * rad;
}


// 2 lines below were commented to include the code from Ian madsen
//      DATA XRYZ(1),XRYZ(2),XRYZ(3),XRYZ(4),XRYZ(5)
//     * /2.28962,1.93597,1.54051,0.70926,0.556363/
// Adding the code from Ian Madsen (10 feb 98)  (Au,Cr,Fe,Co,Cu,
//                                               Mo,Ag,Ta,W ,Au)
const double XRYZ[10+1] = {0.0,
                    2.74851,2.28962,1.93597,1.788965,1.54052,0.70926,0.55936,0.215947,0.20901,0.180195
                   };



const string TABNC[85+1] = {
    "",

    "H","HE","LI","BE","B","C","N","O","F","NE","NA","MG","AL","SI","P","S","CL","AR",
    "K","CA","SC","TI","V","CR","MN","FE","CO","NI","CU","ZN","GA","GE","AS","SE","BR","KR",
    "RB","SR","Y","ZR","NB","MO""TC","RU","RH","PD","AG","CD","IN","SN","SB","TE","I","XE",
    "CS","BA","LA","CE","PR","ND","EU","GD","TB","DY","HO","ER","TM","YB","LU","HF","TA","W",
    "RE","OS","IR","PT","AU","HG","TL","PB","BI","TH","U","NP","PU"
};

const float TABN[85+1] = {
    0.0,

    -0.372,0.3,-0.194,0.774,0.54,0.663,0.94,0.575,0.57,0.46,0.351,0.52,0.345,
    0.415,0.51,0.285,0.958,0.20,0.37,0.47,1.18,-0.33,-0.05,0.352,-0.36,0.95,
    0.25,1.03,0.76,0.57,0.72,0.84,0.64,0.80,0.68,0.74,0.70,0.69,0.79,0.69,
    0.71,0.66,0.68,0.73,0.59,0.60,0.61,0.37,0.39,0.61,0.56,0.54,0.52,0.47,
    0.55,0.52,0.83,0.55,0.44,0.72,0.55,1.5,0.76,1.69,0.85,0.79,0.69,1.26,
    0.73,0.78,0.70,0.48,0.92,1.07,1.06,0.95,0.76,1.27,0.89,0.94,0.85,0.99,
    0.84,1.055,0.75
};

//  Dispersion Coefficients from International Tables
//  Volume C page 219-222 for wavelengths
//    2.748510   2.289620   1.935970   1.788965   1.540520
//      Ti         Cr         Fe         Co         Cu
//    0.709260   0.559360   0.215947   0.209010   0.180195
//      Mo         Ag         Ta         W          Au
//     first  2 lines = 10 fp  values
//     second 2 lines = 10 fpp values
//  From the codes of Ian Madsen , added in DBWS on 11 Feb 98


const float TBD[98+1][20+1] = {
    {0.0,    0.0000,    0.0000,    0.0000,    0.0000,    0.0000,
        0.0000,    0.0000,    0.0000,    0.0000,    0.0000,
        0.0000,    0.0000,    0.0000,    0.0000,    0.0000,
        0.0000,    0.0000,    0.0000,    0.0000,    0.0000},

    //  Dispersion Coefficients for H
      {0.0,    0.0000,    0.0000,    0.0000,    0.0000,    0.0000,
          0.0000,    0.0000,    0.0000,    0.0000,    0.0000,
          0.0000,    0.0000,    0.0000,    0.0000,    0.0000,
          0.0000,    0.0000,    0.0000,    0.0000,    0.0000},
      //  Dispersion Coefficients for He
      {0.0,    0.0000,    0.0000,    0.0000,    0.0000,    0.0000,
          0.0000,    0.0000,    0.0000,    0.0000,    0.0000,
          0.0000,    0.0000,    0.0000,    0.0000,    0.0000,
          0.0000,    0.0000,    0.0000,    0.0000,    0.0000},
      //  Dispersion Coefficients for Li
      {0.0,    0.0035,    0.0023,    0.0015,    0.0013,    0.0008,
         -0.0003,   -0.0004,   -0.0006,   -0.0006,   -0.0006,
          0.0013,    0.0008,    0.0006,    0.0005,    0.0003,
          0.0001,    0.0000,    0.0000,    0.0000,    0.0000},
      //  Dispersion Coefficients for Be
      {0.0,    0.0117,    0.0083,    0.0060,    0.0052,    0.0038,
          0.0005,    0.0001,   -0.0005,   -0.0005,   -0.0005,
          0.0050,    0.0033,    0.0023,    0.0019,    0.0014,
          0.0002,    0.0001,    0.0000,    0.0000,    0.0000},
      //  Dispersion Coefficients for B
      {0.0,    0.0263,    0.0190,    0.0140,    0.0121,    0.0090,
          0.0013,    0.0004,   -0.0009,   -0.0009,   -0.0010,
          0.0139,    0.0094,    0.0065,    0.0055,    0.0039,
          0.0007,    0.0004,    0.0000,    0.0000,    0.0000},
      //  Dispersion Coefficients for C
      {0.0,    0.0490,    0.0364,    0.0273,    0.0237,    0.0181,
          0.0033,    0.0015,   -0.0012,   -0.0013,   -0.0014,
          0.0313,    0.0213,    0.0148,    0.0125,    0.0091,
          0.0016,    0.0009,    0.0001,    0.0001,    0.0001},
      //  Dispersion Coefficients for N
      {0.0,    0.0807,    0.0606,    0.0461,    0.0403,    0.0311,
          0.0061,    0.0030,   -0.0020,   -0.0020,   -0.0023,
          0.0606,    0.0416,    0.0293,    0.0248,    0.0180,
          0.0033,    0.0019,    0.0002,    0.0002,    0.0001},
      //  Dispersion Coefficients for O
      {0.0,    0.1213,    0.0928,    0.0716,    0.0630,    0.0492,
          0.0106,    0.0056,   -0.0025,   -0.0026,   -0.0030,
          0.1057,    0.0731,    0.0518,    0.0440,    0.0322,
          0.0060,    0.0036,    0.0004,    0.0004,    0.0003},
      //  Dispersion Coefficients for F
      {0.0,    0.1700,    0.1324,    0.1037,    0.0920,    0.0727,
          0.0171,    0.0096,   -0.0027,   -0.0028,   -0.0034,
          0.1710,    0.1192,    0.0851,    0.0725,    0.0534,
          0.0103,    0.0061,    0.0007,    0.0007,    0.0005},
      //  Dispersion Coefficients for Ne
      {0.0,    0.2257,    0.1793,    0.1426,    0.1273,    0.1019,
          0.0259,    0.0152,   -0.0025,   -0.0028,   -0.0037,
          0.2621,    0.1837,    0.1318,    0.1126,    0.0833,
          0.0164,    0.0098,    0.0012,    0.0011,    0.0008},
      //  Dispersion Coefficients for Na
      {0.0,    0.2801,    0.2295,    0.1857,    0.1670,    0.1353,
          0.0362,    0.0218,   -0.0028,   -0.0031,   -0.0044,
          0.3829,    0.2699,    0.1957,    0.1667,    0.1239,
          0.0249,    0.0150,    0.0019,    0.0017,    0.0012},
      //  Dispersion Coefficients for Mg
      {0.0,    0.3299,    0.2778,    0.2309,    0.2094,    0.1719,
          0.0486,    0.0298,   -0.0030,   -0.0034,   -0.0052,
          0.5365,    0.3812,    0.2765,    0.2373,    0.1771,
          0.0363,    0.0220,    0.0028,    0.0026,    0.0018},
      //  Dispersion Coefficients for Al
      {0.0,    0.3760,    0.3260,    0.2774,    0.2551,    0.2130,
          0.0645,    0.0406,   -0.0020,   -0.0026,   -0.0050,
          0.7287,    0.5212,    0.3807,    0.3276,    0.2455,
          0.0514,    0.0313,    0.0040,    0.0037,    0.0027},
      //  Dispersion Coefficients for Si
      {0.0,    0.3921,    0.3647,    0.3209,    0.2979,    0.2541,
          0.0817,    0.0522,   -0.0017,   -0.0025,   -0.0055,
          0.9619,    0.6921,    0.5081,    0.4384,    0.3302,
          0.0704,    0.0431,    0.0056,    0.0052,    0.0038},
      //  Dispersion Coefficients for P
      {0.0,    0.3821,    0.3898,    0.3592,    0.3388,    0.2955,
          0.1023,    0.0667,   -0.0002,   -0.0012,   -0.0050,
          1.2423,    0.8984,    0.6628,    0.5731,    0.4335,
          0.0942,    0.0580,    0.0077,    0.0071,    0.0052},
      //  Dispersion Coefficients for S
      {0.0,    0.3167,    0.3899,    0.3848,    0.3706,    0.3331,
          0.1246,    0.0826,    0.0015,    0.0003,   -0.0045,
          1.5665,    1.1410,    0.8457,    0.7329,    0.5567,
          0.1234,    0.0763,    0.0103,    0.0096,    0.0069},
      //  Dispersion Coefficients for Cl
      {0.0,    0.1832,    0.3508,    0.3920,    0.3892,    0.3639,
          0.1484,    0.0998,    0.0032,    0.0017,   -0.0042,
          1.9384,    1.4222,    1.0596,    0.9202,    0.7018,
          0.1585,    0.0984,    0.0134,    0.0125,    0.0091},
      //  Dispersion Coefficients for Ar
      {0.0,   -0.0656,    0.2609,    0.3696,    0.3880,    0.3843,
          0.1743,    0.1191,    0.0059,    0.0041,   -0.0030,
          2.3670,    1.7458,    1.3087,    1.1388,    0.8717,
          0.2003,    0.1249,    0.0174,    0.0162,    0.0118},
      //  Dispersion Coefficients for K
      {0.0,   -0.5083,    0.0914,    0.3068,    0.3532,    0.3868,
          0.2009,    0.1399,    0.0089,    0.0067,   -0.0017,
          2.8437,    2.1089,    1.5888,    1.3865,    1.0657,
          0.2494,    0.1562,    0.0219,    0.0204,    0.0149},
      //  Dispersion Coefficients for Ca
      {0.0,   -1.3666,   -0.1987,    0.1867,    0.2782,    0.3641,
          0.2262,    0.1611,    0.0122,    0.0097,   -0.0002,
          3.3694,    2.5138,    1.9032,    0.6648,    1.2855,
          0.3064,    0.1926,    0.0273,    0.0255,    0.0187},
      //  Dispersion Coefficients for Sc
      {0.0,   -5.4265,   -0.6935,   -0.0120,    0.1474,    0.3119,
          0.2519,    0.1829,    0.0159,    0.0130,    0.0015,
          4.0017,    2.9646,    2.2557,    1.9774,    1.5331,
          0.3716,    0.2348,    0.0338,    0.0315,    0.0231},
      //  Dispersion Coefficients for Ti
      {0.0,   -2.2250,   -1.6394,   -0.3318,   -0.0617,    0.2191,
          0.2776,    0.2060,    0.0212,    0.0179,    0.0047,
          0.5264,    3.4538,    2.6425,    2.3213,    1.8069,
          0.4457,    0.2830,    0.0414,    0.0387,    0.0284},
      //  Dispersion Coefficients for V
      {0.0,   -1.6269,   -4.4818,   -0.8645,   -0.3871,    0.0687,
          0.3005,    0.2276,    0.0259,    0.0221,    0.0070,
          0.6340,    0.4575,    3.0644,    2.6994,    2.1097,
          0.5294,    0.3376,    0.0500,    0.0468,    0.0344},
      //  Dispersion Coefficients for Cr
      {0.0,   -1.2999,   -2.1308,   -1.9210,   -0.9524,   -0.1635,
          0.3209,    0.2496,    0.0314,    0.0272,    0.0101,
          0.7569,    0.5468,    3.5251,    3.1130,    2.4439,
          0.6236,    0.3992,    0.0599,    0.0561,    0.0413},
      //  Dispersion Coefficients for Mn
      {0.0,   -1.0732,   -1.5980,   -3.5716,   -2.0793,   -0.5299,
          0.3368,    0.2704,    0.0377,    0.0330,    0.0139,
          0.8956,    0.6479,    0.4798,    3.5546,    2.8052,
          0.7283,    0.4681,    0.0712,    0.0666,    0.0492},
      //  Dispersion Coefficients for Fe
      {0.0,   -0.8901,   -1.2935,   -2.0554,   -3.3307,   -1.1336,
          0.3463,    0.2886,    0.0438,    0.0386,    0.0173,
          1.0521,    0.7620,    0.5649,    0.4901,    3.1974,
          0.8444,    0.5448,    0.0840,    0.0787,    0.0582},
      //  Dispersion Coefficients for Co
      {0.0,   -0.7307,   -1.0738,   -1.5743,   -2.0230,   -2.3653,
          0.3494,    0.3050,    0.0512,    0.0454,    0.0219,
          1.2272,    0.8897,    0.6602,    0.5731,    3.6143,
          0.9721,    0.6296,    0.0984,    0.0921,    0.0682},
      //  Dispersion Coefficients for Ni
      {0.0,   -0.5921,   -0.9005,   -1.2894,   -1.5664,   -3.0029,
          0.3393,    0.3147,    0.0563,    0.0500,    0.0244,
          1.4240,    1.0331,    0.7671,    0.6662,    0.5091,
          1.1124,    0.7232,    0.1146,    0.1074,    0.0796},
      //  Dispersion Coefficients for Cu
      {0.0,   -0.4430,   -0.7338,   -1.0699,   -1.2789,   -1.9646,
          0.3201,    0.3240,    0.0647,    0.0579,    0.0298,
          1.6427,    1.1930,    0.8864,    0.7700,    0.5888,
          1.2651,    0.8257,    0.1326,    0.1242,    0.0922},
      //  Dispersion Coefficients for Zn
      {0.0,   -0.3524,   -0.6166,   -0.9134,   -1.0843,   -1.5491,
          0.2839,    0.3242,    0.0722,    0.0648,    0.0344,
          1.8861,    1.3712,    1.0193,    0.8857,    0.6778,
          1.4301,    0.9375,    0.1526,    0.1430,    0.1063},
      //  Dispersion Coefficients for Ga
      {0.0,   -0.2524,   -0.4989,   -0.7701,   -0.9200,   -1.2846,
          0.2307,    0.3179,    0.0800,    0.0721,    0.0393,
          2.1518,    1.5674,    1.1663,    1.0138,    0.7763,
          1.6083,    1.0589,    0.1745,    0.1636,    0.1218},
      //  Dispersion Coefficients for Ge
      {0.0,   -0.1549,   -0.3858,   -0.6412,   -0.7781,   -1.0885,
          0.1547,    0.3016,    0.0880,    0.0796,    0.0445,
          2.4445,    1.7841,    1.3291,    1.1557,    0.8855,
          1.8001,    1.1903,    0.1987,    0.1863,    0.1389},
      //  Dispersion Coefficients for As
      {0.0,   -0.0687,   -0.2871,   -0.5260,   -0.6523,   -0.9300,
          0.0499,    0.2758,    0.0962,    0.0873,    0.0501,
          2.7627,    2.0194,    1.5069,    1.3109,    1.0051,
          2.0058,    1.3314,    0.2252,    0.2112,    0.1576},
      //  Dispersion Coefficients for Se
      {0.0,    0.0052,   -0.1919,   -0.4179,   -0.5390,   -0.7943,
         -0.0929,    0.2367,    0.1047,    0.0954,    0.0560,
          3.1131,    2.2784,    1.7027,    1.4821,    1.1372,
          2.2259,    1.4831,    0.2543,    0.2386,    0.1782},
      //  Dispersion Coefficients for Br
      {0.0,    0.0592,   -0.1095,   -0.3244,   -0.4363,   -0.6763,
         -0.2901,    0.1811,    0.1106,    0.1026,    0.0613,
          3.4901,    2.5578,    1.9140,    1.6673,    1.2805,
          2.4595,    1.6452,    0.2858,    0.2682,    0.2006},
      //  Dispersion Coefficients for Kr
      {0.0,    0.1009,   -0.0316,   -0.2303,   -0.3390,   -0.5657,
         -0.5574,    0.1067,    0.1180,    0.1082,    0.0668,
          3.9083,    2.8669,    2.1472,    1.8713,    1.4385,
          2.7079,    1.8192,    0.3197,    0.3003,    0.2251},
      //  Dispersion Coefficients for Rb
      {0.0,    0.1056,    0.0247,   -0.1516,   -0.2535,   -0.4688,
         -0.9393,    0.0068,    0.1247,    0.1146,    0.0717,
          4.3505,    3.1954,    2.3960,    2.0893,    1.6079,
          2.9676,    2.0025,    0.3561,    0.3346,    0.2514},
      //  Dispersion Coefficients for Sr
      {0.0,    0.1220,    0.1037,   -0.0489,   -0.1448,   -0.3528,
         -1.5307,   -0.1172,    0.1321,    0.1219,    0.0769,
          4.8946,    3.6029,    2.7060,    2.3614,    1.8200,
          3.2498,    2.2025,    0.3964,    0.3726,    0.2805},
      //  Dispersion Coefficients for Y
      {0.0,    0.0654,    0.1263,    0.0138,   -0.0720,   -0.2670,
         -2.7962,   -0.2879,    0.1380,    0.1278,    0.0819,
          5.4198,    3.9964,    3.0054,    2.6241,    2.0244,
          3.5667,    2.4099,    0.4390,    0.4128,    0.3112},
      //  Dispersion Coefficients for Zr
      {0.0,   -0.0304,    0.1338,    0.0659,   -0.0066,   -0.1862,
         -2.9673,   -0.5364,    0.1431,    0.1329,    0.0863,
          5.9818,    4.4226,    3.3301,    2.9086,    2.2449,
          0.5597,    2.6141,    0.4852,    0.4562,    0.3443},
      //  Dispersion Coefficients for Nb
      {0.0,   -0.1659,    0.1211,    0.1072,    0.0496,   -0.1121,
         -2.0727,   -0.8282,    0.1471,    0.1371,    0.0905,
          6.5803,    4.8761,    3.6768,    3.2133,    2.4826,
          0.6215,    2.8404,    0.5342,    0.5025,    0.3797},
      //  Dispersion Coefficients for Mo
      {0.0,   -0.3487,    0.0801,    0.1301,    0.0904,   -0.0483,
         -1.6832,   -1.2703,    0.1487,    0.1391,    0.0934,
          7.2047,    5.3484,    4.0388,    3.5326,    2.7339,
          0.6857,    3.0978,    0.5862,    0.5517,    0.4177},
      //  Dispersion Coefficients for Tc
      {0.0,   -0.6073,   -0.0025,    0.1314,    0.1164,    0.0057,
         -1.4390,   -2.0087,    0.1496,    0.1406,    0.0960,
          7.8739,    5.8597,    4.4331,    3.8799,    3.0049,
          0.7593,    3.3490,    0.6424,    0.6047,    0.4582},
      //  Dispersion Coefficients for Ru
      {0.0,   -0.9294,   -0.1091,    0.1220,    0.1331,    0.0552,
         -1.2594,   -5.3630,    0.1491,    0.1409,    0.0981,
          8.5988,    6.4069,    4.8540,    4.2509,    3.2960,
          0.8363,    3.6506,    0.7016,    0.6607,    0.5014},
      //  Dispersion Coefficients for Rh
      {0.0,   -1.3551,   -0.2630,    0.0861,    0.1305,    0.0927,
         -1.1178,   -2.5280,    0.1445,    0.1373,    0.0970,
          9.3504,    6.9820,    5.2985,    4.6432,    3.6045,
          0.9187,    0.5964,    0.7639,    0.7195,    0.5469},
      //  Dispersion Coefficients for Pd
      {0.0,   -1.9086,   -0.4640,    0.0279,    0.1128,    0.1215,
         -0.9988,   -1.9556,    0.1387,    0.1327,    0.0959,
         10.1441,    7.5938,    5.7719,    5.0613,    3.9337,
          1.0072,    0.6546,    0.8302,    0.7822,    0.5955},
      //  Dispersion Coefficients for Ag
      {0.0,   -2.5003,   -0.7387,   -0.0700,    0.0634,    0.1306,
         -0.8971,   -1.6473,    0.1295,    0.1251,    0.0928,
         10.9916,    8.2358,    6.2709,    5.5027,    4.2820,
          1.1015,    0.7167,    0.9001,    0.8484,    0.6469},
      //  Dispersion Coefficients for Cd
      {0.0,   -3.5070,   -1.1086,   -0.2163,   -0.0214,    0.1185,
         -0.8075,   -1.4396,    0.1171,    0.1147,    0.0881,
         11.9019,    8.9174,    6.8017,    5.9728,    4.6533,
          1.2024,    0.7832,    0.9741,    0.9185,    0.7013},
      //  Dispersion Coefficients for In
      {0.0,   -5.1325,   -1.5975,   -0.4165,   -0.1473,    0.0822,
         -0.7276,   -1.2843,    0.1013,    0.1012,    0.0816,
         12.6310,    9.6290,    7.3594,    6.4674,    5.0449,
          1.3100,    0.8542,    1.0519,    0.9922,    0.7587},
      //  Dispersion Coefficients for Sn
      {0.0,   -7.5862,   -2.2019,   -0.6686,   -0.3097,    0.0259,
         -0.6537,   -1.1587,    0.0809,    0.0839,    0.0728,
         13.5168,   10.3742,    7.9473,    6.9896,    5.4591,
          1.4246,    0.9299,    1.1337,    1.0697,    0.8192},
      //  Dispersion Coefficients for Sb
      {0.0,   -9.2145,   -3.0637,   -0.9868,   -0.5189,   -0.0562,
         -0.5866,   -1.0547,    0.0559,    0.0619,    0.0613,
         12.7661,   11.1026,    8.5620,    7.5367,    5.8946,
          1.5461,    1.0104,    1.2196,    1.1512,    0.8830},
      //  Dispersion Coefficients for Te
      {0.0,  -11.6068,   -4.2407,   -1.4022,   -0.7914,   -0.1759,
         -0.5308,   -0.9710,    0.0216,    0.0316,    0.0435,
         10.1013,   11.8079,    9.2067,    8.1113,    6.3531,
          1.6751,    1.0960,    1.3095,    1.2366,    0.9499},
      //  Dispersion Coefficients for I
      {0.0,  -13.9940,   -5.6353,   -1.9032,   -1.1275,   -0.3257,
         -0.4742,   -0.8919,   -0.0146,   -0.0001,    0.0259,
          3.4071,   12.6156,    9.8852,    8.7159,    6.8362,
          1.8119,    1.1868,    1.4037,    1.3259,    1.0201},
      //  Dispersion Coefficients for Xe
      {0.0,   -9.6593,   -8.1899,   -2.6313,   -1.5532,   -0.5179,
         -0.4205,   -0.8200,   -0.0565,   -0.0367,    0.0057,
          3.7063,   11.7407,   10.5776,    9.3585,    7.3500,
          1.9578,    1.2838,    1.5023,    1.4195,    1.0938},
      //  Dispersion Coefficients for Cs
      {0.0,   -8.1342,  -10.3310,   -3.5831,   -2.1433,   -0.7457,
         -0.3680,   -0.7527,   -0.1070,   -0.0809,   -0.0194,
          4.0732,   12.8551,   11.2902,   10.0454,    7.9052,
          2.1192,    1.3916,    1.6058,    1.5179,    1.1714},
      //  Dispersion Coefficients for Ba
      {0.0,   -7.2079,  -11.0454,   -4.6472,   -2.7946,   -1.0456,
         -0.3244,   -0.6940,   -0.1670,   -0.1335,   -0.0494,
          4.4110,   10.0919,   12.0003,   10.7091,    8.4617,
          2.2819,    1.5004,    1.7127,    1.6194,    1.2517},
      //  Dispersion Coefficients for La
      {0.0,   -6.5722,  -12.8190,   -6.3557,   -3.6566,   -1.4094,
         -0.2871,   -0.6411,   -0.2363,   -0.1940,   -0.0835,
          4.7587,    3.5648,   12.8927,   11.4336,    9.0376,
          2.4523,    1.6148,    1.8238,    1.7250,    1.3353},
      //  Dispersion Coefficients for Ce
      {0.0,   -6.0641,   -9.3304,   -8.0962,   -4.8792,   -1.8482,
         -0.2486,   -0.5890,   -0.3159,   -0.2633,   -0.1222,
          5.1301,    3.8433,   11.8734,   12.1350,    9.6596,
          2.6331,    1.7358,    1.9398,    1.8353,    1.4227},
      //  Dispersion Coefficients for Pr
      {0.0,   -5.6727,   -7.9841,  -10.9279,   -6.7923,   -2.4164,
         -0.2180,   -0.5424,   -0.4096,   -0.3443,   -0.1666,
          5.5091,    4.1304,    9.2394,   12.8653,   10.2820,
          2.8214,    1.8624,    2.0599,    1.9496,    1.5136},
      //  Dispersion Coefficients for Nd
      {0.0,   -5.3510,   -7.1451,  -10.5249,   -8.1618,   -3.1807,
         -0.1943,   -0.5012,   -0.5194,   -0.4389,   -0.2183,
          5.9005,    4.4278,    9.9814,   11.9121,   10.9079,
          3.0179,    1.9950,    2.1843,    2.0679,    1.6077},
      //  Dispersion Coefficients for Pm
      {0.0,   -5.0783,   -6.5334,  -13.2062,  -10.0720,   -4.0598,
         -0.1753,   -0.4626,   -0.6447,   -0.5499,   -0.2776,
          6.3144,    4.7422,    3.6278,    9.2324,   11.5523,
          3.2249,    2.1347,    2.3143,    2.1906,    1.7056},
      //  Dispersion Coefficients for Sm
      {0.0,   -4.8443,   -6.0570,   -9.3497,  -10.2609,   -5.3236,
         -0.1638,   -0.4287,   -0.7989,   -0.6734,   -0.3455,
          6.7524,    5.0744,    3.8839,    9.9412,   12.2178,
          3.4418,    2.2815,    2.4510,    2.3197,    1.8069},
      //  Dispersion Coefficients for Eu
      {0.0,   -4.6288,   -5.6630,   -7.9854,  -13.5405,   -8.9294,
         -0.1578,   -0.3977,   -0.9903,   -0.8137,   -0.4235,
          7.2035,    5.4178,    4.1498,    3.6550,   11.1857,
          3.6682,    2.4351,    2.5896,    2.4526,    1.9120},
      //  Dispersion Coefficients for Gd
      {0.0,   -4.5094,   -5.3778,   -7.1681,   -9.3863,   -8.8380,
         -0.1653,   -0.3741,   -1.2279,   -1.0234,   -0.5140,
          7.6708,    5.7756,    4.4280,    3.9016,   11.9157,
          3.9035,    2.5954,    2.7304,    2.5878,    2.0202},
      //  Dispersion Coefficients for Tb
      {0.0,   -4.3489,   -5.0951,   -6.5583,   -8.0413,   -9.1472,
         -0.1723,   -0.3496,   -1.5334,   -1.2583,   -0.6165,
          8.1882,    6.1667,    4.7292,    4.1674,    9.1891,
          4.1537,    2.7654,    2.8797,    2.7310,    2.1330},
      //  Dispersion Coefficients for Dy
      {0.0,   -4.1616,   -4.8149,   -6.0597,   -7.1503,   -9.8046,
         -0.1892,   -0.3302,   -1.9594,   -1.5632,   -0.7322,
          8.6945,    6.5527,    5.0280,    4.4320,    9.8477,
          4.4098,    2.9404,    3.0274,    2.8733,    2.2494},
      //  Dispersion Coefficients for Ho
      {0.0,   -4.0280,   -4.5887,   -5.6628,   -6.5338,  -14.9734,
         -0.2175,   -0.3168,   -2.6705,   -1.9886,   -0.8709,
          9.2302,    6.9619,    5.3451,    4.7129,    3.7046,
          4.6783,    3.1241,    3.1799,    3.0218,    2.3711},
      //  Dispersion Coefficients for Er
      {0.0,   -3.9471,   -4.4106,   -5.3448,   -6.0673,   -9.4367,
         -0.2586,   -0.3091,   -5.5645,   -2.6932,   -1.0386,
          9.7921,    7.3910,    5.6776,    5.0074,    3.9380,
          4.9576,    3.3158,    0.6167,    3.1695,    2.4949},
      //  Dispersion Coefficients for Tm
      {0.0,   -3.9079,   -4.2698,   -5.0823,   -5.6969,   -8.0393,
         -0.3139,   -0.3084,   -2.8957,   -5.6057,   -1.2397,
         10.3763,    7.8385,    6.0249,    5.3151,    4.1821,
          5.2483,    3.5155,    0.6569,    0.6192,    2.6240},
      //  Dispersion Coefficients for Yb
      {0.0,   -3.8890,   -4.1523,   -4.8591,   -5.3940,   -7.2108,
         -0.3850,   -0.3157,   -2.4144,   -2.9190,   -1.4909,
         10.9742,    8.2969,    6.3813,    5.6309,    4.4329,
          5.5486,    3.7229,    0.6994,    0.6592,    2.7538},
      //  Dispersion Coefficients for Lu
      {0.0,   -3.9056,   -4.0630,   -4.6707,   -5.1360,   -6.6179,
         -0.4720,   -0.3299,   -2.1535,   -2.4402,   -1.8184,
         11.5787,    8.7649,    6.7484,    5.9574,    4.6937,
          5.8584,    3.9377,    0.7436,    0.7010,    2.8890},
      //  Dispersion Coefficients for Hf
      {0.0,   -4.0452,   -4.0564,   -4.4593,   -4.9466,   -6.1794,
         -0.5830,   -0.3548,   -1.9785,   -2.1778,   -2.2909,
         12.2546,    9.2832,    7.1518,    6.3150,    4.9776,
          6.1852,    4.1643,    0.7905,    0.7454,    3.0246},
      //  Dispersion Coefficients for Ta
      {0.0,   -4.0905,   -3.9860,   -4.3912,   -4.7389,   -5.7959,
         -0.7052,   -0.3831,   -1.8534,   -2.0068,   -3.1639,
         12.9479,    9.8171,    7.5686,    6.6850,    5.2718,
          6.5227,    4.3992,    0.8392,    0.7915,    3.1610},
      //  Dispersion Coefficients for W
      {0.0,   -4.1530,   -3.9270,   -4.2486,   -4.5529,   -5.4734,
         -0.8490,   -0.4201,   -1.7565,   -1.8819,   -3.8673,
         13.6643,   10.3696,    8.0005,    7.0688,    5.5774,
          6.8722,    4.6430,    0.8905,    0.8388,    0.6433},
      //  Dispersion Coefficients for Re
      {0.0,   -4.2681,   -3.9052,   -4.1390,   -4.4020,   -5.2083,
         -1.0185,   -0.4693,   -1.6799,   -1.7868,   -2.8429,
         14.3931,   10.9346,    8.4435,    7.4631,    5.8923,
          7.2310,    4.8944,    0.9441,    0.8907,    0.6827},
      //  Dispersion Coefficients for Os
      {0.0,   -4.4183,   -3.9016,   -4.0478,   -4.2711,   -4.9801,
         -1.2165,   -0.5280,   -1.6170,   -1.7107,   -2.4688,
         15.1553,   11.5251,    8.9067,    7.8753,    6.2216,
          7.6030,    5.1558,    1.0001,    0.9437,    0.7238},
      //  Dispersion Coefficients for Ir
      {0.0,   -4.5860,   -3.9049,   -3.9606,   -4.1463,   -4.7710,
         -1.4442,   -0.5977,   -1.5648,   -1.6486,   -2.2499,
         15.9558,   12.1453,    9.3923,    8.3074,    6.5667,
          7.9887,    5.4269,    1.0589,    0.9993,    0.7669},
      //  Dispersion Coefficients for Pt
      {0.0,   -4.8057,   -3.9435,   -3.8977,   -4.0461,   -4.5932,
         -1.7033,   -0.6812,   -1.5228,   -1.5998,   -2.1036,
         16.7870,   12.7910,    9.8985,    8.7578,    6.9264,
          8.3905,    5.7081,    1.1193,    1.0565,    0.8116},
      //  Dispersion Coefficients for Au
      {0.0,   -5.0625,   -3.9908,   -3.8356,   -3.9461,   -4.4197,
         -2.0133,   -0.7638,   -1.4693,   -1.5404,   -1.9775,
         17.6400,   13.4551,   10.4202,    9.2222,    7.2980,
          8.8022,    5.9978,    1.1833,    1.1171,    0.8589},
      //  Dispersion Coefficients for Hg
      {0.0,   -5.4327,   -4.1029,   -3.8228,   -3.8921,   -4.2923,
         -2.3894,   -0.8801,   -1.4389,   -1.5055,   -1.8958,
         18.5241,   14.1473,   10.9650,    9.7076,    7.6849,
          9.2266,    6.2989,    1.2483,    1.1796,    0.9080},
      //  Dispersion Coefficients for Tl
      {0.0,   -5.8163,   -4.2233,   -3.8103,   -3.8340,   -4.1627,
         -2.8358,   -1.0117,   -1.4111,   -1.4740,   -1.8288,
         19.4378,   14.8643,   11.5300,   10.2108,    8.0900,
          9.6688,    6.6090,    1.3189,    1.2456,    0.9594},
      //  Dispersion Coefficients for Pb
      {0.0,   -6.4779,   -4.4167,   -3.8519,   -3.8236,   -4.0753,
         -3.3944,   -1.1676,   -1.3897,   -1.4497,   -1.7773,
         20.3336,   15.5987,   12.1106,   10.7292,    8.5060,
         10.1111,    6.9287,    1.3909,    1.3137,    1.0127},
      //  Dispersion Coefficients for Bi
      {0.0,   -7.0419,   -4.6533,   -3.9228,   -3.8408,   -4.0111,
         -4.1077,   -1.3494,   -1.3721,   -1.4290,   -1.7346,
         21.2196,   16.3448,   12.7017,   11.2575,    8.9310,
         10.2566,    7.2566,    1.4661,    1.3851,    1.0685},
      //  Dispersion Coefficients for Po
      {0.0,   -7.7195,   -4.9604,   -4.0267,   -3.8855,   -3.9670,
         -5.1210,   -1.5613,   -1.3584,   -1.4133,   -1.7005,
         22.1974,   17.1410,   13.3329,   11.8209,    9.3834,
         11.0496,    7.5986,    1.5443,    1.4592,    1.1266},
      //  Dispersion Coefficients for At
      {0.0,   -8.5994,   -5.3399,   -4.1781,   -3.9706,   -3.9588,
         -7.9122,   -1.8039,   -1.3540,   -1.4066,   -1.6784,
         23.2213,   17.9390,   13.9709,   12.3915,    9.8433,
          9.9777,    7.9509,    1.6260,    1.5367,    1.1876},
      //  Dispersion Coefficients for Rn
      {0.0,  -10.2749,   -5.7275,   -4.3331,   -4.0549,   -3.9487,
         -8.0659,   -2.0847,   -1.3475,   -1.3982,   -1.6571,
         24.2613,   18.7720,   14.6313,   12.9815,   10.3181,
         10.4580,    8.3112,    1.7103,    1.6167,    1.2504},
      //  Dispersion Coefficients for Fr
      {0.0,  -10.8938,   -6.2180,   -4.5387,   -4.1818,   -3.9689,
         -7.2224,   -2.4129,   -1.3404,   -1.3892,   -1.6367,
         24.3041,   19.6009,   15.3016,   13.5825,   10.8038,
          7.7847,    8.6839,    1.7986,    1.7004,    1.3162},
      //  Dispersion Coefficients for Ra
      {0.0,  -12.3462,   -6.7502,   -4.7764,   -4.3309,   -4.0088,
         -6.7704,   -2.8081,   -1.3462,   -1.3931,   -1.6299,
         25.5374,   20.4389,   15.9778,   14.1902,   11.2969,
          8.1435,    9.0614,    1.8891,    1.7863,    1.3840},
      //  Dispersion Coefficients for Ac
      {0.0,  -12.3496,   -7.4161,   -5.0617,   -4.5270,   -4.0794,
         -6.8494,   -3.2784,   -1.3473,   -1.3922,   -1.6190,
         25.1363,   21.3053,   16.6687,   14.8096,   11.7994,
          8.5178,    9.4502,    1.9845,    1.8770,    1.4553},
      //  Dispersion Coefficients for Th
      {0.0,  -13.6049,   -8.2118,   -5.3692,   -4.7310,   -4.1491,
         -7.2400,   -3.8533,   -1.3524,   -1.3955,   -1.6136,
         26.2511,   22.2248,   17.4018,   15.4642,   12.3296,
          8.8979,    9.8403,    2.0819,    1.9695,    1.5284},
      //  Dispersion Coefficients for Pa
      {0.0,  -14.4639,   -9.4459,   -5.7337,   -4.9639,   -4.2473,
         -8.0334,   -4.6067,   -1.3672,   -1.4083,   -1.6170,
         27.4475,   23.1548,   18.1406,   16.1295,   12.8681,
          9.2807,   10.2413,    2.1835,    2.0661,    1.6047},
      //  Dispersion Coefficients for U
      {0.0,  -12.3528,   -9.9362,   -6.1485,   -5.2392,   -4.3638,
         -9.6767,   -5.7225,   -1.3792,   -1.4184,   -1.6188,
         30.1725,   23.1239,   18.8728,   16.7952,   13.4090,
          9.6646,   10.6428,    2.2876,    1.1650,    1.6831},
      //  Dispersion Coefficients for Np
      {0.0,  -17.4143,  -11.1080,   -6.6136,   -5.5633,   -4.5053,
        -11.4937,   -6.9995,   -1.3941,   -1.4312,   -1.6231,
         31.7405,   24.1168,   19.6379,   17.4837,   13.9666,
          4.1493,    9.5876,    2.3958,    2.2679,    1.7648},
      //  Dispersion Coefficients for Pu
      {0.0,  -18.0862,  -11.4073,   -6.9721,   -5.8130,   -4.6563,
         -9.4100,  -13.5905,   -1.4180,   -1.4527,   -1.6351,
         33.8963,   23.2960,   20.1548,   17.9579,   14.3729,
          4.3056,    6.9468,    2.4979,    2.3652,    1.8430},
      //  Dispersion Coefficients for Am
      {0.0,  -19.7042,  -11.7097,   -7.7881,   -6.2920,   -4.8483,
         -7.8986,   -6.7022,   -1.4359,   -1.4684,   -1.6424,
         37.3716,   24.5715,   21.1738,   18.8618,   15.0877,
          4.5125,    7.3108,    2.6218,    2.4829,    1.9358},
      //  Dispersion Coefficients for Cm
      {0.0,  -24.9307,  -10.4100,   -8.6102,   -6.7506,   -5.0611,
         -7.3248,   -6.2891,   -1.4655,   -1.4952,   -1.6592,
         41.4852,   25.8115,   21.8880,   19.5119,   15.6355,
          4.6980,    7.6044,    2.7421,    2.5974,    2.0271},
      //  Dispersion Coefficients for Bk
      {0.0,  -32.8492,   -9.2185,   -9.3381,   -7.4293,   -5.3481,
         -6.8498,   -6.3438,   -1.4932,   -1.5203,   -1.6746,
         32.5421,   29.3028,   21.9514,   20.3581,   16.3190,
          4.9086,    7.9477,    2.8653,    2.7147,    2.1208},
      //  Dispersion Coefficients for Cf
      {0.0,  -23.6520,  -23.5202,   -9.7799,   -7.8616,   -5.5545,
         -6.6561,   -6.4144,   -1.5323,   -1.5562,   -1.6984,
         21.9334,   31.2999,   22.4858,   20.8536,   16.7428,
          5.0785,    8.1930,    2.9807,    2.8250,    2.2102}
      };


// Coefficients for analytical approximation to the scattering factors
// International Tables for Crystallography, Vol C, 501-503 [blue book]

const string TBXC[212+1] = {
        "",

        "H   ","H   ","H-1 ","HE  ","LI  ","LI+1","BE  ","BE+2","B   ","C   ",
        "CVAL","N   ","O   ","O-1 ","F   ","F-1 ","NE  ","NA  ","NA+1","MG  ",
        "MG+2","AL  ","AL+3","SI  ","SIV ","SI+4","P   ","S   ","CL  ","CL-1",
        "AR  ","K   ","K+1 ","CA  ","CA+2","SC  ","SC+3","TI  ","TI+2","TI+3",
        "TI+4","V   ","V+2 ","V+3 ","V+5 ","CR  ","CR+2","CR+3","MN  ","MN+2",
        "MN+3","MN+4","FE  ","FE+2","FE+3","CO  ","CO+2","CO+3","NI  ","NI+2",
        "NI+3","CU  ","CU+1","CU+2","ZN  ","ZN+2","GA  ","GA+3","GE  ","GE+4",
        "AS  ","SE  ","BR  ","BR-1","KR  ","RB  ","RB+1","SR  ","SR+2","Y   ",
        "Y+3 ","ZR  ","ZR+4","NB  ","NB+3","NB+5","MO  ","MO+3","MO+5","MO+6",
        "TC  ","RU  ","RU+3","RU+4","RH  ","RH+3","RH+4","PD  ","PD+2","PD+4",
        "AG  ","AG+1","AG+2","CD  ","CD+2","IN  ","IN+3","SN  ","SN+2","SN+4",
        "SB  ","SB+3","SB+5","TE  ","I   ","I-1 ","XE  ","CS  ","CS+1","BA  ",
        "BA+2","LA  ","LA+3","CE  ","CE+3","CE+4","PR  ","PR+3","PR+4","ND  ",
        "ND+3","PM  ","PM+3","SM  ","SM+3","EU  ","EU+2","EU+3","GD  ","GD+3",
        "TB  ","TB+3","DY  ","DY+3","HO  ","HO+3","ER  ","ER+3","TM  ","TM+3",
        "YB  ","YB+2","YB+3","LU  ","LU+3","HF  ","HF+4","TA  ","TA+5","W   ",
        "W+6 ","RE  ","OS  ","OS+4","IR  ","IR+3","IR+4","PT  ","PT+2","PT+4",
        "AU  ","AU+1","AU+3","HG  ","HG+1","HG+2","TL  ","TL+1","TL+3","PB  ",
        "PB+2","PB+4","BI  ","BI+3","BI+5","PO  ","AT  ","RN  ","FR  ","RA  ",
        "RA+2","AC  ","AC+3","TH  ","TH+4","PA  ","U   ","U+3 ","U+4 ","U+6 ",
        "NP  ","NP+3","NP+4","NP+6","PU  ","PU+3","PU+4","PU+6","AM  ","CM  ",
        "BK  ","CF  "
};

const float TBX[212+1][10+1] = {
    {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},

    {0.0, 0.493002   ,10.5109   ,0.322912   ,26.1257 ,   0.140191   ,3.14236   ,0.040810   ,57.7997   ,0.003038},
    {0.0, 0.489918   ,20.6593   ,0.262003   ,7.74039 ,   0.196767   ,49.5519   ,0.049879   ,2.20159   ,0.001305   },
    {0.0, 0.897661   ,53.1368   ,0.565616   ,15.1870 ,   0.415815   ,186.576   ,0.116973   ,3.56709   ,0.002389   },
    {0.0, 0.8734   , 9.1037   ,  0.6309   , 3.3568   ,   0.3112   ,22.9276   ,  0.1780   ,  0.9821   ,  0.0064   },
    {0.0,  1.1282   , 3.9546   ,  0.7508   , 1.0524  ,   0.6175   ,85.3905   ,  0.4653   ,168.261   ,  0.0377   },
    {0.0,   0.6968   , 4.6237   ,  0.7888   , 1.9557   ,   0.3414   ,  0.6316   ,  0.1563   ,10.0953   ,  0.0167   },
    {0.0,  1.5919   ,43.6427   , 1.1278   , 1.8623     ,   0.5391   ,103.483   ,  0.7029   ,  0.5420   ,  0.0385   },
    {0.0,  6.2603   ,  0.0027   ,  0.8849   ,  0.8313   ,   0.7993   , 2.2758   ,  0.1647   , 5.1146   ,-6.1092   },
    {0.0,  2.0545   ,23.2185   , 1.3326   , 1.0210     ,  1.0979   ,60.3498   ,  0.7068   ,  0.1403   , -0.1932   },
    {0.0,  2.3100   ,20.8439   , 1.0200   ,10.2075   ,  1.5886   ,  0.5687   ,  0.8650   ,51.6512   ,  0.2156   },
    {0.0, 2.26069   ,22.6907   ,1.56165   ,0.656665       , 1.05075   ,9.75618   ,0.839259   ,55.5949   ,0.286977   },
    {0.0, 12.2126   ,  0.0057   , 3.1322   , 9.8933   ,  2.0125   ,28.9975   , 1.1663   ,  0.5826   ,-11.529   },
    {0.0,  3.0485   ,13.2771   , 2.2868   , 5.7011   ,  1.5463   ,  0.3239   ,  0.8670   ,32.9089   ,  0.2508   },
    {0.0, 4.19160   ,12.8573   ,1.63969   ,4.17236   , 1.52673   ,47.0179   ,-20.307   ,-0.01404   ,21.9412   },
    {0.0,  3.5392   ,10.2825   , 2.6412   , 4.2944   ,  1.5170   ,  0.2615   , 1.0243   ,26.1476   ,  0.2776   },
    {0.0, 3.63220   ,5.27756   ,3.51057   ,14.7353   , 1.26064   ,0.442258   ,0.940706   ,47.3437   ,0.653396   },
    {0.0,  3.9553   , 8.4042   , 3.1125   , 3.4262   ,  1.4546   ,  0.2306   , 1.1251   ,21.7184   ,  0.3515   },
    {0.0,  4.7626   , 3.2850   , 3.1736   , 8.8422   ,  1.2674   ,  0.3136   , 1.1128   ,129.424   ,  0.6760   },
    {0.0,  3.2565   , 2.6671   , 3.9362   , 6.1153   ,  1.3998   ,  0.2001   , 1.0032   ,14.0390   ,  0.4040   },
    {0.0,  5.4204   , 2.8275   , 2.1735   ,79.2611   ,  1.2269   ,  0.3808   , 2.3073   , 7.1937   ,  0.8584   },
    {0.0,  3.4988   , 2.1676   , 3.8378   , 4.7542   ,  1.3284   ,  0.1850   ,  0.8497   ,10.1411   ,  0.4853   },
    {0.0,  6.4202   , 3.0387   , 1.9002   ,  0.7426  ,  1.5936   ,31.5472   , 1.9646   ,85.0886   , 1.1151   },
    {0.0, 4.17448   ,1.93816   ,3.38760   ,4.14553   , 1.20296   ,0.228753   ,0.528137   ,8.28524   ,0.706786   },
    {0.0,  6.2915   , 2.4386   , 3.0353   ,32.3337   ,  1.9891   ,  0.6785   , 1.5410   ,81.6937   , 1.1407   },
    {0.0, 5.66269   ,2.66520   ,3.07164   ,38.6634   , 2.62446   ,0.916946   ,1.39320   ,93.5458   ,1.24707   },
    {0.0, 4.43918   ,1.64167   ,3.20345   ,3.43757   , 1.19453   ,0.214900   ,0.416530   ,6.65365   ,0.746297   },
    {0.0,  6.4345   , 1.9067   , 4.1791   ,27.1570   ,  1.7800   ,  0.5260   , 1.4908   ,68.1645   , 1.1149   },
    {0.0,  6.9053   , 1.4679   , 5.2034   ,22.2151   ,  1.4379   ,  0.2536   , 1.5863   ,56.1720   ,  0.8669   },
    {0.0, 11.4604   ,  0.0104   , 7.1964   , 1.1662  ,  6.2556   ,18.5194   , 1.6455   ,47.7784   ,-9.5574   },
    {0.0, 18.2915   ,  0.0066   , 7.2084   , 1.1717  ,  6.5337   ,19.5424   , 2.3386   ,60.4486   ,-16.378   },
    {0.0,  7.4845   ,  0.9072   , 6.7723   ,14.8407  ,   0.6539   ,43.8983   , 1.6442   ,33.3929   , 1.4445   },
    {0.0,  8.2186   ,12.7949   , 7.4398   ,  0.7748  ,  1.0519   ,213.187   ,  0.8659   ,41.6841   , 1.4228   },
    {0.0,  7.9578   ,12.6331   , 7.4917   ,  0.7674  ,  6.3590   , -0.0020   , 1.1915   ,31.9128   ,-4.9978   },
    {0.0,  8.6266   ,10.4421   , 7.3873   ,  0.6599  ,  1.5899   ,85.7484   , 1.0211   ,178.437   , 1.3751   },
    {0.0, 15.6348   , -0.0074   , 7.9518   ,  0.6089 ,  8.4372   ,10.3116   ,  0.8537   ,25.9905   ,-14.875   },
    {0.0,  9.1890   , 9.0213   , 7.3679   ,  0.5729  ,  1.6409   ,136.108   , 1.4680   ,51.3531   , 1.3329   },
    {0.0, 13.4008   ,0.298540   ,8.02730   ,7.96290  , 1.65943   ,-0.28604   ,1.57936   ,16.0662   ,-6.6667   },
    {0.0,  9.7595   , 7.8508   , 7.3558   ,  0.5000  ,  1.6991   ,35.6338   , 1.9021   ,116.105   , 1.2807   },
    {0.0, 9.11423   ,7.52430   ,7.62174   ,0.457585  , 2.27930   ,19.5361   ,0.087899   ,61.6558   ,0.897155   },
    {0.0, 17.7344   ,0.220610   ,8.73816   ,7.04716  , 5.25691   ,-0.15762   ,1.92134   ,15.9768   ,-14.652   },
    {0.0, 19.5114   ,0.178847   ,8.23473   ,6.67018  , 2.01341   ,-0.29263   ,1.52080   ,12.9464   ,-13.280   },
    {0.0, 10.2971   , 6.8657   , 7.3511   ,  0.4385  ,  2.0703   ,26.8938   , 2.0571   ,102.478   , 1.2199   },
    {0.0, 10.1060   , 6.8818   , 7.3541   ,  0.4409  ,  2.2884   ,20.3004   ,  0.0223   ,115.122   , 1.2298   },
    {0.0, 9.43141   ,6.39535   ,7.74190   ,0.383349  , 2.15343   ,15.1908   ,0.016865   ,63.9690   ,0.656565   },
    {0.0, 15.6887   ,0.679003   ,8.14208   ,5.40135  , 2.03081   ,9.97278   ,-9.5760   ,0.940464   ,1.71430   },
    {0.0, 10.6406   , 6.1038   , 7.3537   ,  0.3920  ,  3.3240   ,20.2626   , 1.4922   ,98.7399   , 1.1832   },
    {0.0, 9.54034   ,5.66078   ,7.75090   ,0.344261  , 3.58274   ,13.3075   ,0.509107   ,32.4224   ,0.616898   },
    {0.0, 9.68090   ,5.59463   ,7.81136   ,0.334393  , 2.87603   ,12.8288   ,0.113575   ,32.8761   ,0.518275   },
    {0.0, 11.2819   , 5.3409   , 7.3573   ,  0.3432  ,  3.0193   ,17.8674   , 2.2441   ,83.7543   , 1.0896   },
    {0.0, 10.8061   , 5.2796   , 7.3620   ,  0.3435  ,  3.5268   ,14.3430   ,  0.2184   ,41.3235   , 1.0874   },
    {0.0, 9.84521   ,4.91797   ,7.87194   ,0.294393  , 3.56531   ,10.8171   ,0.323613   ,24.1281   ,0.393974   },
    {0.0, 9.96253   ,4.84850   ,7.97057   ,0.283303  , 2.76067   ,10.4852   ,0.054447   ,27.5730   ,0.251877   },
    {0.0, 11.7695   , 4.7611   , 7.3573   ,  0.3072  ,  3.5222   ,15.3535   , 2.3045   ,76.8805   , 1.0369   },
    {0.0, 11.0424   , 4.6538   , 7.3740   ,  0.3053  ,  4.1346   ,12.0546   ,  0.4399   ,31.2809   , 1.0097   },
    {0.0, 11.1764   , 4.6147   , 7.3863   ,  0.3005  ,  3.3948   ,11.6729   ,  0.0724   ,38.5566   ,  0.9707   },
    {0.0, 12.2841   , 4.2791   , 7.3409   ,  0.2784  ,  4.0034   ,13.5359   , 2.3488   ,71.1692   , 1.0118   },
    {0.0, 11.2296   , 4.1231   , 7.3883   ,  0.2726  ,  4.7393   ,10.2443   ,  0.7108   ,25.6466   ,  0.9324   },
    {0.0, 10.3380   ,3.90969   ,7.88173   ,0.238668  , 4.76795   ,8.35583   ,0.725591   ,18.3491   ,0.286667   },
    {0.0, 12.8376   , 3.8785   , 7.2920   ,  0.2565  ,  4.4438   ,12.1763   , 2.3800   ,66.3421   , 1.0341   },
    {0.0, 11.4166   , 3.6766   , 7.4005   ,  0.2449  ,  5.3442   , 8.8730   ,  0.9773   ,22.1626   ,  0.8614   },
    {0.0, 10.7806   ,3.54770   ,7.75868   ,0.223140  , 5.22746   ,7.64468   ,0.847114   ,16.9673   ,0.386044   },
    {0.0, 13.3380   , 3.5828   , 7.1676   ,  0.2470  ,  5.6158   ,11.3966   , 1.6735   ,64.8126   , 1.1910   },
    {0.0, 11.9475   , 3.3669   , 7.3573   ,  0.2274  ,  6.2455   , 8.6625   , 1.5578   ,25.8487   ,  0.8900   },
    {0.0, 11.8168   ,3.37484   ,7.11181   ,0.244078  , 5.78135   ,7.98760   ,1.14523   ,19.8970   ,1.14431   },
    {0.0, 14.0743   , 3.2655   , 7.0318   ,  0.2333  ,  5.1652   ,10.3163   , 2.4100   ,58.7097   , 1.3041   },
    {0.0, 11.9719   , 2.9946   , 7.3862   ,  0.2031  ,  6.4668   , 7.0826   , 1.3940   ,18.0995   ,  0.7807   },
    {0.0, 15.2354   , 3.0669   , 6.7006   ,  0.2412  ,  4.3591   ,10.7805   , 2.9623   ,61.4135   , 1.7189   },
    {0.0, 12.6920   ,2.81262   ,6.69883   ,0.227890  , 6.06692   ,6.36441   ,1.00660   ,14.4122   ,1.53545   },
    {0.0, 16.0816   , 2.8509   , 6.3747   ,  0.2516  ,  3.7068   ,11.4468   , 3.6830   ,54.7625   , 2.1313   },
    {0.0, 12.9172   ,2.53718   ,6.70003   ,0.205855  , 6.06791   ,5.47913   ,0.859041   ,11.6030   ,1.45572   },
    {0.0, 16.6723   , 2.6345   , 6.0701   ,  0.2647  ,  3.4313   ,12.9479   , 4.2779   ,47.7972   , 2.5310   },
    {0.0, 17.0006   , 2.4098   , 5.8196   ,  0.2726  ,  3.9731   ,15.2372   , 4.3543   ,43.8163   , 2.8409   },
    {0.0, 17.1789   , 2.1723   , 5.2358   ,16.5796   ,  5.6377   ,  0.2609   , 3.9851   ,41.4328   , 2.9557   },
    {0.0, 17.1718   , 2.2059   , 6.3338   ,19.3345   ,  5.5754   ,  0.2871   , 3.7272   ,58.1535   , 3.1776   },
    {0.0, 17.3555   , 1.9384   , 6.7286   ,16.5623   ,  5.5493   ,  0.2261   , 3.5375   ,39.3972   , 2.8250   },
    {0.0, 17.1784   , 1.7888   , 9.6435   ,17.3151   ,  5.1399   ,  0.2748   , 1.5292   ,164.934   , 3.4873   },
    {0.0, 17.5816   , 1.7139   , 7.6598   ,14.7957   ,  5.8981   ,  0.1603   , 2.7817   ,31.2087   , 2.0782   },
    {0.0, 17.5663   , 1.5564   , 9.8184   ,14.0988   ,  5.4220   ,  0.1664   , 2.6694   ,132.376   , 2.5064   },
    {0.0, 18.0874   , 1.4907   , 8.1373   ,12.6963   ,  2.5654   ,24.5651   ,-34.193   , -0.0138   ,41.4025   },
    {0.0, 17.7760   ,1.40290   ,10.2946   ,12.8006   , 5.72629   ,0.125599   ,3.26588   ,104.354   ,1.91213   },
    {0.0, 17.9268   ,1.35417   ,9.15310   ,11.2145   , 1.76795   ,22.6599   ,-33.108   ,-0.01319   ,40.2602   },
    {0.0, 17.8765   ,1.27618   ,10.9480   ,11.9160   , 5.41732   ,0.117622   ,3.65721   ,87.6627   ,2.06929   },
    {0.0, 18.1668   ,1.21480   ,10.0562   ,10.1483   , 1.01118   ,21.6054   ,-2.6479   ,-0.10276   ,9.41454   },
    {0.0, 17.6142   ,1.18865   ,12.0144   ,11.7660   , 4.04183   ,0.204785   ,3.53346   ,69.7957   ,3.75591   },
    {0.0, 19.8812   ,0.019175   ,18.0653   ,1.13305  , 11.0177   ,10.1621   ,1.94715   ,28.3389   ,-12.912   },
    {0.0, 17.9163   ,1.12446   ,13.3417   ,0.028781  , 10.7990   ,9.28206   ,0.337905   ,25.7228   ,-6.3934   },
    {0.0,  3.7025   ,  0.2772   ,17.2356   , 1.0958  , 12.8876   ,11.0040   , 3.7429   ,61.6584   , 4.3875   },
    {0.0, 21.1664   ,0.014734   ,18.2017   ,1.03031  , 11.7423   ,9.53659   ,2.30951   ,26.6307   ,-14.421   },
    {0.0, 21.0149   ,0.014345   ,18.0992   ,1.02238  , 11.4632   ,8.78809   ,0.740625   ,23.3452   ,-14.316   },
    {0.0, 17.8871   ,1.03649   ,11.1750   ,8.48061   , 6.57891   ,0.058881   ,0.0000   ,0.0000    ,0.344941   },
    {0.0, 19.1301   ,0.864132   ,11.0948   ,8.14487  , 4.64901   ,21.5707   ,2.71263   ,86.8472   ,5.40428   },
    {0.0, 19.2674   ,0.808520   ,12.9182   ,8.43467  , 4.86337   ,24.7997   ,1.56756   ,94.2928   ,5.37874   },
    {0.0, 18.5638   ,0.847329   ,13.2885   ,8.37164  , 9.32602   ,0.017662   ,3.00964   ,22.8870   ,-3.1892   },
    {0.0, 18.5003   ,0.844582   ,13.1787   ,8.12534  , 4.71304   ,0.036495   ,2.18535   ,20.8504   ,1.42357   },
    {0.0, 19.2957   ,0.751536   ,14.3501   ,8.21758  , 4.73425   ,25.8749   ,1.28918   ,98.6062   ,5.32800   },
    {0.0, 18.8785   ,0.764252   ,14.1259   ,7.84438  , 3.32515   ,21.2487   ,-6.1989   ,-0.01036   ,11.8678   },
    {0.0, 18.8545   ,0.760825   ,13.9806   ,7.62436  , 2.53464   ,19.3317   ,-5.6526   ,-0.01020   ,11.2835   },
    {0.0, 19.3319   ,0.698655   ,15.5017   ,7.98929  , 5.29537   ,25.2052   ,0.605844   ,76.8986   ,5.26593   },
    {0.0, 19.1701   ,0.696219   ,15.2096   ,7.55573  , 4.32234   ,22.5057   ,0.0000   ,0.0000   ,5.29160   },
    {0.0, 19.2493   ,0.683839   ,14.7900   ,7.14833  , 2.89289   ,17.9144   ,-7.9492   ,0.005127   ,13.0174   },
    {0.0, 19.2808   ,  0.6446   ,16.6885   , 7.4726  ,  4.8045   ,24.6605   , 1.0463   ,99.8156   , 5.1790   },
    {0.0, 19.1812   ,0.646179   ,15.9719   ,7.19123  , 5.27475   ,21.7326   ,0.357534   ,66.1147   ,5.21572   },
    {0.0, 19.1643   ,0.645643   ,16.2456   ,7.18544  , 4.37090   ,21.4072   ,0.0000   ,0.0000   ,5.21404   },
    {0.0, 19.2214   ,  0.5946   ,17.6444   , 6.9089  ,  4.4610   ,24.7008   , 1.6029   ,87.4825   , 5.0694   },
    {0.0, 19.1514   ,0.597922   ,17.2535   ,6.80639  , 4.47128   ,20.2521   ,0.0000   ,0.0000   ,5.11937   },
    {0.0, 19.1624   ,  0.5476   ,18.5596   , 6.3776  ,  4.2948   ,25.8499   , 2.0396   ,92.8029   , 4.9391   },
    {0.0, 19.1045   ,0.551522   ,18.1108   ,6.32470  , 3.78897   ,17.3595   ,0.0000   ,0.0000   ,4.99635   },
    {0.0, 19.1889   , 5.8303   ,19.1005   ,  0.5031  ,  4.4585   ,26.8909   , 2.4663   ,83.9571   , 4.7821   },
    {0.0, 19.1094   ,  0.5036   ,19.0548   , 5.8378  ,  4.5648   ,23.3752   ,  0.4870   ,62.2061   , 4.7861   },
    {0.0, 18.9333   , 5.7640   ,19.7131   ,  0.4655  ,  3.4182   ,14.0049   ,  0.0193   , -0.7583   , 3.9182   },
    {0.0, 19.6418   , 5.3034   ,19.0455   ,  0.4607  ,  5.0371   ,27.9074   , 2.6827   ,75.2825   , 4.5909   },
    {0.0, 18.9755   ,0.467196   ,18.9330   ,5.22126  , 5.10789   ,19.5902   ,0.288753   ,55.5113   ,4.69626   },
    {0.0, 19.8685   ,5.44853   ,19.0302   ,0.467973  , 2.41253   ,14.1259   ,0.0000   ,0.0000   ,4.69263   },
    {0.0, 19.9644   ,4.81742   ,19.0138   ,0.420885  , 6.14487   ,28.5284   ,2.52390   ,70.8403   ,4.35200   },
    {0.0, 20.1472   , 4.3470   ,18.9949   ,  0.3814  ,  7.5138   ,27.7660   , 2.2735   ,66.8776   , 4.0712   },
    {0.0, 20.2332   , 4.3579   ,18.9970   ,  0.3815  ,  7.8069   ,29.5259   , 2.8868   ,84.9304   , 4.0714   },
    {0.0, 20.2933   , 3.9282   ,19.0298   ,  0.3440  ,  8.9767   ,26.4659   , 1.9900   ,64.2658   , 3.7118   },
    {0.0, 20.3892   , 3.5690   ,19.1062   ,  0.3107  , 10.6620   ,24.3879   , 1.4953   ,213.904   , 3.3352   },
    {0.0, 20.3524   , 3.5520   ,19.1278   ,  0.3086  , 10.2821   ,23.7128   ,  0.9615   ,59.4565   , 3.2791   },
    {0.0, 20.3361   , 3.2160   ,19.2970   ,  0.2756  , 10.8880   ,20.2073   , 2.6959   ,167.202   , 2.7731   },
    {0.0, 20.1807   ,3.21367   ,19.1136   ,0.283310  , 10.9054   ,20.0558   ,0.773634   ,51.7460   ,3.02902   },
    {0.0, 20.5780   ,2.94817   ,19.5990   ,0.244475  , 11.3727   ,18.7726   ,3.28719   ,133.124   ,2.14678   },
    {0.0, 20.2489   ,2.92070   ,19.3763   ,0.250698  , 11.6323   ,17.8211   ,0.336048   ,54.9453   ,2.40860   },
    {0.0, 21.1671   ,2.81219   ,19.7695   ,0.226836  , 11.8513   ,17.6083   ,3.33049   ,127.113   ,1.86264   },
    {0.0, 20.8036   ,2.77691   ,19.5590   ,0.231540  , 11.9369   ,16.5408   ,0.612376   ,43.1692   ,2.09013   },
    {0.0, 20.3235   ,2.65941   ,19.8186   ,0.218850  , 12.1233   ,15.7992   ,0.144583   ,62.2355   ,1.59180   },
    {0.0, 22.0440   ,2.77393   ,19.6697   ,0.222087  , 12.3856   ,16.7669   ,2.82428   ,143.644   ,2.05830   },
    {0.0, 21.3727   ,2.64520   ,19.7491   ,0.214299  , 12.1329   ,15.3230   ,0.975180   ,36.4065   ,1.77132   },
    {0.0, 20.9413   ,2.54467   ,20.0539   ,0.202481  , 12.4668   ,14.8137   ,0.296689   ,45.4643   ,1.24285   },
    {0.0, 22.6845   ,2.66248   ,19.6847   ,0.210628  , 12.7740   ,15.8850   ,2.85137   ,137.903   ,1.98486   },
    {0.0, 21.9610   ,2.52722   ,19.9339   ,0.199237  , 12.1200   ,14.1783   ,1.51031   ,30.8717   ,1.47588   },
    {0.0, 23.3405   ,2.56270   ,19.6095   ,0.202088  , 13.1235   ,15.1009   ,2.87516   ,132.721   ,2.02876   },
    {0.0, 22.5527   ,2.41740   ,20.1108   ,0.185769  , 12.0671   ,13.1275   ,2.07492   ,27.4491   ,1.19499   },
    {0.0, 24.0042   ,2.47274   ,19.4258   ,0.196451  , 13.4396   ,14.3996   ,2.89604   ,128.007   ,2.20963   },
    {0.0, 23.1504   ,2.31641   ,20.2599   ,0.174081  , 11.9202   ,12.1571   ,2.71488   ,24.8242   ,0.954586   },
    {0.0, 24.6274   , 2.3879   ,19.0886   ,  0.1942  , 13.7603   ,13.7546   , 2.9227   ,123.174   , 2.5745   },
    {0.0, 24.0063   ,2.27783   ,19.9504   ,0.173530  , 11.8034   ,11.6096   ,3.87243   ,26.5156   ,1.36389   },
    {0.0, 23.7497   ,2.22258   ,20.3745   ,0.163940  , 11.8509   ,11.3110   ,3.26503   ,22.9966   ,0.759344   },
    {0.0, 25.0709   ,2.25341   ,19.0798   ,0.181951  , 13.8518   ,12.9331   ,3.54545   ,101.398   ,2.41960   },
    {0.0, 24.3466   ,2.13553   ,20.4208   ,0.155525  , 11.8708   ,10.5782   ,3.71490   ,21.7029   ,0.645089   },
    {0.0, 25.8976   ,2.24256   ,18.2185   ,0.196143  , 14.3167   ,12.6648   ,2.95354   ,115.362   ,3.58324   },
    {0.0, 24.9559   ,2.05601   ,20.3271   ,0.149525  , 12.2471   ,10.0499   ,3.77300   ,21.2773   ,0.691967   },
    {0.0, 26.5070   ,2.18020   ,17.6383   ,0.202172  , 14.5596   ,12.1899   ,2.96577   ,111.874   ,4.29728   },
    {0.0, 25.5395   ,1.98040   ,20.2861   ,0.143384  , 11.9812   ,9.34972   ,4.50073   ,19.5810   ,0.689690   },
    {0.0, 26.9049   ,2.07051   ,17.2940   ,0.197940  , 14.5583   ,11.4407   ,3.63837   ,92.6566   ,4.56796   },
    {0.0, 26.1296   ,1.91072   ,20.0994   ,0.139358  , 11.9788   ,8.80018   ,4.93676   ,18.5908   ,0.852795   },
    {0.0, 27.6563   ,2.07356   ,16.4285   ,0.223545  , 14.9779   ,11.3604   ,2.98233   ,105.703   ,5.92046   },
    {0.0, 26.7220   ,1.84659   ,19.7748   ,0.137290  , 12.1506   ,8.36225   ,5.17379   ,17.8974   ,1.17613   },
    {0.0, 28.1819   ,2.02859   ,15.8851   ,0.238849  , 15.1542   ,10.9975   ,2.98706   ,102.961   ,6.75621   },
    {0.0, 27.3083   ,1.78711   ,19.3320   ,0.136974  , 12.3339   ,7.96778   ,5.38348   ,17.2922   ,1.63929   },
    {0.0, 28.6641   ,1.98890   ,15.4345   ,0.257119  , 15.3087   ,10.6647   ,2.98963   ,100.417   ,7.56672   },
    {0.0, 28.1209   ,1.78503   ,17.6817   ,0.159970  , 13.3335   ,8.18304   ,5.14657   ,20.3900   ,3.70983   },
    {0.0, 27.8917   ,1.73272   ,18.7614   ,0.138790  , 12.6072   ,7.64412   ,5.47647   ,16.8153   ,2.26001   },
    {0.0, 28.9476   ,1.90182   ,15.2208   ,9.98519   , 15.1000   ,0.261033   ,3.71601   ,84.3298   ,7.97628   },
    {0.0, 28.4628   ,1.68216   ,18.1210   ,0.142292  , 12.8429   ,7.33727   ,5.59415   ,16.3535   ,2.97573   },
    {0.0, 29.1440   ,1.83262   ,15.1726   ,9.59990   , 14.7586   ,0.275116   ,4.30013   ,72.0290   ,8.58154   },
    {0.0, 28.8131   ,1.59136   ,18.4601   ,0.128903  , 12.7285   ,6.76232   ,5.59927   ,14.0366   ,2.39699   },
    {0.0, 29.2024   ,1.77333   ,15.2293   ,9.37046   , 14.5135   ,0.295977   ,4.76492   ,63.3644   ,9.24354   },
    {0.0, 29.1587   ,1.50711   ,18.8407   ,0.116741  , 12.8268   ,6.31524   ,5.38695   ,12.4244   ,1.78555   },
    {0.0, 29.0818   ,1.72029   ,15.4300   ,9.22590   , 14.4327   ,0.321703   ,5.11982   ,57.0560   ,9.88750   },
    {0.0, 29.4936   ,1.42755   ,19.3763   ,0.104621  , 13.0544   ,5.93667   ,5.06412   ,11.1972   ,1.01074   },
    {0.0, 28.7621   ,1.67191   ,15.7189   ,9.09227   , 14.5564   ,0.350500   ,5.44174   ,52.0861   ,10.4720   },
    {0.0, 28.1894   ,1.62903   ,16.1550   ,8.97948   , 14.9305   ,0.382661   ,5.67589   ,48.1647   ,11.0005   },
    {0.0, 30.4190   ,1.37113   ,15.2637   ,6.84706   , 14.7458   ,0.165191   ,5.06795   ,18.0030   ,6.49804   },
    {0.0, 27.3049   ,1.59279   ,16.7296   ,8.86553   , 15.6115   ,0.417916   ,5.83377   ,45.0011   ,11.4722   },
    {0.0, 30.4156   ,1.34323   ,15.8620   ,7.10909   , 13.6145   ,0.204633   ,5.82008   ,20.3254   ,8.27903   },
    {0.0, 30.7058   ,1.30923   ,15.5512   ,6.71983   , 14.2326   ,0.167252   ,5.53672   ,17.4911   ,6.96824   },
    {0.0, 27.0059   ,1.51293   ,17.7639   ,8.81174   , 15.7131   ,0.424593   ,5.78370   ,38.6103   ,11.6883   },
    {0.0, 29.8429   ,1.32927   ,16.7224   ,7.38979   , 13.2153   ,0.263297   ,6.35234   ,22.9426   ,9.85329   },
    {0.0, 30.9612   ,1.24813   ,15.9829   ,6.60834   , 13.7348   ,0.168640   ,5.92034   ,16.9392   ,7.39534   },
    {0.0, 16.8819   ,  0.4611   ,18.5913   , 8.6216  , 25.5582   , 1.4826   , 5.8600   ,36.3956   ,12.0658   },
    {0.0, 28.0109   ,1.35321   ,17.8204   ,7.73950   , 14.3359   ,0.356752   ,6.58077   ,26.4043   ,11.2299   },
    {0.0, 30.6886   ,1.21990   ,16.9029   ,6.82872   , 12.7801   ,0.212867   ,6.52354   ,18.6590   ,9.09680   },
    {0.0, 20.6809   ,  0.5450   ,19.0417   , 8.4484  , 21.6575   , 1.5729   , 5.9676   ,38.3246   ,12.6089   },
    {0.0, 25.0853   ,1.39507   ,18.4973   ,7.65105   , 16.8883   ,0.443378   ,6.48216   ,28.2262   ,12.0205   },
    {0.0, 29.5641   ,1.21152   ,18.0600   ,7.05639   , 12.8374   ,0.284738   ,6.89912   ,20.7482   ,10.6268   },
    {0.0, 27.5446   ,0.655150   ,19.1584   ,8.70751  , 15.5380   ,1.96347   ,5.52593   ,45.8149   ,13.1746   },
    {0.0, 21.3985   ,1.47110   ,20.4723   ,0.517394  , 18.7478   ,7.43463   ,6.82847   ,28.8482   ,12.5258   },
    {0.0, 30.8695   ,1.10080   ,18.3841   ,6.53852   , 11.9328   ,0.219074   ,7.00574   ,17.2114   ,9.80270   },
    {0.0, 31.0617   ,  0.6902   ,13.0637   , 2.3576  , 18.4420   , 8.6180   , 5.9696   ,47.2579   ,13.4118   },
    {0.0, 21.7886   ,1.33660   ,19.5682   ,0.488383  , 19.1406   ,6.77270   ,7.01107   ,23.8132   ,12.4734   },
    {0.0, 32.1244   ,1.00566   ,18.8003   ,6.10926   , 12.0175   ,0.147041   ,6.96886   ,14.7140   ,8.08428   },
    {0.0, 33.3689   ,  0.7040   ,12.9510   , 2.9238  , 16.5877   , 8.7937   , 6.4692   ,48.0093   ,13.5782   },
    {0.0, 21.8053   ,1.23560   ,19.5026   ,6.24149   , 19.1053   ,0.469999   ,7.10295   ,20.3185   ,12.4711   },
    {0.0, 33.5364   ,0.916540   ,25.0946   ,0.039042 , 19.2497   ,5.71414   ,6.91555   ,12.8285   ,-6.7994   },
    {0.0, 34.6726   ,0.700999   ,15.4733   ,3.55078  , 13.1138   ,9.55642   ,7.02588   ,47.0045   ,13.6770   },
    {0.0, 35.3163   ,0.685870   ,19.0211   ,3.97458  , 9.49887   ,11.3824   ,7.42518   ,45.4715   ,13.7108   },
    {0.0, 35.5631   ,  0.6631   ,21.2816   , 4.0691  ,  8.0037   ,14.0422   , 7.4433   ,44.2473   ,13.6905   },
    {0.0, 35.9299   ,0.646453   ,23.0547   ,4.17619  , 12.1439   ,23.1052   ,2.11253   ,150.645   ,13.7247   },
    {0.0, 35.7630   ,0.616341   ,22.9064   ,3.87135  , 12.4739   ,19.9887   ,3.21097   ,142.325   ,13.6211   },
    {0.0, 35.2150   ,0.604909   ,21.6700   ,3.57670  , 7.91342   ,12.6010   ,7.65078   ,29.8436   ,13.5431   },
    {0.0, 35.6597   ,0.589092   ,23.1032   ,3.65155  , 12.5977   ,18.5990   ,4.08655   ,117.020   ,13.5266   },
    {0.0, 35.1736   ,0.579689   ,22.1112   ,3.41437  , 8.19216   ,12.9187   ,7.05545   ,25.9443   ,13.4637   },
    {0.0, 35.5645   ,0.563359   ,23.4219   ,3.46204  , 12.7473   ,17.8309   ,4.80703   ,99.1722   ,13.4314   },
    {0.0, 35.1007   ,0.555054   ,22.4418   ,3.24498  , 9.78554   ,13.4661   ,5.29444   ,23.9533   ,13.3760   },
    {0.0, 35.8847   ,0.547751   ,23.2948   ,3.41519  , 14.1891   ,16.9235   ,4.17287   ,105.251   ,13.4287   },
    {0.0, 36.0228   ,  0.5293   ,23.4128   , 3.3253  , 14.9491   ,16.0927   , 4.1880   ,100.613   ,13.3966   },
    {0.0, 35.5747   ,0.520480   ,22.5259   ,3.12293  , 12.2165   ,12.7148   ,5.37073   ,26.3394   ,13.3092   },
    {0.0, 35.3715   ,0.516598   ,22.5326   ,3.05053  , 12.0291   ,12.5723   ,4.79840   ,23.4582   ,13.2671   },
    {0.0, 34.8509   ,0.507079   ,22.7584   ,2.89030  , 14.0099   ,13.1767   ,1.21457   ,25.2017   ,13.1665   },
    {0.0, 36.1874   ,0.511929   ,23.5964   ,3.25396  , 15.6402   ,15.3622   ,4.18550   ,97.4908   ,13.3573   },
    {0.0, 35.7074   ,0.502322   ,22.6130   ,3.03807  , 12.9898   ,12.1449   ,5.43227   ,25.4928   ,13.2544   },
    {0.0, 35.5103   ,0.498626   ,22.5787   ,2.96627  , 12.7766   ,11.9484   ,4.92159   ,22.7502   ,13.2116   },
    {0.0, 35.0136   ,0.489810   ,22.7286   ,2.81099  , 14.3884   ,12.3300   ,1.75669   ,22.6581   ,13.1130   },
    {0.0, 36.5254   ,0.499384   ,23.8083   ,3.26371  , 16.7707   ,14.9455   ,3.47947   ,105.980   ,13.3812   },
    {0.0, 35.8400   ,0.484938   ,22.7169   ,2.96118  , 13.5807   ,11.5331   ,5.66016   ,24.3992   ,13.1991   },
    {0.0, 35.6493   ,0.481422   ,22.6460   ,2.89020  , 13.3595   ,11.3160   ,5.18831   ,21.8301   ,13.1555   },
    {0.0, 35.1736   ,0.473204   ,22.7181   ,2.73848  , 14.7635   ,11.5530   ,2.28678   ,20.9303   ,13.0582   },
    {0.0, 36.6706   ,0.483629   ,24.0992   ,3.20647  , 17.3415   ,14.3136   ,3.49331   ,102.273   ,13.3592   },
    {0.0, 36.6488   ,0.465154   ,24.4096   ,3.08997  , 17.3990   ,13.4346   ,4.21665   ,88.4834   ,13.2887   },
    {0.0, 36.7881   ,0.451018   ,24.7736   ,3.04619  , 17.8919   ,12.8946   ,4.23284   ,86.0030   ,13.2754   },
    {0.0, 36.9185   ,0.437533   ,25.1995   ,3.00775  , 18.3317   ,12.4044   ,4.24391   ,83.7881   ,13.2674   }
};

const float TBM[98+1] = {
        0.0,

        1.0079  ,4.0026  ,6.94    ,9.01218 ,10.81   ,12.011   ,
        14.0067 ,15.999  ,18.9984 ,20.17   ,22.98977,24.305   ,
        26.98154,28.08   ,30.97376,32.06   ,35.453  ,39.94    ,
        39.09   ,40.08   ,44.9559 ,47.9    ,50.941  ,51.996   ,
        54.9380 ,55.84   ,58.9332 ,58.7    ,63.54   ,65.377   ,
        69.72   ,72.5    ,74.9216 ,78.9    ,79.904  ,83.80    ,
        85.467  ,87.62   ,88.9059 ,91.22   ,92.9064 ,95.9     ,
        98.9062 ,101.0   ,102.9055,106.4   ,107.868 ,112.40   ,
        114.82  ,118.6   ,121.70  ,127.60  ,126.9045,131.30   ,
        132.9054,137.30  ,138.905 ,140.12  ,140.9077,144.20   ,
        147.0   ,150.40  ,151.96  ,157.20  ,158.9254,162.50   ,
        164.9304,167.20  ,168.9342,173.0   ,174.97  ,178.4    ,
        180.947 ,183.8   ,186.2   ,190.2   ,192.2   ,195.0    ,
        196.9665,200.5   ,204.3   ,207.2   ,208.9804,210.0    ,
        210.0   ,222.0   ,223.0   ,226.0254,227.0   ,232.0381 ,
        231.0359,238.029 ,237.0482,242.0   ,243.0   ,247.0    ,
        247.0   ,249.0
    };



//                          *** COMPTON TABLE ***
//-----THE VALUES OF THE COSTANTS FOR  COMPTON SCATTERING ARE TAKEN
//     FROM:
//     V.H. SMITH JR. A.J. THAKKAR AND C. CHAPMAN
//     ACTA CRYST. (1975), A31, 391.

const float TCS[95+1][4+1] = {
{0.0, 0.0,0.0,0.0,0.0 },

//                    -----H -----
{0.0, 0.65390,-0.18456,8.2356,12.438 },
//                    -----HE-----
{0.0, 0.72391,-0.21464,9.1019,15.566 },
//                    -----LI-----
{0.0, 26.076,6.8817,26.299,0.88062 },
//                    -----BE-----
{0.0, 16.966,1117.7,40.948,103.99 },
//                    -----B -----
{0.0, 7.2997,272.81,22.693,34.403 },
//                    -----C -----
{0.0, 4.3353,93.125,14.656,14.628 },
//                    -----N -----
{0.0, 4.5051,40.965,11.061,7.3225 },
//                    -----O -----
{0.0, 3.2434,19.377,8.2735,4.0087 },
//                    -----F -----
{0.0, 2.7771,10.031,6.5952,2.3142 },
//                     -----NE-----
{0.0, 3.1880,5.6531,5.7748,1.3790 },
//                     -----NA-----
{0.0, 16.285,45.169,13.167,5.4569 },
//                     -----MG-----
{0.0, 115.98,3227.0,70.762,77.161 },
//                     -----AL-----
{0.0, 107.62,2740.9,67.151,59.872 },
//                     -----SI-----
{0.0, 80.719,1508.4,52.054,36.898 },
//                     -----P -----
{0.0, 55.933,703.48,37.402,20.872 },
//                     -----S -----
{0.0, 43.695,416.47,30.100,13.430 },
//                     -----CL-----
{0.0, 34.592,252.66,24.481,8.8480 },
//                     -----AR-----
{0.0, 27.153,150.48,19.697,5.8774 },
//                     -----K -----
{0.0, 30.545,193.71,21.865,6.5615 },
//                     -----CA-----
{0.0, 36.945,289.98,25.950,8.1578 },
//                     -----SC-----
{0.0, 33.212,232.59,23.472,6.8604 },
//                     -----TI-----
{0.0, 29.486,182.05,20.962,5.7117 },
//                     -----V -----
{0.0, 26.193,143.17,18.683,4.8164 },
//                     -----CR-----
{0.0, 18.929,72.508,13.819,3.0415 },
//                     -----MN-----
{0.0, 21.292,94.848,15.188,3.6204 },
//                     -----FE-----
{0.0, 19.276,77.511,13.788,3.1076 },
//                     -----CO-----
{0.0, 17.616,64.657,12.621,2.7056 },
//                     -----NI-----
{0.0, 16.346,55.896,11.687,2.4272 },
//                     -----CU-----
{0.0, 12.851,33.834,9.3436,1.7194 },
//                     -----ZN-----
{0.0, 14.619,45.462,10.338,2.0820 },
//                     -----GA-----
{0.0, 17.176,64.6920,11.820,2.5707 },
//                     -----GE-----
{0.0, 19.343,83.421,13.080,2.9211 },
//                     -----AS-----
{0.0, 19.471,84.720,13.126,2.8165 },
//                     -----SE-----
{0.0, 20.359,92.997,13.650,2.8488 },
//                     -----BR-----
{0.0, 20.316,92.534,13.623,2.7028 },
//                     -----KR-----
{0.0, 18.986,80.312,12.812,2.3584 },
//                     -----RB-----
{0.0, 21.269,101.61,14.209,2.6226 },
//                     -----SR-----
{0.0, 24.497,135.93,16.192,3.0174 },
//                     -----Y -----
{0.0, 24.539,136.20,16.237,2.9014 },
//                     -----ZR-----
{0.0, 23.692,126.53,15.732,2.6710 },
//                     -----NB-----
{0.0, 19.178,81.654,12.952,19.678 },
//                     -----MO-----
{0.0, 17.443,67.055,11.867,1.6907 },
//                     -----TC-----
{0.0, 18.256,73.766,12.363,1.7500 },
//                     -----RU-----
{0.0, 15.431,51.934,10.601,1.3610 },
//                     -----RH-----
{0.0, 14.236,43.914,9.8385,1.1954 },
//                     -----PD-----
{0.0, 12.125,31.377,8.4946,0.94341 },
//                     -----AG-----
{0.0, 11.910,30.295,8.3388,0.90612 },
//                     -----CD-----
{0.0, 12.283,32.428,8.5514,0.93212 },
//                     -----IN-----
{0.0, 12.893,36.009,8.9130,0.98158 },
//                     -----SN-----
{0.0, 13.547,40.031,9.3037,1.0326 },
//                     -----SB-----
{0.0, 13.486,39.657,9.2631,1.0057 },
//                     -----TE-----
{0.0, 14.490,46.190,9.8671,1.0869 },
//                     -----I -----
{0.0, 14.975,49.498,10.161,1.1116 },
//                     -----XE-----
{0.0, 14.885,48.883,10.102,1.0775 },
//                     -----CS-----
{0.0, 16.159,57.996,10.886,1.1773 },
//                     -----BA-----
{0.0, 17.835,71.158,11.921,13.128 },
//                     -----LA-----
{0.0, 18.225,74.363,12.167,1.3191 },
//                     -----CE-----
{0.0, 17.590,69.295,11.741,1.2501 },
//                     -----PR-----
{0.0, 16.613,61.934,11.071,1.1678 },
//                     -----ND-----
{0.0, 16.148,58.598,10.747,1.1195 },
//                     -----PM-----
{0.0, 15.741,55.777,10.458,10.774 },
//                     -----SM-----
{0.0, 15.359,53.212,10.182,1.0396 },
//                     -----EU-----
{0.0, 15.027,51.053,9.9393,1.0059 },
//                     -----GD-----
{0.0, 14.888,50.133,9.8426,0.97728 },
//                     -----TB-----
{0.0, 14.449,47.248,9.5464,0.93253 },
//                     -----DY-----
{0.0, 13.795,43.137,9.1027,0.87906 },
//                     -----HO-----
{0.0, 13.447,41.045,8.8604,0.84486 },
//                     -----ER-----
{0.0, 13.146,39.287,8.6467,0.81464 },
//                     -----TM-----
{0.0, 12.882,37.803,8.4552,0.78869 },
//                     -----YB-----
{0.0, 12.670,36.643,8.2968,0.76627 },
//                     -----LU-----
{0.0, 12.576,36.129,8.2264,0.74720 },
//                     -----HF-----
{0.0, 12.392,35.077,8.1062,0.72092 },
//                     -----TA-----
{0.0, 11.966,32.657,7.8420,0.67752 },
//                     -----W -----
{0.0, 11.429,29.720,7.5123,0.62773 },
//                     -----RE-----
{0.0, 10.841,26.660,7.1515,0.57682 },
//                     -----OS-----
{0.0, 10.553,25.229,6.9734,0.54767 },
//                     -----IR-----
{0.0, 10.255,23.781,6.7889,0.51891 },
//                     -----PT-----
{0.0, 9.1444,18.754,6.1116,0.43980 },
//                     -----AU-----
{0.0, 8.6692,16.793,5.8176,0.40417 },
//                     -----HG-----
{0.0, 8.8187,17.414,5.9035,0.40768 },
//                     -----TL-----
{0.0, 9.0707,18.476,6.0519,0.41721 },
//                     -----PB-----
{0.0, 9.3622,19.739,6.2252,0.42863 },
//                     -----BI-----
{0.0, 9.5574,20.605,6.3414,0.43371 },
//                     -----PO-----
{0.0, 9.9256,22.287,6.5624,0.44878 },
//                     -----AT-----
{0.0, 10.267,23.902,6.7681,0.46167 },
//                     -----RN-----
{0.0, 10.425,24.663,6.8643,0.46342 },
//                     -----FR-----
{0.0, 11.077,27.947,7.2583,0.49341 },
//                     -----RA-----
{0.0, 11.906,32.420,7.7600,0.53275 },
//                     -----AC-----
{0.0, 12.372,35.070,8.0440,0.55039 },
//                     -----TH-----
{0.0, 12.708,37.029,8.2501,0.56015 },
//                     -----PA-----
{0.0, 11.931,32.573,7.7684,0.51436 },
//                     -----U------
{0.0, 11.596,30.746,7.5590,0.49185 },
//                     -----NP-----
{0.0, 11.277,29.055,7.3579,0.47097 },
//                     -----PU-----
{0.0, 10.569,25.479,6.9123,0.43325 },
//                     -----AM-----
{0.0, 10.243,23.918,6.7044,0.41402 }
};



int NINT(double a)
{
    return rint(a);
}

double AMOD(double a, double p)
{
    double r;
    //r= double(int(a/p))*p;
    r = a - int(a/p)*p;
    return r;
}

int MOD(int a, int p)
{
    double r;
    //r= double(int(double(a)/double(p)))*p;
    r = a - int(double(a)/double(p))*p;
    return r;
}



double SIGN(double a, double b)
{
    if (b < 0.0)
    {
        return -abs(a);
    }
    else
    {
        return abs(a);
    }
}

int ISIGN(int a, int b)
{
    if (b < 0.0)
    {
        return -abs(a);
    }
    else
    {
        return abs(a);
    }
}



int LODGDF(int I, int J)
{
    return (I ^ J) & 307;
}

int iand(int a, int b)
{
    return a & b;
}

int ior(int a, int b)
{
    return a | b;
}

int ieor(int a, int b)
{
    return a ^ b;
}

int IFIX(double a)
{
    return int(a);
}







struct
{
    double SAVE[99+1][6+1];
    int NSAVE;
} dc;



struct
{
    double U, V, W,
          ULOR, VLOR, ZZZ, UC;
} g1;

struct
{


    int MAXSX, MCYCLX, ICYRUN;

    int IBGD;
} cntrls;


struct
{
    double FINAL[NFINAL+1][2+1];
    int ILOC;
} allp;

struct
{
    double POSI[30+1], SCAT[30+1];
} coeff;

struct
{
    double SCABKG[99+1];
} bkgscale;



struct
{
    int IVEC[99+1][192+1], MLTPHS[99+1], ICNTPHS[99+1];
} rtmtx;

struct
{
    int N;
    double SINLAM[30+1], F[30+1];
} cnv;

struct
{
    int NSPGRP, NAXIS, NCONT[10+1], NC, NPOL, MULTP;
} spgcom;

struct
{
    double VOLI[99+1], GCOM[99+1];
} volume;


struct
{
    double COND;
    int IORD1, IORD2;
    double TH;
    int NUM;
} g3;

struct
{
    int N, NMAX;
    int MULTX; // L
    double X[192+1],Y[192+1],Z[192+1];
    double XLT;
    int IXB; // KXB
    double NCTR[192+1];
} blnk1;

struct
{
    double TMASSA[99+1];
    int MLTPHASE;
    double XMLTP[99+1];


} multip;

struct
{
    int ISIMOP;
} simoper;

struct {
    int IHKL[3+1][24+1];
    double AZ[24+1];
    int NC1[10+1][7+1][99+1], ICHKL[99+1], N1HKL[99+1], IER;
} hklctl;

struct
{
    double a,b,c,alpha,beta,gamma,AL[3+1][3+1];
} cellx;

struct
{
    double DELT, TL, GAM1, GAM2, PRFDER;
    //int IPH_;
    double DELTA;
} prfx;

struct
{
    double TF1, TF2, TF4, TF6, TF8, TF9, C4;
} pvii;

struct
{
    double RL, DA1L, DA2L, DA3L, DA4L, DA5L, DA6L, DA7L, RH, DA1H, DA2H, DA3H,
          DA4H, DA5H, DA6H, DA7H;
} spvii;

struct
{
    int IBCKCODE;
} codebck;

struct
{
    double TANN[NOV+1], DERSTO[NOV+1][MSZ+1];
} g4;

struct
{
    double CC[4+1][16+1], ZEFF[16+1];

} comp;

struct
{
    double FI2[2+1];
} atfat;

struct
{
    int LB1, LB2, LB3;
    string TEST;
} labels;

string namefile3,namefile4,namefile5,namefile6,namefile11;
fstream file3,file4,file5,file6,file11,file31,file32,file33,file34,file35,file36,file37,file38;

// Lê ou grava um arquivo RIT, por padrão o arquivo com difratograma no DBWS
class FileRIT
{
public:
    double thetamax,thetamin,step;
    int count;
    string title;
    vector<double> y;
    bool error;

    FileRIT();
    void read(string);
    void write(string);
    void get(double v[]);
    void set(double v[], int start, int size);
};

FileRIT::FileRIT()
{
    error = false;
}

void FileRIT::read(string filename)
{
    fstream f;
    string line,buffer;
    int i;

    f.open(filename, ios::in);
    if (f.is_open())
    {
        getline(f,line);
        if (!f.bad())
        {
            thetamin = stof(line.substr(0,8));
            step     = stof(line.substr(1*8,8));
            thetamax = stof(line.substr(2*8,8));
            title    = line.substr(3*8,56);

            count = (thetamax - thetamin) / step + 1.5;

            buffer = "";
            while( getline(f,line) && (!error) )
            {
                if (!f.bad())
                {
                    buffer += line.substr(0,8*8);
                }
                else
                {
                    error = true;
                }
            }

            if (!error)
            {
                for (i = 1; i <= count; ++i)
                {
                    y.push_back(stof(buffer.substr((i-1)*8,7)));
                }
            }

            if (f.is_open())
            {
                f.close();
            }
        }
        else
        {
            error = true;
        }
    }
    else
    {
        error = true;
    }
}

void FileRIT::write(string)
{
    fstream f;
    int i;
    vector<double>::iterator it;

    f.open(namefile4, ios::out);
    if (f.is_open())
    {
        f << setw(8) << setprecision(4) << fixed << thetamin
          << setw(8) << setprecision(4) << fixed << step
          << setw(8) << setprecision(4) << fixed << thetamax << endl;

        i=0;
        for (it = y.begin() ; it != y.end(); ++it)
        {
            i++;
            f << setw(7) << setprecision(0) << fixed << *it << " ";
            if (i == 8)
            {
                i = 0 ;
                f << endl;
            }
        }

        f.close();
    }
    else
    {
        error = true;
    }
}

void FileRIT::get(double v[])
{
    int i;
    vector<double>::iterator it;

    i=0;
    for (it = y.begin() ; it != y.end(); ++it)
    {
        i++;
        v[i] = *it;
    }
}

void FileRIT::set(double v[], int start, int size)
{
    int i;
    vector<double>::iterator it;

    y.clear();
    for(i=start; i <= size; i++)
    {
        y.push_back(v[i]);
    }
}


// Class para o titulo do projeto. Antigamente a primeira linha do arquivo ICF.
class Title
{
public:
    void set(string);
    string get() const;
    Title& operator=(const string&);
    friend ostream& operator<< (ostream& stream, const Title&);
private:
    string value;
};

void Title::set(string v)
{
    value = v;
}

string Title::get() const
{
    return value;
}

Title& Title::operator=(const string& v)
{
    set(v);
    return *this;
}

ostream& operator<< (ostream& stream, const Title& v)
{
    string s;

    s = v.get();
    stream << s;
    return stream;
}

class JobType
{
public:
    void set(int);
    int get() const;
    operator int() const { return value; }
    JobType& operator=(const int&);
private:
    int value;
};

void JobType::set(int v)
{
    value = v;
}

int JobType::get() const
{
    return value;
}

JobType& JobType::operator=(const int& v)
{
    set(v);
    return *this;
}



class Variable
{
public:
    vector<double> oldvalues;                                     // Pilha para os valores antigos da variavel. Não utlizei stack pois é necessário listar todos os itens no final.
    virtual double get() const;
    virtual void set(double);
    virtual void clear();
    virtual void reset();
    operator double() const { return value; }
    Variable& operator=(const Variable&);
    Variable& operator=(const double&);

    Variable& operator+=(const double&);
    Variable& operator-=(const double&);
    Variable& operator*=(const double&);
    Variable& operator/=(const double&);

    Variable& operator+=(const Variable&);
    Variable& operator-=(const Variable&);
    Variable& operator*=(const Variable&);
    Variable& operator/=(const Variable&);
private:
    double value;
};

double Variable::get() const
{
     return value;
}

void Variable::set(double v)
{
    oldvalues.push_back(value);
    value = v;
}

void Variable::clear()
{
    value = 0.0;
}

void Variable::reset()
{
    value = 0.0;
    oldvalues.clear();
}

Variable& Variable::operator=(const Variable& v)
{
    set(v.value);
    return *this;
}

Variable& Variable::operator=(const double& v)
{
    set(v);
    return *this;
}

Variable& Variable::operator+=(const double& v)
{
    set(value + v);
    return *this;
}

Variable& Variable::operator-=(const double& v)
{
    set(value - v);
    return *this;
}

Variable& Variable::operator*=(const double& v)
{
    set(value * v);
    return *this;
}

Variable& Variable::operator/=(const double& v)
{
    set(value / v);
    return *this;
}

Variable& Variable::operator+=(const Variable& v)
{
    set(value + v.get());
    return *this;
}

Variable& Variable::operator-=(const Variable& v)
{
    set(value - v.get());
    return *this;
}

Variable& Variable::operator*=(const Variable& v)
{
    set(value * v.get());
    return *this;
}

Variable& Variable::operator/=(const Variable& v)
{
    set(value / v.get());
    return *this;
}




class Codeword
{
public:
    int L;
    void set(double);
    double get() const;
    operator double() const { return value; }
    Codeword& operator=(const Codeword&);
    Codeword& operator=(const double&);
    friend ostream& operator<< (ostream& stream, const Codeword&);
private:
    double value;
};

void Codeword::set(double v)
{
    value = v;
}

double Codeword::get() const
{
    return value;
}

Codeword& Codeword::operator=(const Codeword& v)
{
    set(v.get());
    return *this;
}

Codeword& Codeword::operator=(const double& v)
{
    set(v);
    return *this;
}

ostream& operator<< (ostream& stream, const Codeword& v)
{
    stream << setw(5) << setprecision(2) << fixed << v.get();
    return stream;
}













class Parameter : public Variable
{
public:
    double error;                                               // Old SY. O erro associado a variavel, δf1/δx1
    double increase;                                            // Old SZ. O incremento do vetor F(x) no metodo de Newton-Rhapson

    Codeword codeword;                                           // Old APAR
    Parameter& operator=(const Parameter&);
    Parameter& operator=(const double&);
private:
};


Parameter& Parameter::operator=(const Parameter& v)
{
    set(v.get());
    return *this;
}

Parameter& Parameter::operator=(const double& v)
{
    set(v);
    return *this;
}

class Atom
{
public:
    string ATEXT;
    int MURT;
    string NTYP;
    Parameter AtomPAR[11+1];

    int PTR;
    int PTC;

    double DERDIS[2+1];
    double SA,SB;
    double SNX,SNEX;
    double TEMP;
    double SUMAX[9+1], SUMBX[9+1];

    double DERISO, ISODER;
};






class Phase
{
public:
    Phase();
    int id;
    string name;
    int NATOM;
    int NMOL;
    double SAQF;
    double PREF[3+1];
    string SpaceGroup; // Old SYMB
    Parameter PAR[30+1];
    //int LPAR[30+1];

    //Parameter* a;       // cell a
    //Parameter* b;       // cell b
    //Parameter* c;       // cell c
    //Parameter* alpha;   // cell
    //Parameter* beta;    // cell
    //Parameter* gamma;   // cell
};


Phase::Phase()
{
    //a     = &PAR[6];
    //b     = &PAR[7];
    //c     = &PAR[8];
    //alpha = &PAR[9];
    //beta  = &PAR[10];
    //gamma = &PAR[11];
}



class Refs
{
public:
    int iphase;
    Phase* phase;
    int h,k,l;
    int lambda;
    double refs[3+1];  // refs[2] = 2teta
    double FMGNTD;           // O fator de estrutura do hkl
    double HALFL, HALFG, GAM;
    double FWHM[2+1];
    double APHASE;
    double TAVIX, SRIX;
    Refs& operator=(const Refs&);
};

Refs& Refs::operator=(const Refs& v)
{
    iphase = v.iphase;
    phase = v.phase;
    h = v.h;
    k = v.k;
    l = v.l;
    lambda = v.lambda;
    refs[1] = v.refs[1];
    refs[2] = v.refs[2];
    refs[3] = v.refs[3];
    FMGNTD = v.FMGNTD;
    HALFL = v.HALFL;
    HALFG = v.HALFG;
    GAM = v.GAM;
    FWHM[1] = v.FWHM[1];
    FWHM[2] = v.FWHM[2];
    APHASE = v.APHASE;
    TAVIX = v.TAVIX;
    SRIX = v.SRIX;
    return *this;
}


class DBWS
{
public:

    Title title;        // Define o titulo do projeto.
    JobType jobtyp;     // Define o tipo de trabalho, job type.
    int nprof;          // Define a função de perfil.
    int nphase;         // Armazena a quantidade de fases presentes no modelo inicial.

    int nbckgd;
    int nexcrg;
    int nscat;
    int instrm;
    int ipref;
    int iasym;
    int iabsr;
    int idata;

    int ias;
    int fondo;

    int r_iot,r_ipl,r_ipc, r_mat, r_nxt, r_lst1, r_lst2,
        r_lst3, r_ipl1, r_ipl2, r_iplst, r_iploss, r_iplcal, r_iplpol, r_iplcom,
        r_ipldis, r_iplam, r_ipbig;

    int mcycle;

    int MAXS;
    Parameter GLB[20+1];

    Atom atoms[NATS+1];




    Phase phases[99+1];


    double LAMDA[2+1];
    double RATIO[2+1];
    double BKPOS;
    double WDT;
    double CTHM;
    double TMV;
    double RLIM;
    double SW;

    double EPS;
    double RELAX[4+1];

    double THMIN, STEP, THMAX;

    double POS_[30+1];
    double BCK_[30+1];


    double ALOW[30+1];
    double AHIGH[30+1];

    string NAM_[16+1];
    double DFP[16+1];
    double DFPP[16+1];
    double XMAS[16+1];
    double AC_[10+1][16+1];
    //double POSI[30+1], SCAT[30+1];


    Variable R_p;
    Variable R_wp;
    Variable R_SS4;
    Variable R_SS2;
    Variable R_S1;
    Variable R_S2;
    Variable R_S3;
    Variable R_S4;
    Variable R_D1;
    Variable R_D2;
    Variable R_D4;


    int NPTS;               // Número de pontos experimentais em Y, antigo NPTS
    double Y_[IDSZ+1], VAR_[IDSZ+1], YC_[IDSZ+1];
    int KR_[IDSZ+1];
    double BK_[IDSZ+1];
    double AMORPHOUS_[IDSZ+1];
    double BKCOM_[IDSZ+1], BKDIS_[IDSZ+1], BKAM_[IDSZ+1], BKPOL_[IDSZ+1];

    int KRR_[2+1][IDSZ+1]; // <<<-!!!!!!!!


    Refs refs[IRS+1];
    int ICR_[99+1];


    double matrix[MSZ+1][MSZ+1], Fx[MSZ+1];  // Jacobian matrix

    DBWS();
    void read_icf_line1(string&);
    void read_icf_line2(string&);
    void read_icf_line2_2(string&);
    void read_icf_line3(string&);
    void read_icf_line4(string&);
    void read_icf_line5(string&);
    void read_icf_line6(string&, int);
    void read_icf_line7(string&, int);
    void read_icf_line8_1_neutron(string&, int);
    void read_icf_line8_1_xray(string&, int);
    void read_icf_line8_2_xray(string&, int);
    void read_icf_line9(string&);
    void read_icf_line10_1(string&);
    void read_icf_line10_1_1(string&);
    void read_icf_line10_2(string&);
    void read_icf_line10_2_1(string&);
    void read_icf_line10_3(string&);
    void read_icf_line10_3_1(string&);
    void read_icf_line10_11_1(string&, int);
    void read_icf_line10_11_2(string&, int);
    void read_icf_line10_11_3(string&, int);
    void read_icf_line10_11_4_1(string&, int);
    void read_icf_line10_11_4_2(string&, int);
    void read_icf_line10_11_4_3(string&, int);
    void read_icf_line10_11_4_4(string&, int);
    void read_icf_line10_11_5(string&, int);
    void read_icf_line10_11_5_1(string&, int);
    void read_icf_line10_11_6(string&, int);
    void read_icf_line10_11_6_1(string&, int);
    void read_icf_line10_11_7(string&, int);
    void read_icf_line10_11_7_1(string&, int);
    void read_icf_line10_11_8(string&, int);
    void read_icf_line10_11_8_1(string&, int);
    void read_icf_line10_11_91(string&, int);
    void read_icf_line10_11_91_1(string&, int);
    void read_icf_line10_11_93(string&, int);
    void read_icf_line10_11_93_1(string&, int);
    void read_icf_line10_11_95(string&, int);
    void read_icf_line10_11_95_1(string&, int);

    void write_file31();    // IT BUILDS THE OBSERVED DATA FILE CORRECTED FOR ABSORPTION
    void write_file32();    // IT BUILDS THE CALCULATED DATA FILE (BRAGG+COMPTON+DISORDINE+AMORPHOUS)
    void write_file33();    // IT BUILDS THE TOTAL COMPTON SCATTERING FILE FOR ALL PHASES
    void write_file34();    // IT BUILDS THE TOTAL DISORDER SCATTERING FILE FOR ALL PHASES
    void write_file36();    // IT BUILDS THE AMORPHOUS FILE
    void write_file37();    // IT BUILDS THE POLYNOMIAL BACKGROUND FILE
    void write_file38();    // IT BUILDS THE TOTAL PLOT FILE

private:

    double LAMDAM;
    double calc_lambdam();  // Calcula o lambda medio
    int search_wavelengths();

public:
    void GOTOER();
    void CV1(double AB[],double V[]);
    void CV2(double AB[],double* G);
    void STEEP(double X[],int N, int M);
    void COEF(int J,int K);
    void SPGP(string SPG);
    void SORT(int IPHASE);
    void ASSIGN();
    void CHISQ();
    void COMPTON(int K, double STH, double* CISK);
    void DISORDER(int K,double STH,int IDERIV,double *SDK,double *DYC,int FONDO);
    void SMTRY2(int IPHASE);
    void CALCUL(int NN);
    double GAMMA(double X);
    void PRSVII(double T);
    void MSPVII(double A, double W);
    double PROFIL(int N, double X);
    void SUMMAT(int IPM,double CSK[], double DISK[], double DYCDD[],double TOTCS);
    double DPINV(int N);
    void outscr(int I, double R2, double R3, double X);
    double ERROR(double A[][6+1],double B[],double OMEGA);
    void ESD(double SM[][6+1], double V[], double SUM);
    void DIRECT(double SM[][6+1],double V[], int IPH);
    void OUTPTR(int ICYCLE);
    void CEL000();
    void OPERTR(int I, int L2);
    void SYMOPR();
    void ITER();
    void RTMT(int IPRT, int IPHASE);
    void OP1(int IPHASE);
    void LOOKUP(int K, int N, int NSCAT, int IXRAY, int JOB);
    void CELL2(int NPHASE, double LAMDAM);
    double MULT(int IH,int IK,int IL,int KXIS);
    void REWRIT(int ISCALE, int IDIF);
    void EXPUT();
    void REFGEN(int IPHASE, double ZERO, double DIS, double TRANS, double PREFOR);
    void FINDC(int K,int NSCAT);
    void PHILIPSREAD();
    void GSASREAD();
    void SCINTAG();
    void READASC();
    void ABSORP(double MU, double SW, double TH, double *ABC);
    void INPTR();
    void INPAM();
};

DBWS::DBWS()
{
    int i;

    for(i=0; i < 99+1; i++) phases[i].id = i;
}

void DBWS::read_icf_line1(string& line)
{
    title = line.substr(0,70);
}

void DBWS::read_icf_line2(string& line)
{
    jobtyp    = stoi(line.substr(4*0,4));
    nprof     = stoi(line.substr(4*1,4));
    nphase    = stoi(line.substr(4*2,4));
    nbckgd     = stoi(line.substr(4*3,4));
    nexcrg  = stoi(line.substr(4*4,4));
    nscat   = stoi(line.substr(4*5,4));
    instrm  = stoi(line.substr(4*6,4));
    ipref   = stoi(line.substr(4*7,4));
    iasym   = stoi(line.substr(4*8,4));
    iabsr   = stoi(line.substr(4*9,4));
    idata   = stoi(line.substr(4*10,4));
}

void DBWS::read_icf_line2_2(string& line)
{
    ias = stoi(line.substr(0,4));
    fondo = stoi(line.substr(4,4));
}

void DBWS::read_icf_line3(string& line)
{
    r_iot    = stoi(line.substr(0,1));
    r_ipl    = stoi(line.substr(1,1));
    r_ipc    = stoi(line.substr(2,1));
    r_mat    = stoi(line.substr(3,1));
    r_nxt    = stoi(line.substr(4,1));

    r_lst1   = stoi(line.substr(6,1));
    r_lst2   = stoi(line.substr(7,1));
    r_lst3   = stoi(line.substr(8,1));
    r_ipl1   = stoi(line.substr(9,1));
    r_ipl2   = stoi(line.substr(10,1));

    r_iplst  = stoi(line.substr(12,1));
    r_iploss = stoi(line.substr(13,1));
    r_iplcal = stoi(line.substr(14,1));
    r_iplpol = stoi(line.substr(15,1));
    r_iplcom = stoi(line.substr(16,1));

    r_ipldis = stoi(line.substr(18,1));
    r_iplam  = stoi(line.substr(19,1));
    r_ipbig  = stoi(line.substr(20,1));
}

void DBWS::read_icf_line4(string& line)
{
    LAMDA[1]     = stof(line.substr(0,8));
    LAMDA[2]     = stof(line.substr(1*8,8));
    RATIO[2] = stof(line.substr(2*8,8));
    BKPOS        = stof(line.substr(3*8,8));
    WDT          = stof(line.substr(4*8,8));
    CTHM         = stof(line.substr(5*8,8));
    TMV          = stof(line.substr(6*8,8));
    RLIM         = stof(line.substr(7*8,8));
    SW       = stof(line.substr(8*8,8));
}

void DBWS::read_icf_line5(string& line)
{
    mcycle = stoi(line.substr(0*4,4));
    EPS = stof(line.substr(1*4,4));
    RELAX[1] = stof(line.substr(2*4,4));
    RELAX[2] = stof(line.substr(3*4,4));
    RELAX[3] = stof(line.substr(4*4,4));
    RELAX[4] = stof(line.substr(5*4,4));
    if (jobtyp > 2)
    {
        THMIN  = stof(line.substr(3*8,8));
        STEP   = stof(line.substr(4*8,8));
        THMAX  = stof(line.substr(5*8,8));
    }
}

void DBWS::read_icf_line6(string& line, int i)
{
    POS_[i] = stof(line.substr(0,8));
    BCK_[i] = stof(line.substr(8,8));
}

void DBWS::read_icf_line7(string& line, int i)
{
    ALOW[i] = stof(line.substr(0,8));
    AHIGH[i] = stof(line.substr(8,8));
}

void DBWS::read_icf_line8_1_neutron(string& line, int i)
{
    NAM_[i] = line.substr(0,4);
    DFP[i] = stof(line.substr(4,8));
    XMAS[i] = stof(line.substr(12,8));
}

void DBWS::read_icf_line8_1_xray(string& line, int i)
{
    NAM_[i] = line.substr(0,4);
    DFP[i] = stof(line.substr(4,8));
    DFPP[i] = stof(line.substr(12,8));
    XMAS[i] = stof(line.substr(20,8));
}

void DBWS::read_icf_line8_2_xray(string& line, int i)
{
    string tmp;

    tmp = line.substr(0*8,8);
    if (tmp.empty() || tmp == "        ")
    {
        AC_[1][i] = 0.0;
    }
    else
    {
        AC_[1][i] = stof(tmp);
    }

    tmp = line.substr(1*8,8);
    if (tmp.empty() || tmp == "        ")
    {
        AC_[2][i] = 0.0;
    }
    else
    {
        AC_[2][i] = stof(tmp);
    }

    tmp = line.substr(2*8,8);
    if (tmp.empty() || tmp == "        ")
    {
        AC_[3][i] = 0.0;
    }
    else
    {
        AC_[3][i] = stof(tmp);
    }

    tmp = line.substr(3*8,8);
    if (tmp.empty() || tmp == "        ")
    {
        AC_[4][i] = 0.0;
    }
    else
    {
        AC_[4][i] = stof(tmp);
    }

    tmp = line.substr(4*8,8);
    if (tmp.empty() || tmp == "        ")
    {
        AC_[5][i] = 0.0;
    }
    else
    {
        AC_[5][i] = stof(tmp);
    }

    tmp = line.substr(5*8,8);
    if (tmp.empty() || tmp == "        ")
    {
        AC_[6][i] = 0.0;
    }
    else
    {
        AC_[6][i] = stof(tmp);
    }

    tmp = line.substr(6*8,8);
    if (tmp.empty() || tmp == "        ")
    {
        AC_[7][i] = 0.0;
    }
    else
    {
        AC_[7][i] = stof(tmp);
    }

    tmp = line.substr(7*8,8);
    if (tmp.empty() || tmp == "        ")
    {
        AC_[8][i] = 0.0;
    }
    else
    {
        AC_[8][i] = stof(tmp);
    }

    tmp = line.substr(8*8,8);
    if (tmp.empty() || tmp == "        ")
    {
        AC_[9][i] = 0.0;
    }
    else
    {
        AC_[9][i] = stof(tmp);
    }
}

void DBWS::read_icf_line9(string& line)
{
    MAXS = stoi(line.substr(0,8));
}

void DBWS::read_icf_line10_1(string& line)
{
    GLB[1]  = stof(line.substr(0*8,8));
    GLB[10] = stof(line.substr(1*8,8));
    GLB[11] = stof(line.substr(2*8,8));
    GLB[8]  = stof(line.substr(3*8,8));
    GLB[9]  = stof(line.substr(4*8,8));
    GLB[12] = stof(line.substr(5*8,8));
    GLB[13] = stof(line.substr(6*8,8));
}

void DBWS::read_icf_line10_1_1(string& line)
{
    GLB[1].codeword  = stof(line.substr(0*8,8));
    GLB[10].codeword  = stof(line.substr(1*8,8));
    GLB[11].codeword = stof(line.substr(2*8,8));
    GLB[8].codeword  = stof(line.substr(3*8,8));
    GLB[9].codeword  = stof(line.substr(4*8,8));
    GLB[12].codeword = stof(line.substr(5*8,8));
    GLB[13].codeword = stof(line.substr(6*8,8));
}

void DBWS::read_icf_line10_2(string& line)
{
    GLB[20] = stof(line.substr(0*8,8));
    GLB[18] = stof(line.substr(1*8,8));
    GLB[19] = stof(line.substr(2*8,8));
}

void DBWS::read_icf_line10_2_1(string& line)
{
    GLB[20].codeword = stof(line.substr(0*8,8));
    GLB[18].codeword = stof(line.substr(1*8,8));
    GLB[19].codeword = stof(line.substr(2*8,8));
}

void DBWS::read_icf_line10_3(string& line)
{
    GLB[2] = stof(line.substr(9*0,9));
    GLB[3] = stof(line.substr(9*1,9));
    GLB[4] = stof(line.substr(9*2,9));
    GLB[5] = stof(line.substr(9*3,9));
    GLB[6] = stof(line.substr(9*4,9));
    GLB[7] = stof(line.substr(9*5,9));
}

void DBWS::read_icf_line10_3_1(string& line)
{
    GLB[2].codeword = stof(line.substr(9*0,9));
    GLB[3].codeword = stof(line.substr(9*1,9));
    GLB[4].codeword = stof(line.substr(9*2,9));
    GLB[5].codeword = stof(line.substr(9*3,9));
    GLB[6].codeword = stof(line.substr(9*4,9));
    GLB[7].codeword = stof(line.substr(9*5,9));
}

void DBWS::read_icf_line10_11_1(string& line, int K)
{
    phases[K].name = line.substr(0,50);
}

void DBWS::read_icf_line10_11_2(string& line, int K)
{
    phases[K].NATOM = stoi(line.substr(0,4));
    phases[K].NMOL  = stoi(line.substr(4,4));
    phases[K].SAQF = stof(line.substr(8,8));
    phases[K].PREF[1] = stof(line.substr(4*4,4));
    phases[K].PREF[2] = stof(line.substr(5*4,4));
    phases[K].PREF[3] = stof(line.substr(6*4,4));
}

void DBWS::read_icf_line10_11_3(string& line, int K)
{
     phases[K].SpaceGroup = " " + line.substr(0,20);         //vvv mudar isso!!!!!!!!!!!
}

void DBWS::read_icf_line10_11_4_1(string& line, int i)
{
    atoms[i].ATEXT = line.substr(0,4);
    atoms[i].MURT = stoi(line.substr(5,4));
    atoms[i].NTYP = line.substr(10,4);
    atoms[i].AtomPAR[1] = stof(line.substr(17,8));
    atoms[i].AtomPAR[2] = stof(line.substr(25,8));
    atoms[i].AtomPAR[3] = stof(line.substr(33,8));
    atoms[i].AtomPAR[4] = stof(line.substr(41,8));
    atoms[i].AtomPAR[5] = stof(line.substr(49,8));
}

void DBWS::read_icf_line10_11_4_2(string& line, int i)
{
    atoms[i].AtomPAR[1].codeword = stof(line.substr(17,8));
    atoms[i].AtomPAR[2].codeword = stof(line.substr(25,8));
    atoms[i].AtomPAR[3].codeword = stof(line.substr(33,8));
    atoms[i].AtomPAR[4].codeword = stof(line.substr(41,8));
    atoms[i].AtomPAR[5].codeword = stof(line.substr(49,8));
}

void DBWS::read_icf_line10_11_4_3(string& line, int i)
{
    atoms[i].AtomPAR[6] = stof(line.substr(0,8));
    atoms[i].AtomPAR[7] = stof(line.substr(8,8));
    atoms[i].AtomPAR[8] = stof(line.substr(16,8));
    atoms[i].AtomPAR[9] = stof(line.substr(24,8));
    atoms[i].AtomPAR[10] = stof(line.substr(32,8));
    atoms[i].AtomPAR[11] = stof(line.substr(40,8));
}

void DBWS::read_icf_line10_11_4_4(string& line, int i)
{
    atoms[i].AtomPAR[6].codeword = stof(line.substr(0,8));
    atoms[i].AtomPAR[7].codeword = stof(line.substr(8,8));
    atoms[i].AtomPAR[8].codeword = stof(line.substr(16,8));
    atoms[i].AtomPAR[9].codeword = stof(line.substr(24,8));
    atoms[i].AtomPAR[10].codeword = stof(line.substr(32,8));
    atoms[i].AtomPAR[11].codeword = stof(line.substr(40,8));
}

void DBWS::read_icf_line10_11_5(string& line, int K)
{
    phases[K].PAR[1] = stof(line.substr(0,8));
    phases[K].PAR[2] = stof(line.substr(8,8));
}

void DBWS::read_icf_line10_11_5_1(string& line, int K)
{
    phases[K].PAR[1].codeword = stof(line.substr(0,8));
    phases[K].PAR[2].codeword = stof(line.substr(8,8));
}

void DBWS::read_icf_line10_11_6(string& line, int K)
{
    phases[K].PAR[3] = stof(line.substr(0*8,8));
    phases[K].PAR[4] = stof(line.substr(1*8,8));
    phases[K].PAR[5] = stof(line.substr(2*8,8));
    phases[K].PAR[21] = stof(line.substr(3*8,8));
    phases[K].PAR[20] = stof(line.substr(4*8,8));
    phases[K].PAR[15] = stof(line.substr(5*8,8));
    phases[K].PAR[16] = stof(line.substr(6*8,8));
}

void DBWS::read_icf_line10_11_6_1(string& line, int K)
{
    phases[K].PAR[3].codeword = stof(line.substr(0*8,8));
    phases[K].PAR[4].codeword = stof(line.substr(1*8,8));
    phases[K].PAR[5].codeword = stof(line.substr(2*8,8));
    phases[K].PAR[21].codeword = stof(line.substr(3*8,8));
    phases[K].PAR[20].codeword = stof(line.substr(4*8,8));
    phases[K].PAR[15].codeword = stof(line.substr(5*8,8));
    phases[K].PAR[16].codeword = stof(line.substr(6*8,8));
}

void DBWS::read_icf_line10_11_7(string& line, int K)
{
    phases[K].PAR[6] = stof(line.substr(0*8,8));
    phases[K].PAR[7] = stof(line.substr(1*8,8));
    phases[K].PAR[8] = stof(line.substr(2*8,8));
    phases[K].PAR[9] = stof(line.substr(3*8,8));
    phases[K].PAR[10]  = stof(line.substr(4*8,8));
    phases[K].PAR[11] = stof(line.substr(5*8,8));
}

void DBWS::read_icf_line10_11_7_1(string& line, int K)
{
    phases[K].PAR[6].codeword = stof(line.substr(0*8,8));
    phases[K].PAR[7].codeword = stof(line.substr(1*8,8));
    phases[K].PAR[8].codeword = stof(line.substr(2*8,8));
    phases[K].PAR[9].codeword = stof(line.substr(3*8,8));
    phases[K].PAR[10].codeword = stof(line.substr(4*8,8));
    phases[K].PAR[11].codeword  = stof(line.substr(5*8,8));
}

void DBWS::read_icf_line10_11_8(string& line, int K)
{
    phases[K].PAR[12] = stof(line.substr(0*8,8));
    phases[K].PAR[13] = stof(line.substr(1*8,8));
    phases[K].PAR[14] = stof(line.substr(2*8,8));
}

void DBWS::read_icf_line10_11_8_1(string& line, int K)
{
    phases[K].PAR[12].codeword = stof(line.substr(0*8,8));
    phases[K].PAR[13].codeword = stof(line.substr(1*8,8));
    phases[K].PAR[14].codeword = stof(line.substr(2*8,8));
}

void DBWS::read_icf_line10_11_91(string& line, int K)
{
    phases[K].PAR[17] = stof(line.substr(0*8,8));
    phases[K].PAR[18] = stof(line.substr(1*8,8));
    phases[K].PAR[19] = stof(line.substr(2*8,8));
}

void DBWS::read_icf_line10_11_91_1(string& line, int K)
{
    phases[K].PAR[17].codeword = stof(line.substr(0*8,8));
    phases[K].PAR[18].codeword = stof(line.substr(1*8,8));
    phases[K].PAR[19].codeword = stof(line.substr(2*8,8));
}

void DBWS::read_icf_line10_11_93(string& line, int K)
{
    phases[K].PAR[24] = stof(line.substr(0*8,8));
    phases[K].PAR[25] = stof(line.substr(1*8,8));
    phases[K].PAR[26] = stof(line.substr(2*8,8));
}

void DBWS::read_icf_line10_11_93_1(string& line, int K)
{
    phases[K].PAR[24].codeword = stof(line.substr(0*8,8));
    phases[K].PAR[25].codeword = stof(line.substr(1*8,8));
    phases[K].PAR[26].codeword = stof(line.substr(2*8,8));
}

void DBWS::read_icf_line10_11_95(string& line, int K)
{
    phases[K].PAR[27] = stof(line.substr(0*8,8));
}

void DBWS::read_icf_line10_11_95_1(string& line, int K)
{
    phases[K].PAR[27].codeword = stof(line.substr(0*8,8));
}

void DBWS::write_file31()
{
    fstream file;
    int i;

    file.open("PLOTOSS.COR", ios::out);
    file << "\"" << title << "OSS.COR \"" << endl;
    file << setw(6) << NPTS
         << setw(15) << setprecision(5) << fixed << STEP
         << setw(15) << setprecision(5) << fixed << THMIN
         << setw(15) << setprecision(5) << fixed << THMAX
         << setw(5) << 1 << endl;
    for (i = 1; i <= NPTS; ++i)
    {
        file << setw(15) << setprecision(5) << fixed << Y_[i];
    }
    file.close();
}

void DBWS::write_file32()
{
    fstream file;
    int i;

    file.open ("PLOTCAL.TOT", ios::out);
    file << "\"" << title << "TOTALE \"" << endl;
    file << setw(6) << NPTS
         << setw(15) << setprecision(5) << fixed << STEP
         << setw(15) << setprecision(5) << fixed << THMIN
         << setw(15) << setprecision(5) << fixed << THMAX
         << setw(5) << 1 << endl;
    for (i = 1; i <= NPTS; ++i) {
        file << setw(15) << setprecision(5) << fixed << YC_[i];
    }
    file.close();
}

void DBWS::write_file33()
{
    fstream file;
    int i;

    file.open ("PLOTCOM.TOT", ios::out);
    file << "\"" << title << "COM.TOT\"" << endl;
    file << setw(6) << NPTS
         << setw(15) << setprecision(5) << fixed << STEP
         << setw(15) << setprecision(5) << fixed << THMIN
         << setw(15) << setprecision(5) << fixed << THMAX
         << setw(5) << 1 << endl;
    for (i = 1; i <= NPTS; ++i) {
        file << setw(15) << setprecision(5) << fixed << BKCOM_[i];
    }
    file.close();
}

void DBWS::write_file34()
{
    fstream file;
    int i;

    file.open ("PLOTDIS.TOT", ios::out);
    file << "\"" << title << "DIS.TOT\"" << endl;
    file << setw(6) << NPTS
         << setw(15) << setprecision(5) << fixed << STEP
         << setw(15) << setprecision(5) << fixed << THMIN
         << setw(15) << setprecision(5) << fixed << THMAX
         << setw(5) << 1 << endl;
    for (i = 1; i <= NPTS; ++i) {
        file << setw(15) << setprecision(5) << fixed << BKDIS_[i];
    }
    file.close();
}

void DBWS::write_file36()
{
    fstream file;
    int i;

    file.open ("PLOTAM.TOT", ios::out);
    file << "\"" << title << "AM.TOT \"" << endl;
    file << setw(6) << NPTS
         << setw(15) << setprecision(5) << fixed << STEP
         << setw(15) << setprecision(5) << fixed << THMIN
         << setw(15) << setprecision(5) << fixed << THMAX
         << setw(5) << 1 << endl;
    for (i = 1; i <= NPTS; ++i) {
        file << setw(15) << setprecision(5) << fixed << BKAM_[i];
    }
    file.close();
}

void DBWS::write_file37()
{
    fstream file;
    int i;

    file.open ("PLOTPOL.TOT", ios::out);
    file << "\"" << title << "POL.TOT\"" << endl;
    file << setw(6) << NPTS
         << setw(15) << setprecision(5) << fixed << STEP
         << setw(15) << setprecision(5) << fixed << THMIN
         << setw(15) << setprecision(5) << fixed << THMAX
         << setw(5) << 1 << endl;
    for (i = 1; i <= NPTS; ++i) {
        file << setw(15) << setprecision(5) << fixed << BKPOL_[i];
    }
    file.close();
}

void DBWS::write_file38()
{
    fstream file;
    int i;
    double ang;

    file.open ("PLOTBIG.DAT", ios::out);
    file << "\"" << title << "ALL.TOT\"" << endl;
    file << "    ANG,       OSS,       CAL,       +AM,      +POL,      +DIS,      +COM,       RES" << endl;
    for (i = 1; i <= NPTS; ++i) {
        ang = THMIN + (double) (i - 1) * STEP;
        file << setw(10) << setprecision(3) << fixed << ang << ","
             << setw(10) << setprecision(3) << fixed << Y_[i] << ","
             << setw(10) << setprecision(3) << fixed << YC_[i] << ","
             << setw(10) << setprecision(3) << fixed << BKAM_[i] << ","
             << setw(10) << setprecision(3) << fixed << BKAM_[i] + BKPOL_[i] << ","
             << setw(10) << setprecision(3) << fixed << BKAM_[i] + BKPOL_[i] + BKDIS_[i] << ","
             << setw(10) << setprecision(3) << fixed << BKAM_[i] + BKPOL_[i] +  BKDIS_[i] + BKCOM_[i] << ","
             << setw(10) << setprecision(3) << fixed << pow(Y_[i] - YC_[i],2)/ Y_[i] << "," << endl;
    }
    file.close();
}

double DBWS::calc_lambdam()
{
    return (RATIO[1]*LAMDA[1]+RATIO[2]*LAMDA[2])/(RATIO[1]+RATIO[2]);
}

int DBWS::search_wavelengths()
{
    int i;
    bool c;

    i=1;
    c = true;
    while (c) {
        if (1.03*LAMDA[1] > XRYZ[i])
        {
            c = false;
        }
        else
        {
            if (i <= 10)
            {
                i++;
            }
            else
            {
                c = false;
            }
        }
    }

    return i;
}


void DBWS::GOTOER()
{
    file6 << " subroutine GOTOER was called" << endl;
    exit (EXIT_FAILURE);
}


void DBWS::CV1(double AB[],double V[])
{
    int i, j, k, NN, MAXX;

    MAXX=min(9,cnv.N);
    for(k=1; k <= MAXX; k=k+2)
    {
        V[k]=0.0;
        for(i=1; i <= cnv.N ; i++)
        {
            V[k]=V[k]+cnv.F[i];
            for(j=1; j <= MAXX; j=j+2) V[k]=V[k]-AB[j]*exp(-AB[j+1]*cnv.SINLAM[i]);
        }
        V[k]=-2.0*V[k]*exp(-AB[k+1]*cnv.SINLAM[k]);
        V[k+1]=-V[k] * cnv.SINLAM[k]*AB[k];
    }
    NN=MAXX+1;
    for(i=NN; i <= 10 ; i++) V[i]=0.0;
}

void DBWS::CV2(double AB[],double* G)
{
    int i, j, MAXX;
    double T;

    MAXX=min(9,cnv.N);
    *G=0.0;
    for(i=1; i <= cnv.N; i++)
    {
        T=cnv.F[i];
        for(j=1; j <= MAXX; j=j+2) T=T-AB[j]*exp(-AB[j+1]*cnv.SINLAM[i]);
        *G=*G+T*T;
    }
}

void DBWS::STEEP(double X[],int N, int M)
{
    double D, G;
    int I, J, K;
    double T[16+1], U, V, W, Y[16+1][16+1], Z[16+1], G1, T1,
          T2, XI[16+1], ZN[16+1], ETA, SIG[16+1], ZNT[16+1], SIGT[16+1], ALPHA;

    if (N == 0) return;
    CV1(X,Z);
    CV2(X,&G);
    for(I=1; I <= M; I++)
    {
        for(J=1; J <= M; J++)
        {
            Y[I][J]=0.0;
            if (I == J)Y[I][J]=1.0;
        }
    }
    for(K=1; K <= N; K++)
    {
        U=0;
        for(I=1; I <= M; I++)
        {
            T1=0;
            for(J=1; J <= M; J++) T1=T1+Z[J]*Y[I][J];
            SIG[I]=T1;
            U=U-SIG[I]*Z[I];
        }

        ETA=min(1.0,abs(2.0*G/U));
        for(I=1; I <= M; I++) T[I]=X[I]-ETA*SIG[I];
        CV1(T,ZN);
        V=0;
        for(I=1; I <= M; I++) V=V-ZN[I]*SIG[I];
        CV2(T,&G1);
        D=3.*abs(G-G1)/ETA+U+V;
        W=sqrt(D*D-U*V);
        ALPHA=ETA*(1.0-(V+W-D)/(V-U+2.0*W));
        for(I=1; I <= M; I++)
        {
            SIG[I]=-1.0*ALPHA*SIG[I];
            X[I]=X[I]+SIG[I];
            ZN[I]=Z[I];
        }
        CV1(X,Z);
        CV2(X,&G);
        T1=0;
        for(I=1; I <= M; I++)
        {
            XI[I]=Z[I]-ZN[I];
            T1=T1+XI[I]*SIG[I];
        }
        for(I=1; I <= M; I++) SIGT[I]=SIG[I]/T1;
        T1=0;
        for(I=1; I <= M; I++)
        {
            T2=0;
            for(J=1; J <= M; J++) T2=T2+XI[J]*Y[I][J];
            ZN[I]=T2;
            T1=T1+ZN[I]*XI[I];
        }
        for(I=1; I <= M; I++)
        {
            T2=0;
            for(J=1; J <= M; J++) T2=T2+XI[J]*Y[J][I];
            ZNT[I]=T2/T1;
        }
        for(I=1; I <= M; I++)
        {
            for(J=1; J <= M; J++) Y[I][J]=Y[I][J]+SIG[I]*SIGT[J]-ZN[I]*ZNT[J];
        }
    }
}

void DBWS::COEF(int J,int K)
{
    int i, nn, nn1;
    double AB[10+1];

    for(i=1; i <= K; i++)
    {
        cnv.SINLAM[i]=coeff.POSI[i]*coeff.POSI[i];
        cnv.F[i]=coeff.SCAT[i];
    }
    cnv.N=K;
    nn=min(cnv.N,9);
    for(i=1; i <= nn; i++) AB[i]=i;
    nn1=nn+1;
    for(i=nn1; i<= 10; i++) AB[i]=0;
    STEEP(AB,3,10);
    if (AB[3] == 0.0) AB[3]=-1E-6;
    for(i=1; i <= 9; i++) AC_[i][J]=AB[i];
}

void DBWS::SPGP(string SPG)
{

    //
    //
    //                             THIS SR INTERPRETS THE SPACE GROUP SYMBOL
    //                           AND GENERATES OPERATORS WHICH SYMOPR USES TO
    //                           GENERATE THE FULL SET OF EQUIVALENT
    //                           POSITIONS AND OP1 AND SMTRY2 USE TO GENERATE
    //                           THE FULL SET OF EQUIVALENT INDICES.

    int ww;
    int I, J, K, M, N, M1, M2, M3,
        LD, IJ, KJ, MJ, IX, IN1, IN2, NI4, NI5, NI6, NK4, NK5, NK6, NM4,
        NM5, NM6, NCI, NCK, NCM, LOD, NIJ,
        NXC, NYC, NZC, NJX, ICO4, ICO5, ICO6, KCO4, KCO5, KCO6, MCO4,
        MCO5, IKO4, IKO5, IKO6, MCO6, LOD1;
    int L[4+1][4+1];
    int ICO[6+1][15+1];

    //  LODGDF(I,J) = iand( ieor(I,J),307)

    int NDAT[7+1] = {  0,     3, 1, 2, 0, 2, 1, 3 };
    string CHR = "  CBAPFIRMND123456-/H.";

    //CDB 2
    //C     PRINT 8,CHR
    //C   8 FORMAT (1X25A1)
    for(I=1; I <= 6; I++)
    {
        for(J=1; J <= 15; J++) ICO[I][J]=0;
    }
    for(I=1; I <= 4; I++)
    {
        for(J=1; J <= 4; J++) L[I][J] = 0;
    }
    M2 = 0;
    K = 1;
    M = 1;
    spgcom.NSPGRP = 0;
    spgcom.NAXIS = 0;
    N = 0;
    for(J=1; J <= 20; J++)
    {
        //L99:
        for (I=1; I <= 21; I++)
        {
            //I = ww;
            if ( SPG[J] == CHR[I] ) goto L101;
        }
        //DB 2
        //     PRINT 7,SPG(J),J
        //   7 FORMAT (1XA1* IS AN UNRECOGNIZABLE CHARACTER IN COL. *I2)
        goto L110;
L101:
        if ( K+M+I == 3 ) goto L110;
        if ( I == 1 ) goto L108;
        L[M][K] = I;
        N = 0;
        M = M+1;
        if ( M-4 <= 0 ) {
            goto L110;
        }
        else {
            goto L108;
        }
L108:
        if ( N == 1 ) goto L110;
        N = 1;
        M = 1;
        K = K+1;
        if ( K > 4 ) goto L200;
L110:
        ;
    }
L200:
    if ( K <= 2 ) goto L500;
    //DB 3
    //     PRINT 3,N,M,K,J,L
    //   3 FORMAT (*0N =*I3*  M =*I3*  K =*I3*  J =*I3/
    //    1  * L =*4I4/(4X4I4))
    if ( L[1][1] > 8 ) goto L500;
    J = 1;
    I = L[1][1]-1;
    switch (I) {
    case 1:
        spgcom.NCONT[J] = 68;
        J = J+1;
        if ( K-4 < 0 )
        {
            if ( L[1][2] == 18 )
            {
                if ( L[2][2] == 17 )
                {
                    spgcom.NSPGRP = 11;
                }
                else if ( L[2][2] == 14 )
                {
                    spgcom.NSPGRP = 8;
                }
                else if ( L[2][2] == 15 )
                {
                    spgcom.NSPGRP = 4;
                }
                else if ( L[2][2] == 12 )
                {
                    spgcom.NSPGRP = 1;
                }
                else
                {
                    goto L500;
                }
            }
            else if ( L[1][2] == 17 )
            {
                spgcom.NSPGRP = 11;
            }
            else if ( L[1][2] == 14 )
            {
                spgcom.NSPGRP = 8;
            }
            else if ( L[1][2] == 15 )
            {
                spgcom.NSPGRP = 4;
            }
            else if ( L[1][2] == 12 )
            {
                spgcom.NSPGRP = 1;
            }
            else
            {
                spgcom.NSPGRP = 2;
                spgcom.NAXIS = 2;
            }
        }
        else if ( K-4 == 0 )
        {
            if ( L[1][3] != 14 )
            {
                goto L500;
            }
            else
            {
                spgcom.NSPGRP = 13;
            }
        }
        else
        {
            if ( L[1][3] == 14 )
            {
                spgcom.NSPGRP = 14;
            }
            else if ( L[1][2] == 18 )
            {
                if ( L[2][2] == 17 )
                {
                    spgcom.NSPGRP = 12;
                }
                else if ( L[2][2] == 14 )
                {
                    if ( L[1][3] == 12 )
                    {
                        if ( L[1][4] == 12 )
                        {
                            spgcom.NSPGRP = 8;
                        }
                        else
                        {
                            spgcom.NSPGRP = 10;
                        }
                    }
                    else if ( L[1][4] != 12 )
                    {
                        goto L500;
                    }
                    else
                    {
                        spgcom.NSPGRP = 9;
                    }
                }
                else if ( L[2][2] == 15 )
                {
                    spgcom.NSPGRP = 5;
                }
                else
                {
                    goto L500;
                }
            }
            else if ( L[1][2] == 17 )
            {
                spgcom.NSPGRP = 12;
            }
            else if ( L[1][2] == 14 )
            {
                if ( L[1][3] == 12 )
                {
                    if ( L[1][4] == 12 )
                    {
                        spgcom.NSPGRP = 8;
                    }
                    else
                    {
                        spgcom.NSPGRP = 10;
                    }
                }
                else if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 9;
                }
            }
            else if ( L[1][2] == 15 )
            {
                spgcom.NSPGRP = 5;
            }
            else if ( L[1][2] == 12 )
            {
                if ( L[1][3] == 12 )
                {
                    if ( L[1][4] == 12 )
                    {
                        goto L500;
                    }
                    else
                    {
                        spgcom.NSPGRP = 2;
                        spgcom.NAXIS = 3;
                    }
                }
                else if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 2;
                    spgcom.NAXIS = 2;
                }
            }
            else if ( L[1][3] == 12 )
            {
                if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 2;
                    spgcom.NAXIS = 1;
                }
            }
            else if ( L[1][4] == 12 )
            {
                goto L500;
            }
            else
            {
                spgcom.NSPGRP = 3;
            }
        }
        break;
    case 2:
        spgcom.NCONT[J] = 516;
        J = J+1;
        if ( K-4 < 0 )
        {
            if ( L[1][2] == 18 )
            {
                if ( L[2][2] == 17 )
                {
                    spgcom.NSPGRP = 11;
                }
                else if ( L[2][2] == 14 )
                {
                    spgcom.NSPGRP = 8;
                }
                else if ( L[2][2] == 15 )
                {
                    spgcom.NSPGRP = 4;
                }
                else if ( L[2][2] == 12 )
                {
                    spgcom.NSPGRP = 1;
                }
                else
                {
                    goto L500;
                }
            }
            else if ( L[1][2] == 17 )
            {
                spgcom.NSPGRP = 11;
            }
            else if ( L[1][2] == 14 )
            {
                spgcom.NSPGRP = 8;
            }
            else if ( L[1][2] == 15 )
            {
                spgcom.NSPGRP = 4;
            }
            else if ( L[1][2] == 12 )
            {
                spgcom.NSPGRP = 1;
            }
            else
            {
                spgcom.NSPGRP = 2;
                spgcom.NAXIS = 2;
            }
        }
        else if ( K-4 == 0 )
        {
            if ( L[1][3] != 14 )
            {
                goto L500;
            }
            else
            {
                spgcom.NSPGRP = 13;
            }
        }
        else
        {
            if ( L[1][3] == 14 )
            {
                spgcom.NSPGRP = 14;
            }
            else if ( L[1][2] == 18 )
            {
                if ( L[2][2] == 17 )
                {
                    spgcom.NSPGRP = 12;
                }
                else if ( L[2][2] == 14 )
                {
                    if ( L[1][3] == 12 )
                    {
                        if ( L[1][4] == 12 )
                        {
                            spgcom.NSPGRP = 8;
                        }
                        else
                        {
                            spgcom.NSPGRP = 10;
                        }
                    }
                    else if ( L[1][4] != 12 )
                    {
                        goto L500;
                    }
                    else
                    {
                        spgcom.NSPGRP = 9;
                    }
                }
                else if ( L[2][2] == 15 )
                {
                    spgcom.NSPGRP = 5;
                }
                else
                {
                    goto L500;
                }
            }
            else if ( L[1][2] == 17 )
            {
                spgcom.NSPGRP = 12;
            }
            else if ( L[1][2] == 14 )
            {
                if ( L[1][3] == 12 )
                {
                    if ( L[1][4] == 12 )
                    {
                        spgcom.NSPGRP = 8;
                    }
                    else
                    {
                        spgcom.NSPGRP = 10;
                    }
                }
                else if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 9;
                }
            }
            else if ( L[1][2] == 15 )
            {
                spgcom.NSPGRP = 5;
            }
            else if ( L[1][2] == 12 )
            {
                if ( L[1][3] == 12 )
                {
                    if ( L[1][4] == 12 )
                    {
                        goto L500;
                    }
                    else
                    {
                        spgcom.NSPGRP = 2;
                        spgcom.NAXIS = 3;
                    }
                }
                else if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 2;
                    spgcom.NAXIS = 2;
                }
            }
            else if ( L[1][3] == 12 )
            {
                if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 2;
                    spgcom.NAXIS = 1;
                }
            }
            else if ( L[1][4] == 12 )
            {
                goto L500;
            }
            else
            {
                spgcom.NSPGRP = 3;
            }
        }
        break;
    case 3:
        spgcom.NCONT[J] = 576;
        J = J+1;
        if ( K-4 < 0 )
        {
            if ( L[1][2] == 18 )
            {
                if ( L[2][2] == 17 )
                {
                    spgcom.NSPGRP = 11;
                }
                else if ( L[2][2] == 14 )
                {
                    spgcom.NSPGRP = 8;
                }
                else if ( L[2][2] == 15 )
                {
                    spgcom.NSPGRP = 4;
                }
                else if ( L[2][2] == 12 )
                {
                    spgcom.NSPGRP = 1;
                }
                else
                {
                    goto L500;
                }
            }
            else if ( L[1][2] == 17 )
            {
                spgcom.NSPGRP = 11;
            }
            else if ( L[1][2] == 14 )
            {
                spgcom.NSPGRP = 8;
            }
            else if ( L[1][2] == 15 )
            {
                spgcom.NSPGRP = 4;
            }
            else if ( L[1][2] == 12 )
            {
                spgcom.NSPGRP = 1;
            }
            else
            {
                spgcom.NSPGRP = 2;
                spgcom.NAXIS = 2;
            }
        }
        else if ( K-4 == 0 )
        {
            if ( L[1][3] != 14 ) goto L500;
            spgcom.NSPGRP = 13;
        }
        else
        {
            if ( L[1][3] == 14 )
            {
                spgcom.NSPGRP = 14;
            }
            else if ( L[1][2] == 18 )
            {
                if ( L[2][2] == 17 )
                {
                    spgcom.NSPGRP = 12;
                }
                else if ( L[2][2] == 14 )
                {
                    if ( L[1][3] == 12 )
                    {
                        if ( L[1][4] == 12 )
                        {
                            spgcom.NSPGRP = 8;
                        }
                        else
                        {
                            spgcom.NSPGRP = 10;
                        }
                    }
                    else if ( L[1][4] != 12 )
                    {
                        goto L500;
                    }
                    else
                    {
                        spgcom.NSPGRP = 9;
                    }
                }
                else if ( L[2][2] == 15 )
                {
                    spgcom.NSPGRP = 5;
                }
                else
                {
                    goto L500;
                }
            }
            else if ( L[1][2] == 17 )
            {
                spgcom.NSPGRP = 12;
            }
            if ( L[1][2] == 14 )
            {
                if ( L[1][3] == 12 )
                {
                    if ( L[1][4] == 12 )
                    {
                        spgcom.NSPGRP = 8;
                    }
                    else
                    {
                        spgcom.NSPGRP = 10;
                    }
                }
                else if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 9;
                }
            }
            else if ( L[1][2] == 15 )
            {
                spgcom.NSPGRP = 5;
            }
            else if ( L[1][2] == 12 )
            {
                if ( L[1][3] == 12 )
                {
                    if ( L[1][4] == 12 )
                    {
                        goto L500;
                    }
                    else
                    {
                        spgcom.NSPGRP = 2;
                        spgcom.NAXIS = 3;
                    }
                }
                else if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 2;
                    spgcom.NAXIS = 2;
                }
            }
            if ( L[1][3] == 12 )
            {
                if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 2;
                    spgcom.NAXIS = 1;
                }
            }
            else if ( L[1][4] == 12 )
            {
                goto L500;
            }
            else
            {
                spgcom.NSPGRP = 3;
            }
        }
        break;
    case 4:
        if ( K-4 < 0 )
        {
            if ( L[1][2] == 18 )
            {
                if ( L[2][2] == 17 )
                {
                    spgcom.NSPGRP = 11;
                }
                else if ( L[2][2] == 14 )
                {
                    spgcom.NSPGRP = 8;
                }
                else if ( L[2][2] == 15 )
                {
                    spgcom.NSPGRP = 4;
                }
                else if ( L[2][2] == 12 )
                {
                    spgcom.NSPGRP = 1;
                }
                else
                {
                    goto L500;
                }
            }
            else if ( L[1][2] == 17 )
            {
                spgcom.NSPGRP = 11;
            }
            else if ( L[1][2] == 14 )
            {
                spgcom.NSPGRP = 8;
            }
            else if ( L[1][2] == 15 )
            {
                spgcom.NSPGRP = 4;
            }
            else if ( L[1][2] == 12 )
            {
                spgcom.NSPGRP = 1;
            }
            else
            {
                spgcom.NSPGRP = 2;
                spgcom.NAXIS = 2;
            }
        }
        else if ( K-4 == 0 )
        {
            if ( L[1][3] != 14 ) goto L500;
            spgcom.NSPGRP = 13;
        }
        else
        {
            if ( L[1][3] == 14 )
            {
                spgcom.NSPGRP = 14;
            }
            else if ( L[1][2] == 18 )
            {
                if ( L[2][2] == 17 )
                {
                    spgcom.NSPGRP = 12;
                }
                else if ( L[2][2] == 14 )
                {
                    if ( L[1][3] == 12 )
                    {
                        if ( L[1][4] == 12 )
                        {
                            spgcom.NSPGRP = 8;
                        }
                        else
                        {
                            spgcom.NSPGRP = 10;
                        }
                    }
                    else if ( L[1][4] != 12 )
                    {
                        goto L500;
                    }
                    else
                    {
                        spgcom.NSPGRP = 9;
                    }
                }
                else if ( L[2][2] == 15 )
                {
                    spgcom.NSPGRP = 5;
                }
                else
                {
                    goto L500;
                }
            }
            else if ( L[1][2] == 17 )
            {
                spgcom.NSPGRP = 12;
            }
            else if ( L[1][2] == 14 )
            {
                if ( L[1][3] == 12 )
                {
                    if ( L[1][4] == 12 )
                    {
                        spgcom.NSPGRP = 8;
                    }
                    else
                    {
                        spgcom.NSPGRP = 10;
                    }
                }
                else if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 9;
                }
            }
            else if ( L[1][2] == 15 )
            {
                spgcom.NSPGRP = 5;
            }
            else if ( L[1][2] == 12 )
            {
                if ( L[1][3] == 12 )
                {
                    if ( L[1][4] == 12 )
                    {
                        goto L500;
                    }
                    else
                    {
                        spgcom.NSPGRP = 2;
                        spgcom.NAXIS = 3;
                    }
                }
                else if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 2;
                    spgcom.NAXIS = 2;
                }
            }
            else if ( L[1][3] == 12 )
            {
                if ( L[1][4] != 12 ) goto L500;
                spgcom.NSPGRP = 2;
                spgcom.NAXIS = 1;
            }
            else if ( L[1][4] == 12 )
            {
                goto L500;
            }
            else
            {
                spgcom.NSPGRP = 3;
            }
        }
        break;
    case 5:
        spgcom.NCONT[J] = 576;
        J = J+1;
        spgcom.NCONT[J] = 516;
        J = J+1;
        if ( K-4 < 0 )
        {
            if ( L[1][2] == 18 )
            {
                if ( L[2][2] == 17 )
                {
                    spgcom.NSPGRP = 11;
                }
                else if ( L[2][2] == 14 )
                {
                    spgcom.NSPGRP = 8;
                }
                else if ( L[2][2] == 15 )
                {
                    spgcom.NSPGRP = 4;
                }
                else if ( L[2][2] == 12 )
                {
                    spgcom.NSPGRP = 1;
                }
                else
                {
                    goto L500;
                }
            }
            else if ( L[1][2] == 17 )
            {
                spgcom.NSPGRP = 11;
            }
            else if ( L[1][2] == 14 )
            {
                spgcom.NSPGRP = 8;
            }
            else if ( L[1][2] == 15 )
            {
                spgcom.NSPGRP = 4;
            }
            else if ( L[1][2] == 12 )
            {
                spgcom.NSPGRP = 1;
            }
            else
            {
                spgcom.NSPGRP = 2;
                spgcom.NAXIS = 2;
            }
        }
        else if ( K-4 == 0 )
        {
            if ( L[1][3] != 14 ) goto L500;
            spgcom.NSPGRP = 13;
        }
        else
        {
            if ( L[1][3] == 14 )
            {
                spgcom.NSPGRP = 14;
            }
            else if ( L[1][2] == 18 )
            {
                if ( L[2][2] == 17 )
                {
                    spgcom.NSPGRP = 12;
                }
                else if ( L[2][2] == 14 )
                {
                    if ( L[1][3] == 12 )
                    {
                        if ( L[1][4] == 12 )
                        {
                            spgcom.NSPGRP = 8;
                        }
                        else
                        {
                            spgcom.NSPGRP = 10;
                        }
                    }
                    else if ( L[1][4] != 12 )
                    {
                        goto L500;
                    }
                    else
                    {
                        spgcom.NSPGRP = 9;
                    }
                }
                else if ( L[2][2] == 15 )
                {
                    spgcom.NSPGRP = 5;
                }
                else
                {
                    goto L500;
                }
            }
            else if ( L[1][2] == 17 )
            {
                spgcom.NSPGRP = 12;
            }
            else if ( L[1][2] == 14 )
            {
                if ( L[1][3] == 12 )
                {
                    if ( L[1][4] == 12 )
                    {
                        spgcom.NSPGRP = 8;
                    }
                    else
                    {
                        spgcom.NSPGRP = 10;
                    }
                }
                else if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 9;
                }
            }
            else if ( L[1][2] == 15 )
            {
                spgcom.NSPGRP = 5;
            }
            else if ( L[1][2] == 12 )
            {
                if ( L[1][3] == 12 )
                {
                    if ( L[1][4] == 12 ) goto L500;
                    spgcom.NSPGRP = 2;
                    spgcom.NAXIS = 3;
                }
                else if ( L[1][4] != 12 )
                {
                    goto L500;
                }
                else
                {
                    spgcom.NSPGRP = 2;
                    spgcom.NAXIS = 2;
                }
            }
            else if ( L[1][3] == 12 )
            {
                if ( L[1][4] != 12 ) goto L500;
                spgcom.NSPGRP = 2;
                spgcom.NAXIS = 1;
            }
            else if ( L[1][4] == 12 )
            {
                goto L500;
            }
            else
            {
                spgcom.NSPGRP = 3;
            }
        }
        break;
    case 6:
        spgcom.NCONT[J] = 580;
        J = J+1;
        if ( K-4 < 0 )
        {
            if ( L[1][2] == 18 )
            {
                if ( L[2][2] == 17 )
                {
                    spgcom.NSPGRP = 11;
                }
                else if ( L[2][2] == 14 )
                {
                    spgcom.NSPGRP = 8;
                }
                else if ( L[2][2] == 15 )
                {
                    spgcom.NSPGRP = 4;
                }
                else if ( L[2][2] == 12 )
                {
                    spgcom.NSPGRP = 1;
                }
                else
                {
                    goto L500;
                }
            }
            else if ( L[1][2] == 17 )
            {
                spgcom.NSPGRP = 11;
            }
            else if ( L[1][2] == 14 )
            {
                spgcom.NSPGRP = 8;
            }
            else if ( L[1][2] == 15 )
            {
                spgcom.NSPGRP = 4;
            }
            else if ( L[1][2] == 12 )
            {
                spgcom.NSPGRP = 1;
            }
            else
            {
                spgcom.NSPGRP = 2;
                spgcom.NAXIS = 2;
            }
        }
        else if ( K-4 == 0 )
        {
            if ( L[1][3] != 14 ) goto L500;
            spgcom.NSPGRP = 13;
        }
        else
        {
            if ( L[1][3] == 14 )
            {
                spgcom.NSPGRP = 14;
            }
            else if ( L[1][2] == 18 )
            {
                if ( L[2][2] == 17 )
                {
                    spgcom.NSPGRP = 12;
                }
                else if ( L[2][2] == 14 )
                {
                    if ( L[1][3] == 12 )
                    {
                        if ( L[1][4] == 12 )
                        {
                            spgcom.NSPGRP = 8;
                        }
                        else
                        {
                            spgcom.NSPGRP = 10;
                        }
                    }
                    else
                    {
                        if ( L[1][4] != 12 ) goto L500;
                        spgcom.NSPGRP = 9;
                    }
                }
                else if ( L[2][2] == 15 )
                {
                    spgcom.NSPGRP = 5;
                }
                else
                {
                    goto L500;
                }
            }
            else if ( L[1][2] == 17 )
            {
                spgcom.NSPGRP = 12;
            }
            else if ( L[1][2] == 14 )
            {
                if ( L[1][3] == 12 )
                {
                    if ( L[1][4] == 12 )
                    {
                        spgcom.NSPGRP = 8;
                    }
                    else
                    {
                        spgcom.NSPGRP = 10;
                    }
                }
                else
                {
                    if ( L[1][4] != 12 ) goto L500;
                    spgcom.NSPGRP = 9;
                }
            }
            else if ( L[1][2] == 15 )
            {
                spgcom.NSPGRP = 5;
            }
            else if ( L[1][2] == 12 )
            {
                if ( L[1][3] == 12 )
                {
                    if ( L[1][4] == 12 ) goto L500;
                    spgcom.NSPGRP = 2;
                    spgcom.NAXIS = 3;
                }
                else
                {
                    if ( L[1][4] != 12 ) goto L500;
                    spgcom.NSPGRP = 2;
                    spgcom.NAXIS = 2;
                }
            }
            else if ( L[1][3] == 12 )
            {
                if ( L[1][4] != 12 ) goto L500;
                spgcom.NSPGRP = 2;
                spgcom.NAXIS = 1;
            }
            else if ( L[1][4] == 12 )
            {
                goto L500;
            }
            else
            {
                spgcom.NSPGRP = 3;
            }
        }
        break;
    case 7:
        if ( L[1][3] == 8 || L[1][4] == 8 )
        {
            K = K-1;
            spgcom.NSPGRP = K+3;
        }
        else
        {
            spgcom.NCONT[J] = 8192;
            if ( L[1][K-1] == 20 ) K=K-1;
            spgcom.NSPGRP = K+5;
            J = J+1;
        }
        break;
    default:
        GOTOER();
        break;
    }

//L210:
    K = K-1;
    //DB 2
    //     PRINT 4,K,NSPGRP,NAXIS,J,NCONT
    //   4 FORMAT ('0K =',I3,'  NSPGRP =',2I4,'  J=',I3/' NCONT =',10I4)
    N = 1;
    for(M=2; M <= K; M++)
    {
        if ( L[1][M] == 0 ) goto L500;
L218:
        I = abs(L[1][M]-5);
L219:
        if ( I <= 0 || I > 15 ) goto L500;
        switch (I) {
        case 1:
            // A
            //        H
            switch (M) {
            case 1:
                goto L500;
                break;
            case 2:
                if ( L[1][3] == 14 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( L[1][2] == 17 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( K == 2 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 2;
                    ICO[3][N] = 0;
                    ICO[5][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    N = N+1;
                    goto L300;
                }
                ICO[1][N] = 2;
                ICO[2][N] = 0;
                ICO[3][N] = 0;
                ICO[4][N] = 4;
                if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                N = N+1;
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = ICO[2][N-1];
                    ICO[2][N] = ICO[1][N-1];
                    ICO[3][N] = ICO[3][N-1];
                    ICO[4][N] = ICO[5][N-1];
                    ICO[5][N] = ICO[4][N-1];
                    ICO[6][N] = ICO[6][N-1];
                    N= N+1;
                }
                goto L300;
                break;
            case 3:
                if ( L[1][2] == 14 || L[1][2] == 17 )
                {
                    if ( spgcom.NSPGRP == 7 )
                    {
                        ICO[1][N] = 1;
                        ICO[2][N] = 1;
                        ICO[3][N] = 0;
                        ICO[4][N] = 4;
                        ICO[5][N] = 4;
                        if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                        if ( spgcom.NSPGRP == 7 && I == 3 )
                        {
                            ICO[4][N] = 5;
                            ICO[5][N] = 5;
                            N = N+1;
                        }
                        else
                        {
                            if ( I != 5 )
                            {
                                N = N+1;
                                goto L300;
                            }
                            ICO[4][N] = 5;
                            ICO[5][N] = 5;
                            N = N+1;
                        }
                        goto L300;
                    }
                    ICO[1][N] = 3;
                    ICO[2][N] = 3;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 ) ICO[6][N] = 1;
                    N = N+1;
                    goto L300;
                }
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = 2;
                    ICO[2][N] = 0;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    N = N+1;
                    if ( L[1][2] == 15 )
                    {
                        ICO[1][N] = ICO[2][N-1];
                        ICO[2][N] = ICO[1][N-1];
                        ICO[3][N] = ICO[3][N-1];
                        ICO[4][N] = ICO[5][N-1];
                        ICO[5][N] = ICO[4][N-1];
                        ICO[6][N] = ICO[6][N-1];
                        N= N+1;
                    }
                    goto L300;
                }
                ICO[1][N] = 0;
                ICO[2][N] = 2;
                ICO[3][N] = 0;
                ICO[5][N] = 4;
                if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                N = N+1;
                goto L300;
                break;
            case 4:
                if ( L[1][3] == 14 || L[1][2] == 15 )
                {
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    if ( spgcom.NSPGRP == 7 && I == 3 )
                    {
                        ICO[4][N] = 5;
                        ICO[5][N] = 5;
                        N = N+1;
                        goto L300;
                    }
                    if ( I != 5 )
                    {
                        N = N+1;
                        goto L300;
                    }
                    ICO[4][N] = 5;
                    ICO[5][N] = 5;
                    N = N+1;
                    goto L300;
                }
                if ( L[1][2] == 14 || L[1][2] == 17 )
                {
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    if ( spgcom.NSPGRP == 7 && I == 3 )
                    {
                        ICO[4][N] = 5;
                        ICO[5][N] = 5;
                        N = N+1;
                        goto L300;
                    }
                    if ( I != 5 )
                    {
                        N = N+1;
                        goto L300;
                    }
                    ICO[4][N] = 5;
                    ICO[5][N] = 5;
                    N = N+1;
                    goto L300;
                }
                ICO[1][N] = 0;
                ICO[2][N] = 0;
                ICO[3][N] = 2;
                ICO[6][N] = 4;
                if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                N = N+1;
                if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                if ( M !=  2 || L[1][2] != 17) goto L300;
                if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                goto L300;
                break;
            default:
                GOTOER();
                break;
            }
            break;
        case 2:
            // B
            //        H
            switch (M) {
            case 1:
                goto L500;
                break;
            case 2:
                if ( L[1][3] == 14 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( L[1][2] == 17 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( K == 2 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 2;
                    ICO[3][N] = 0;
                    ICO[5][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    N = N+1;
                    goto L300;
                }
                ICO[1][N] = 2;
                ICO[2][N] = 0;
                ICO[3][N] = 0;
                ICO[4][N] = 4;
                if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                N = N+1;
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = ICO[2][N-1];
                    ICO[2][N] = ICO[1][N-1];
                    ICO[3][N] = ICO[3][N-1];
                    ICO[4][N] = ICO[5][N-1];
                    ICO[5][N] = ICO[4][N-1];
                    ICO[6][N] = ICO[6][N-1];
                    N= N+1;
                }
                goto L300;
                break;
            case 3:
                if ( L[1][2] == 14 || L[1][2] == 17 )
                {
                    if ( spgcom.NSPGRP == 7 )
                    {
                        ICO[1][N] = 1;
                        ICO[2][N] = 1;
                        ICO[3][N] = 0;
                        ICO[4][N] = 4;
                        ICO[5][N] = 4;
                        if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                        if ( spgcom.NSPGRP == 7 && I == 3 )
                        {
                            ICO[4][N] = 5;
                            ICO[5][N] = 5;
                            N = N+1;
                        }
                        else
                        {
                            if ( I != 5 )
                            {
                                N = N+1;
                                goto L300;
                            }
                            ICO[4][N] = 5;
                            ICO[5][N] = 5;
                            N = N+1;
                        }
                        goto L300;
                    }
                    ICO[1][N] = 3;
                    ICO[2][N] = 3;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 ) ICO[6][N] = 1;
                    N = N+1;
                    goto L300;
                }
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = 2;
                    ICO[2][N] = 0;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    N = N+1;
                    if ( L[1][2] == 15 )
                    {
                        ICO[1][N] = ICO[2][N-1];
                        ICO[2][N] = ICO[1][N-1];
                        ICO[3][N] = ICO[3][N-1];
                        ICO[4][N] = ICO[5][N-1];
                        ICO[5][N] = ICO[4][N-1];
                        ICO[6][N] = ICO[6][N-1];
                        N= N+1;
                    }
                    goto L300;
                }
                ICO[1][N] = 0;
                ICO[2][N] = 2;
                ICO[3][N] = 0;
                ICO[5][N] = 4;
                if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                N = N+1;
                goto L300;
                break;
            case 4:
                if ( L[1][3] == 14 || L[1][2] == 15 )
                {
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    if ( spgcom.NSPGRP == 7 && I == 3 )
                    {
                        ICO[4][N] = 5;
                        ICO[5][N] = 5;
                        N = N+1;
                        goto L300;
                    }
                    if ( I != 5 )
                    {
                        N = N+1;
                        goto L300;
                    }
                    ICO[4][N] = 5;
                    ICO[5][N] = 5;
                    N = N+1;
                    goto L300;
                }
                if ( L[1][2] == 14 || L[1][2] == 17 )
                {
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    if ( spgcom.NSPGRP == 7 && I == 3 )
                    {
                        ICO[4][N] = 5;
                        ICO[5][N] = 5;
                        N = N+1;
                        goto L300;
                    }
                    if ( I != 5 )
                    {
                        N = N+1;
                        goto L300;
                    }
                    ICO[4][N] = 5;
                    ICO[5][N] = 5;
                    N = N+1;
                    goto L300;
                }
                ICO[1][N] = 0;
                ICO[2][N] = 0;
                ICO[3][N] = 2;
                ICO[6][N] = 4;
                if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                N = N+1;
                if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                if ( M !=  2 || L[1][2] != 17) goto L300;
                if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                goto L300;
                break;
            default:
                GOTOER();
                break;
            }
            break;
        case 3:
            // C
            //        H
            switch (M) {
            case 1:
                goto L500;
                break;
            case 2:
                if ( L[1][3] == 14 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( L[1][2] == 17 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( K == 2 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 2;
                    ICO[3][N] = 0;
                    ICO[5][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    N = N+1;
                    goto L300;
                }
                ICO[1][N] = 2;
                ICO[2][N] = 0;
                ICO[3][N] = 0;
                ICO[4][N] = 4;
                if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                N = N+1;
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = ICO[2][N-1];
                    ICO[2][N] = ICO[1][N-1];
                    ICO[3][N] = ICO[3][N-1];
                    ICO[4][N] = ICO[5][N-1];
                    ICO[5][N] = ICO[4][N-1];
                    ICO[6][N] = ICO[6][N-1];
                    N= N+1;
                }
                goto L300;
                break;
            case 3:
                if ( L[1][2] == 14 || L[1][2] == 17 )
                {
                    if ( spgcom.NSPGRP == 7 )
                    {
                        ICO[1][N] = 1;
                        ICO[2][N] = 1;
                        ICO[3][N] = 0;
                        ICO[4][N] = 4;
                        ICO[5][N] = 4;
                        if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                        if ( spgcom.NSPGRP == 7 && I == 3 )
                        {
                            ICO[4][N] = 5;
                            ICO[5][N] = 5;
                            N = N+1;
                        }
                        else
                        {
                            if ( I != 5 )
                            {
                                N = N+1;
                                goto L300;
                            }
                            ICO[4][N] = 5;
                            ICO[5][N] = 5;
                            N = N+1;
                        }
                        goto L300;
                    }
                    ICO[1][N] = 3;
                    ICO[2][N] = 3;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 ) ICO[6][N] = 1;
                    N = N+1;
                    goto L300;
                }
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = 2;
                    ICO[2][N] = 0;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    N = N+1;
                    if ( L[1][2] == 15 )
                    {
                        ICO[1][N] = ICO[2][N-1];
                        ICO[2][N] = ICO[1][N-1];
                        ICO[3][N] = ICO[3][N-1];
                        ICO[4][N] = ICO[5][N-1];
                        ICO[5][N] = ICO[4][N-1];
                        ICO[6][N] = ICO[6][N-1];
                        N= N+1;
                    }
                    goto L300;
                }
                ICO[1][N] = 0;
                ICO[2][N] = 2;
                ICO[3][N] = 0;
                ICO[5][N] = 4;
                if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                N = N+1;
                goto L300;
                break;
            case 4:
                if ( L[1][3] == 14 || L[1][2] == 15 )
                {
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    if ( spgcom.NSPGRP == 7 && I == 3 )
                    {
                        ICO[4][N] = 5;
                        ICO[5][N] = 5;
                        N = N+1;
                        goto L300;
                    }
                    if ( I != 5 )
                    {
                        N = N+1;
                        goto L300;
                    }
                    ICO[4][N] = 5;
                    ICO[5][N] = 5;
                    N = N+1;
                    goto L300;
                }
                if ( L[1][2] == 14 || L[1][2] == 17 )
                {
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    if ( spgcom.NSPGRP == 7 && I == 3 )
                    {
                        ICO[4][N] = 5;
                        ICO[5][N] = 5;
                        N = N+1;
                        goto L300;
                    }
                    if ( I != 5 )
                    {
                        N = N+1;
                        goto L300;
                    }
                    ICO[4][N] = 5;
                    ICO[5][N] = 5;
                    N = N+1;
                    goto L300;
                }
                ICO[1][N] = 0;
                ICO[2][N] = 0;
                ICO[3][N] = 2;
                ICO[6][N] = 4;
                if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                N = N+1;
                if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                if ( M !=  2 || L[1][2] != 17) goto L300;
                if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                goto L300;
                break;
            default:
                GOTOER();
                break;
            }
            break;
        case 4:
            // M
            //        H
            switch (M) {
            case 1:
                goto L500;
                break;
            case 2:
                if ( L[1][3] == 14 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( L[1][2] == 17 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( K == 2 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 2;
                    ICO[3][N] = 0;
                    ICO[5][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    N = N+1;
                    goto L300;
                }
                ICO[1][N] = 2;
                ICO[2][N] = 0;
                ICO[3][N] = 0;
                ICO[4][N] = 4;
                if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                N = N+1;
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = ICO[2][N-1];
                    ICO[2][N] = ICO[1][N-1];
                    ICO[3][N] = ICO[3][N-1];
                    ICO[4][N] = ICO[5][N-1];
                    ICO[5][N] = ICO[4][N-1];
                    ICO[6][N] = ICO[6][N-1];
                    N= N+1;
                }
                goto L300;
                break;
            case 3:
                if ( L[1][2] == 14 || L[1][2] == 17 )
                {
                    if ( spgcom.NSPGRP == 7 )
                    {
                        ICO[1][N] = 1;
                        ICO[2][N] = 1;
                        ICO[3][N] = 0;
                        ICO[4][N] = 4;
                        ICO[5][N] = 4;
                        if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                        if ( spgcom.NSPGRP == 7 && I == 3 )
                        {
                            ICO[4][N] = 5;
                            ICO[5][N] = 5;
                            N = N+1;
                        }
                        else
                        {
                            if ( I != 5 )
                            {
                                N = N+1;
                                goto L300;
                            }
                            ICO[4][N] = 5;
                            ICO[5][N] = 5;
                            N = N+1;
                        }
                        goto L300;
                    }
                    ICO[1][N] = 3;
                    ICO[2][N] = 3;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 ) ICO[6][N] = 1;
                    N = N+1;
                    goto L300;
                }
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = 2;
                    ICO[2][N] = 0;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    N = N+1;
                    if ( L[1][2] == 15 )
                    {
                        ICO[1][N] = ICO[2][N-1];
                        ICO[2][N] = ICO[1][N-1];
                        ICO[3][N] = ICO[3][N-1];
                        ICO[4][N] = ICO[5][N-1];
                        ICO[5][N] = ICO[4][N-1];
                        ICO[6][N] = ICO[6][N-1];
                        N= N+1;
                    }
                    goto L300;
                }
                ICO[1][N] = 0;
                ICO[2][N] = 2;
                ICO[3][N] = 0;
                ICO[5][N] = 4;
                if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                N = N+1;
                goto L300;
                break;
            case 4:
                if ( L[1][3] == 14 || L[1][2] == 15 )
                {
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    if ( spgcom.NSPGRP == 7 && I == 3 )
                    {
                        ICO[4][N] = 5;
                        ICO[5][N] = 5;
                        N = N+1;
                        goto L300;
                    }
                    if ( I != 5 )
                    {
                        N = N+1;
                        goto L300;
                    }
                    ICO[4][N] = 5;
                    ICO[5][N] = 5;
                    N = N+1;
                    goto L300;
                }
                if ( L[1][2] == 14 || L[1][2] == 17 )
                {
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    if ( spgcom.NSPGRP == 7 && I == 3 )
                    {
                        ICO[4][N] = 5;
                        ICO[5][N] = 5;
                        N = N+1;
                        goto L300;
                    }
                    if ( I != 5 )
                    {
                        N = N+1;
                        goto L300;
                    }
                    ICO[4][N] = 5;
                    ICO[5][N] = 5;
                    N = N+1;
                    goto L300;
                }
                ICO[1][N] = 0;
                ICO[2][N] = 0;
                ICO[3][N] = 2;
                ICO[6][N] = 4;
                if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                N = N+1;
                if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                if ( M !=  2 || L[1][2] != 17) goto L300;
                if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                goto L300;
                break;
            default:
                GOTOER();
                break;
            }
            break;
        case 5:
            // N
            //        H
            switch (M) {
            case 1:
                goto L500;
                break;
            case 2:
                if ( L[1][3] == 14 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( L[1][2] == 17 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[6][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    N = N+1;
                    if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                    if ( M !=  2 || L[1][2] != 17) goto L300;
                    if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                    if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                    goto L300;
                }
                if ( K == 2 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 2;
                    ICO[3][N] = 0;
                    ICO[5][N] = 4;
                    if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    N = N+1;
                    goto L300;
                }
                ICO[1][N] = 2;
                ICO[2][N] = 0;
                ICO[3][N] = 0;
                ICO[4][N] = 4;
                if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                N = N+1;
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = ICO[2][N-1];
                    ICO[2][N] = ICO[1][N-1];
                    ICO[3][N] = ICO[3][N-1];
                    ICO[4][N] = ICO[5][N-1];
                    ICO[5][N] = ICO[4][N-1];
                    ICO[6][N] = ICO[6][N-1];
                    N= N+1;
                }
                goto L300;
                break;
            case 3:
                if ( L[1][2] == 14 || L[1][2] == 17 )
                {
                    if ( spgcom.NSPGRP == 7 )
                    {
                        ICO[1][N] = 1;
                        ICO[2][N] = 1;
                        ICO[3][N] = 0;
                        ICO[4][N] = 4;
                        ICO[5][N] = 4;
                        if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                        if ( spgcom.NSPGRP == 7 && I == 3 )
                        {
                            ICO[4][N] = 5;
                            ICO[5][N] = 5;
                            N = N+1;
                        }
                        else
                        {
                            if ( I != 5 )
                            {
                                N = N+1;
                                goto L300;
                            }
                            ICO[4][N] = 5;
                            ICO[5][N] = 5;
                            N = N+1;
                        }
                        goto L300;
                    }
                    ICO[1][N] = 3;
                    ICO[2][N] = 3;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 ) ICO[6][N] = 1;
                    N = N+1;
                    goto L300;
                }
                if ( L[1][2] == 15 )
                {
                    ICO[1][N] = 2;
                    ICO[2][N] = 0;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    N = N+1;
                    if ( L[1][2] == 15 )
                    {
                        ICO[1][N] = ICO[2][N-1];
                        ICO[2][N] = ICO[1][N-1];
                        ICO[3][N] = ICO[3][N-1];
                        ICO[4][N] = ICO[5][N-1];
                        ICO[5][N] = ICO[4][N-1];
                        ICO[6][N] = ICO[6][N-1];
                        N= N+1;
                    }
                    goto L300;
                }
                ICO[1][N] = 0;
                ICO[2][N] = 2;
                ICO[3][N] = 0;
                ICO[5][N] = 4;
                if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                N = N+1;
                goto L300;
                break;
            case 4:
                if ( L[1][3] == 14 || L[1][2] == 15 )
                {
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    if ( spgcom.NSPGRP == 7 && I == 3 )
                    {
                        ICO[4][N] = 5;
                        ICO[5][N] = 5;
                        N = N+1;
                        goto L300;
                    }
                    if ( I != 5 )
                    {
                        N = N+1;
                        goto L300;
                    }
                    ICO[4][N] = 5;
                    ICO[5][N] = 5;
                    N = N+1;
                    goto L300;
                }
                if ( L[1][2] == 14 || L[1][2] == 17 )
                {
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 0;
                    ICO[4][N] = 4;
                    ICO[5][N] = 4;
                    if ( I == 3 || I == 5 ) ICO[6][N] = 1;
                    if ( spgcom.NSPGRP == 7 && I == 3 )
                    {
                        ICO[4][N] = 5;
                        ICO[5][N] = 5;
                        N = N+1;
                        goto L300;
                    }
                    if ( I != 5 )
                    {
                        N = N+1;
                        goto L300;
                    }
                    ICO[4][N] = 5;
                    ICO[5][N] = 5;
                    N = N+1;
                    goto L300;
                }
                ICO[1][N] = 0;
                ICO[2][N] = 0;
                ICO[3][N] = 2;
                ICO[6][N] = 4;
                if ( I == 1 || I == 5 ) ICO[4][N] = 1;
                if ( I == 2 || I == 5 ) ICO[5][N] = 1;
                N = N+1;
                if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
                if ( M !=  2 || L[1][2] != 17) goto L300;
                if ( L[1][3] == 2 ) ICO[6][N-1]=1;
                if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
                goto L300;
                break;
            default:
                GOTOER();
                break;
            }
            break;
        case 6:
            // D
            //    D TYPE MIRROR
            switch (M) {
            case 1:
                goto L500;
                break;
            case 2:
                if ( K == 2 )
                {
                    ICO[1][N] = 0;
                    ICO[2][N] = 2;
                    ICO[3][N] = 0;
                    ICO[4][N] = 6;
                    ICO[5][N] = 6;
                    ICO[6][N] = 6;
                    N = N+1;
                    goto L300;
                }
                ICO[1][N] = 2;
                ICO[2][N] = 0;
                ICO[3][N] = 0;
                ICO[4][N] = 6;
                ICO[5][N] = 6;
                ICO[6][N] = 6;
                N = N+1;
                goto L300;
                break;
            case 3:
                ICO[1][N] = 0;
                ICO[2][N] = 2;
                ICO[3][N] = 0;
                ICO[4][N] = 6;
                ICO[5][N] = 6;
                ICO[6][N] = 6;
                N = N+1;
                goto L300;
                break;
            case 4:
                if ( L[1][2] == 15 || L[1][3] == 14 )
                {
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 0;
                    ICO[4][N] = 6;
                    ICO[5][N] = 6;
                    ICO[6][N] = 6;
                    if (L[1][3] != 13)
                    {
                        N = N+1;
                        goto L300;
                    }
                    ICO[4][N] = 0;
                    ICO[5][N] = 1;
                    N = N+1;
                    goto L300;
                }
                ICO[1][N] = 0;
                ICO[2][N] = 0;
                ICO[3][N] = 2;
                ICO[4][N] = 6;
                ICO[5][N] = 6;
                ICO[6][N] = 6;
                N = N+1;
                goto L300;
                break;
            default:
                GOTOER();
                break;
            }
            break;
        case 7:
            // 1
            //    1 FOLD ROTATION
            if ( L[2][M] != 3 ) goto L300;
            ICO[1][N] = 2;
            ICO[2][N] = 2;
            ICO[3][N] = 2;
            ICO[4][N] = 4;
            ICO[5][N] = 4;
            ICO[6][N] = 4;
            N = N+1;
            goto L300;
            break;
        case 8:
            // 2
            switch (M) {
            case 1:
                goto L500;
                break;
            case 2:
                //    2 FOLD ROTATION
                if ( K == 2 )
                {
                    ICO[1][N] = 2;
                    ICO[2][N] = 0;
                    ICO[3][N] = 2;
                    ICO[4][N] = 4;
                    ICO[5][N] = 0;
                    ICO[6][N] = 4;
                    if ( L[2][M] == 12 ) ICO[5][N]=1;
                    if ( L[1][2] == 15 )
                    {
                        N = N+1;
                        if ( L[1][2] == 15 )
                        {
                            ICO[1][N] = ICO[2][N-1];
                            ICO[2][N] = ICO[1][N-1];
                            ICO[3][N] = ICO[3][N-1];
                            ICO[4][N] = ICO[5][N-1];
                            ICO[5][N] = ICO[4][N-1];
                            ICO[6][N] = ICO[6][N-1];
                            N= N+1;
                        }
                        goto L300;
                    }
                    N = N+1;
                    for (I=2; I <= 4; I++)
                    {
                        if ( L[I][M] == 19 )
                        {
                            if ( L[I+1][M] <= 1 ) goto L500;
                            I = abs(L[I+1][M]-5);
                            goto L219;
                        }
                    }
                    goto L300;
                }
                ICO[1][N] = 0;
                ICO[2][N] = 2;
                ICO[3][N] = 2;
                ICO[4][N] = 0;
                ICO[5][N] = 4;
                ICO[6][N] = 4;
                if ( abs(L[2][M]-13) == 1 ) ICO[4][N] = 1;
                N = N+1;
                for (I=2; I <= 4; I++)
                {
                    if ( L[I][M] == 19 )
                    {
                        if ( L[I+1][M] <= 1 ) goto L500;
                        I = abs(L[I+1][M]-5);
                        goto L219;
                    }
                }
                goto L300;
                break;
            case 3:
                if ( L[1][2] == 14 || L[1][2] == 17 )
                {
                    if ( L[1][3] == 8 || L[1][4] == 8 ) goto L2595;
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 2;
                    ICO[4][N] = 0;
                    ICO[5][N] = 0;
                    ICO[6][N] = 4;
                    N = N+1;
                    for (I=2; I <= 4; I++)
                    {
                        if ( L[I][M] == 19 )
                        {
                            if ( L[I+1][M] <= 1 ) goto L500;
                            I = abs(L[I+1][M]-5);
                            goto L219;
                        }
                    }
                    goto L300;
                }
                ICO[1][N] = 2;
                ICO[2][N] = 0;
                ICO[3][N] = 2;
                ICO[4][N] = 4;
                ICO[5][N] = 0;
                ICO[6][N] = 4;
                if ( L[2][M] == 12 ) ICO[5][N]=1;
                if ( L[1][2] == 15 )
                {
                    N = N+1;
                    if ( L[1][2] == 15 )
                    {
                        ICO[1][N] = ICO[2][N-1];
                        ICO[2][N] = ICO[1][N-1];
                        ICO[3][N] = ICO[3][N-1];
                        ICO[4][N] = ICO[5][N-1];
                        ICO[5][N] = ICO[4][N-1];
                        ICO[6][N] = ICO[6][N-1];
                        N= N+1;
                    }
                    goto L300;
                }
                N = N+1;
                for (I=2; I <= 4; I++)
                {
                    if ( L[I][M] == 19 )
                    {
                        if ( L[I+1][M] <= 1 ) goto L500;
                        I = abs(L[I+1][M]-5);
                        goto L219;
                    }
                }
                goto L300;
                break;
            case 4:
                if ( L[1][2] >= 14 ) goto L2595;
                if ( L[1][3] == 14 )
                {
                    if ( L[1][3] == 8 || L[1][4] == 8 ) goto L2595;
                    ICO[1][N] = 1;
                    ICO[2][N] = 1;
                    ICO[3][N] = 2;
                    ICO[4][N] = 0;
                    ICO[5][N] = 0;
                    ICO[6][N] = 4;
                    N = N+1;
                    for (I=2; I <= 4; I++)
                    {
                        if ( L[I][M] == 19 )
                        {
                            if ( L[I+1][M] <= 1 ) goto L500;
                            I = abs(L[I+1][M]-5);
                            goto L219;
                        }
                    }
                    goto L300;
                }
                ICO[1][N] = 2;
                ICO[2][N] = 2;
                ICO[3][N] = 0;
                ICO[4][N] = 4;
                ICO[5][N] = 4;
                ICO[6][N] = 0;
                if ( abs(L[2][M]-13) == 1 ) ICO[6][N] = 1;
                if ( L[2][M] == 16 ) ICO[6][N] = 1;
                N = N+1;
                for (I=2; I <= 4; I++)
                {
                    if ( L[I][M] == 19 )
                    {
                        if ( L[I+1][M] <= 1 ) goto L500;
                        I = abs(L[I+1][M]-5);
                        goto L219;
                    }
                }
                goto L300;
                break;
            default:
                GOTOER();
                break;
            }
            break;
        case 9:
            goto L260; // 3
            break;
        case 10:
            goto L265; // 4
            break;
        case 11:
            goto L500; // 5
            break;
        case 12:
            goto L270; // 6
            break;
        case 13:
            goto L275; // -
            break;
        case 14:
            goto L300; // /
            break;
        case 15:
            goto L300; //
            break;
        default:
            GOTOER();
            break;
        }



L2595:
        if ( L[1][2] == 15)
        {
            if ( L[1][3] == 8 || L[1][4] == 8 ) goto L2595;
            ICO[1][N] = 1;
            ICO[2][N] = 1;
            ICO[3][N] = 2;
            ICO[4][N] = 0;
            ICO[5][N] = 0;
            ICO[6][N] = 4;
            N = N+1;
            for (I=2; I <= 4; I++)
            {
                if ( L[I][M] == 19 )
                {
                    if ( L[I+1][M] <= 1 ) goto L500;
                    I = abs(L[I+1][M]-5);
                    goto L219;
                }
            }
            goto L300;
        }
        ICO[1][N] = 3;
        ICO[2][N] = 3;
        ICO[3][N] = 2;
        ICO[4][N] = 4;
        ICO[5][N] = 4;
        ICO[6][N] = 4;
        N = N+1;
        for (I=2; I <= 4; I++)
        {
            if ( L[I][M] == 19 )
            {
                if ( L[I+1][M] <= 1 ) goto L500;
                I = abs(L[I+1][M]-5);
                goto L219;
            }
        }
        goto L300;

L260:
        //    3 FOLD ROTATION
        switch (M) {
        case 1:
            goto L500;
            break;
        case 2:
            goto L261;
            break;
        case 3:
            goto L262;
            break;
        case 4:
            goto L500;
            break;
        }
        GOTOER();
L261:
        if ( L[1][1] == 8 || J == 1 ) goto L262;
        IX = 0;
        if ( L[2][M] == 12 ) goto L2611;
        if ( L[2][M] == 13 ) goto L2612;
        spgcom.NCONT[J] = 8196;
        goto L2613;

L2611:
        spgcom.NCONT[J] = 8200;
        if ( L[1][4] != 13 ) goto L2613;
        J = J+1;
        spgcom.NCONT[J] = 2321;
        if ( L[1][2] == 14 ) spgcom.NCONT[J]=4403;
        L[1][3] = 12;
        L[1][4] = 12;
        goto L2613;
L2612:
        spgcom.NCONT[J] = 8204;
        if ( L[1][4] != 13 ) goto L2613;
        J = J+1;
        spgcom.NCONT[J] = 4369;
        if ( L[1][2] == 14 ) spgcom.NCONT[J]=2355;
        L[1][3] = 12;
        L[1][4] = 12;
L2613:
        J = J+1;
        if ( IX-1 < 0 )
        {
            //    1 FOLD ROTATION
            if ( L[2][M] != 3 ) goto L300;
            ICO[1][N] = 2;
            ICO[2][N] = 2;
            ICO[3][N] = 2;
            ICO[4][N] = 4;
            ICO[5][N] = 4;
            ICO[6][N] = 4;
            N = N+1;
            goto L300;
        }
        else if ( IX-1 == 0 )
        {
            ICO[1][N] = 2;
            ICO[2][N] = 2;
            ICO[3][N] = 0;
            ICO[4][N] = 4;
            ICO[5][N] = 4;
            ICO[6][N] = 0;
            if ( abs(L[2][M]-13) == 1 ) ICO[6][N] = 1;
            if ( L[2][M] == 16 ) ICO[6][N] = 1;
            N = N+1;
            for (I=2; I <= 4; I++)
            {
                if ( L[I][M] == 19 )
                {
                    if ( L[I+1][M] <= 1 ) goto L500;
                    I = abs(L[I+1][M]-5);
                    goto L219;
                }
            }
            goto L300;
        }
        else
        {
            ICO[1][N] = 0;
            ICO[2][N] = 0;
            ICO[3][N] = 2;
            ICO[6][N] = 4;
            if ( I == 1 || I == 5 ) ICO[4][N] = 1;
            if ( I == 2 || I == 5 ) ICO[5][N] = 1;
            N = N+1;
            if ( M == 2 && L[1][2] == 15 && I == 5 ) ICO[4][N-3]=1;
            if ( M !=  2 || L[1][2] != 17) goto L300;
            if ( L[1][3] == 2 ) ICO[6][N-1]=1;
            if ( L[1][4] == 2 ) ICO[6][N-1]=MOD(ICO[6][N-1]+1,2);
            goto L300;
        }
        //    CUBIC OR RHOMBOHEDERAL
L262:
        spgcom.NCONT[J] = 16384;
        if (L[2][M] != 3 ) goto L2620;
        J = J+1;
        spgcom.NCONT[J] = 290;
L2620:
        J = J+1;
        if ( N == 1 ) goto L300;
        I = N-1;
        IN1 = N;
        IN2 = N+1;
        ICO[1][IN1] = ICO[3][I];
        ICO[2][IN1] = ICO[1][I];
        ICO[3][IN1] = ICO[2][I];
        ICO[4][IN1] = ICO[6][I];
        ICO[5][IN1] = ICO[4][I];
        ICO[6][IN1] = ICO[5][I];
        ICO[1][IN2] = ICO[2][I];
        ICO[2][IN2] = ICO[3][I];
        ICO[3][IN2] = ICO[1][I];
        ICO[4][IN2] = ICO[5][I];
        ICO[5][IN2] = ICO[6][I];
        //L263:
        ICO[6][IN2] = ICO[4][I];
        N = IN2+1;
        goto L300;
L265:
        if ( M != 2 ) goto L500;
        ICO[1][N] = 3;
        ICO[2][N] = 1;
        ICO[3][N] = 0;
        ICO[4][N] = 4;
        ICO[5][N] = 4;
        ICO[6][N] = 0;
        if ( L[2][2] == 12 ) ICO[6][N] = 2;
        if ( L[2][2] == 13 ) ICO[6][N] = 1;
        if ( L[2][2] == 14 ) ICO[6][N] = 3;
        if ( L[2][2] ==  3 ) ICO[3][N] = 2;
        N = N+1;
        if ( L[2][2] == 3 && L[1][3] == 14 && L[1][4] == 11 ) goto L266;
        if ( L[1][3] == 14 )
        {
            ICO[1][N] = 0;
            ICO[2][N] = 2;
            ICO[3][N] = 2;
            ICO[4][N] = 0;
            ICO[5][N] = 4;
            ICO[6][N] = 4;
            if ( abs(L[2][M]-13) == 1 ) ICO[4][N] = 1;
            N = N+1;
            for (I=2; I <= 4; I++)
            {
                if ( L[I][M] == 19 )
                {
                    if ( L[I+1][M] <= 1 ) goto L500;
                    I = abs(L[I+1][M]-5);
                    goto L219;
                }
            }
            goto L300;
        }
        if ( K > 2 || L[1][1] != 7 )
        {
            ICO[1][N] = 2;
            ICO[2][N] = 2;
            ICO[3][N] = 0;
            ICO[4][N] = 4;
            ICO[5][N] = 4;
            ICO[6][N] = 0;
            if ( abs(L[2][M]-13) == 1 ) ICO[6][N] = 1;
            if ( L[2][M] == 16 ) ICO[6][N] = 1;
            N = N+1;
            for (I=2; I <= 4; I++)
            {
                if ( L[I][M] == 19 )
                {
                    if ( L[I+1][M] <= 1 ) goto L500;
                    I = abs(L[I+1][M]-5);
                    goto L219;
                }
            }
            goto L300;
        }
        if ( L[2][2]+L[3][2] != 12 )
        {
            ICO[1][N] = 2;
            ICO[2][N] = 2;
            ICO[3][N] = 0;
            ICO[4][N] = 4;
            ICO[5][N] = 4;
            ICO[6][N] = 0;
            if ( abs(L[2][M]-13) == 1 ) ICO[6][N] = 1;
            if ( L[2][M] == 16 ) ICO[6][N] = 1;
            N = N+1;
            for (I=2; I <= 4; I++)
            {
                if ( L[I][M] == 19 )
                {
                    if ( L[I+1][M] <= 1 ) goto L500;
                    I = abs(L[I+1][M]-5);
                    goto L219;
                }
            }
            goto L300;
        }
        L[2][2] = 0;
        ICO[5][N-1] = 1;
        ICO[1][N] = 2;
        ICO[2][N] = 2;
        ICO[3][N] = 0;
        ICO[4][N] = 4;
        ICO[5][N] = 4;
        ICO[6][N] = 0;
        if ( abs(L[2][M]-13) == 1 ) ICO[6][N] = 1;
        if ( L[2][M] == 16 ) ICO[6][N] = 1;
        N = N+1;
        for (I=2; I <= 4; I++)
        {
            if ( L[I][M] == 19 )
            {
                if ( L[I+1][M] <= 1 ) goto L500;
                I = abs(L[I+1][M]-5);
                goto L219;
            }
        }
        goto L300;
L266:
        if ( L[1][1] != 7 || L[1][2] != 15 ) goto L500;
        spgcom.NCONT[J  ] = 16384;
        spgcom.NCONT[J+1] = 356;
        spgcom.NCONT[J+2] = 834;
        spgcom.NCONT[J+3] = 1177;
        J = J+3;
        goto L410;
L270:
        if ( M != 2 ) goto L500;
        IX = 1;
        if ( L[2][2] == 12 ) goto L2611;
        if ( L[2][2] == 13 ) goto L2612;
        if ( L[2][2] == 14 )
        {
            spgcom.NCONT[J] = 8196;
            goto L2613;
        }
        if ( L[2][2] == 15 ) goto L2611;
        if ( L[2][2] == 16 ) goto L2612;
        if ( L[2][2] ==  3 ) goto L271;
        spgcom.NCONT[J] = 8196;
        goto L2613;
L271:
        IX = 2;
        spgcom.NCONT[J] = 8196;
        goto L2613;
L275:
        if ( M != 2 ) goto L500;
        L[1][2] = L[2][2];
        L[2][2] = 3;
        goto L218;
L300:
        ;
    }
    N = N-1;
    IJ = J;
    if ( N > 0 ) goto L301;
    J = J-1;
    goto L410;
L301:
    for(I=1; I <= N; I++)
    {
        spgcom.NCONT[J] = ICO[1][I]+16*ICO[2][I]+128*ICO[3][I]+4*MOD(ICO[4][I],4)+64*MOD(ICO[5][I],4)+ 512*MOD(ICO[6][I],4);
        J = J+1;
    }
L306:
    J = J-1;
    //DB 4
    //     PRINT 5,J,IJ,N,NSPGRP,NAXIS,NCONT
    //    1 ,ICO
    //   5 FORMAT ('0J =',I3,'  IJ =',I3,'  N =',I3,'  NSP =',2I5/
    //    1 ' NCONT =',10I4/' ICO =',6I3/(6X6I3))
    //L310:
    for(I=IJ; I <= J; I++)
    {
        NCI = I-IJ+1;
        ICO4 = MOD(ICO[4][NCI],4);
        ICO5 = MOD(ICO[5][NCI],4);
        ICO6 = MOD(ICO[6][NCI],4);
        NI4 = NDAT[ICO4+4];
        NI5 = NDAT[ICO5+4];
        NI6 = NDAT[ICO6+4];
        KJ = I+1;
        if ( (iand(spgcom.NCONT[I],307)-290) == 0 ) {
            goto L315;
        }
        else {
            goto L320;
        }
L315:
        if ( iand(spgcom.NCONT[I],7884) == 0 ) {
            goto L318;
        }
        else {
            goto L316;
        }
        //   A CENTER IS PRESENT, NOT AT 0,0,0
L316:
        file6 << endl << " A 1-bar site is present, But NOT at 0,0,0" << endl;
        goto L320;
        //   A CENTER AT 0,0,0 IS PRESENT
L318:
L320:
        if ( KJ > J ) goto L400;
        for(K=KJ; K <= J; K++)
        {
            NCK = K-IJ+1;
            KCO4 = MOD(ICO[4][NCK],4);
            KCO5 = MOD(ICO[5][NCK],4);
            KCO6 = MOD(ICO[6][NCK],4);
            NK4 = NDAT[KCO4+4];
            NK5 = NDAT[KCO5+4];
            NK6 = NDAT[KCO6+4];
            NXC = MOD(NI4+NK4,4);
            NYC = MOD(NI5+NK5,4);
            NZC = MOD(NI6+NK6,4);
            MJ = K+1;
            LOD = LODGDF(spgcom.NCONT[K],spgcom.NCONT[I]);
            if ( LOD != 290 ) goto L330;
            //   A CENTER IS GENERATED
            if ( NXC+NYC+NZC == 0 ) goto L330;
            if ( L[1][2] == 15 && I == IJ+1 ) goto L324;
L321:
            if ( NXC == 0 ) goto L322;
            if ( ICO[4][NCI] == 4 ) spgcom.NCONT[I] = spgcom.NCONT[I]+NDAT[NXC]*4;
            if ( ICO[4][NCK] == 4 ) spgcom.NCONT[K] = spgcom.NCONT[K]+NDAT[NXC]*4;
L322:
            if ( NYC == 0 ) goto L323;
            if ( ICO[5][NCI] == 4 ) spgcom.NCONT[I] = spgcom.NCONT[I]+NDAT[NYC]*64;
            if ( ICO[5][NCK] == 4 ) spgcom.NCONT[K] = spgcom.NCONT[K]+NDAT[NYC]*64;
L323:
            if ( NZC == 0 ) goto L325;
            if ( ICO[6][NCI] == 4 ) spgcom.NCONT[I] = spgcom.NCONT[I]+NDAT[NZC]*512;
            if ( ICO[6][NCK] == 4 ) spgcom.NCONT[K] = spgcom.NCONT[K]+NDAT[NZC]*512;
            goto L325;
L324:
            L[1][2] = 30;
            NIJ = ICO[6][1];
            NIJ = NDAT[NIJ+4];
            NJX = MOD(NIJ+NXC,4);
            spgcom.NCONT[IJ] = iand(spgcom.NCONT[IJ],2035)+NDAT[NJX+4]*4;
            spgcom.NCONT[IJ] = iand(spgcom.NCONT[IJ],1855)+NDAT[NIJ+4]*64;
            goto L321;
L325:
            ICO[4][NCI] = 0;
            ICO[4][NCK] = 0;
            ICO[5][NCK] = 0;
            ICO[5][NCI] = 0;
            ICO[6][NCI] = 0;
            ICO[6][NCK] = 0;
L330:
            ICO4 = MOD(spgcom.NCONT[I]/4  ,4);
            IKO4 = MOD(spgcom.NCONT[K]/4  ,4);
            ICO5 = MOD(spgcom.NCONT[I]/64 ,4);
            IKO5 = MOD(spgcom.NCONT[K]/64 ,4);
            ICO6 = MOD(spgcom.NCONT[I]/512,4);
            IKO6 = MOD(spgcom.NCONT[K]/512,4);
            NI4 = NDAT[ICO4+4];
            NK4 = NDAT[IKO4+4];
            NI5 = NDAT[ICO5+4];
            NK5 = NDAT[IKO5+4];
            NI6 = NDAT[ICO6+4];
            NK6 = NDAT[IKO6+4];
            if ( MJ > J ) goto L390;
            for(M=MJ; M <= J; M++)
            {
                NCM = M-IJ+1;
                MCO4 = MOD(ICO[4][NCM],4);
                MCO5 = MOD(ICO[5][NCM],4);
                MCO6 = MOD(ICO[6][NCM],4);
                NM4 = NDAT[MCO4+4];
                NM5 = NDAT[MCO5+4];
                NM6 = NDAT[MCO6+4];
                LOD1 = LODGDF(LOD,spgcom.NCONT[M]);
                NXC = MOD(NI4+NK4+NM4,4);
                NYC = MOD(NI5+NK5+NM5,4);
                NZC = MOD(NI6+NK6+NM6,4);
                if ( LOD1 != 290 ) goto L350;
                if ( L[1][2] == 11 ) goto L334;
                if ( NXC+NYC+NZC == 0 ) goto L380;
                if ( IJ == 1 ) goto L331;
                if (NXC +NYC  == 0 )goto L333;
                if ( L[1][3] == 14 ) goto L331;
                if ( L[1][2] == 15 ) goto L331;
                if ( L[1][2] == 14 ) goto L331;
                if ( L[1][2] == 17 ) goto L331;
                if ( L[1][2]+L[1][3]+L[1][4] < 18 && L[1][2] != 9 ) goto L331;
                NXC = MOD(spgcom.NCONT[1]/2  +NXC,4);
                NYC = MOD(spgcom.NCONT[1]/32 +NYC,4);
                NZC = MOD(spgcom.NCONT[1]/256+NZC,4);
L331:
                if ( NXC == 0 ) goto L332;
                if ( ICO[4][NCI] == 4 ) spgcom.NCONT[I] = spgcom.NCONT[I]+NDAT[NXC]*4;
                if ( ICO[4][NCK] == 4 ) spgcom.NCONT[K] = spgcom.NCONT[K]+NDAT[NXC]*4;
                if ( ICO[4][NCM] == 4 ) spgcom.NCONT[M] = spgcom.NCONT[M]+NDAT[NXC]*4;
L332:
                if ( NYC == 0 ) goto L333;
                if ( ICO[5][NCI] == 4 ) spgcom.NCONT[I] = spgcom.NCONT[I]+NDAT[NYC]*64;
                if ( ICO[5][NCK] == 4 ) spgcom.NCONT[K] = spgcom.NCONT[K]+NDAT[NYC]*64;
                if ( ICO[5][NCM] == 4 ) spgcom.NCONT[M] = spgcom.NCONT[M]+NDAT[NYC]*64;
L333:
                if ( NZC == 0 ) goto L335;
                if ( ICO[6][NCI] == 4 ) spgcom.NCONT[I] = spgcom.NCONT[I]+NDAT[NZC]*512;
                if ( ICO[6][NCK] == 4 ) spgcom.NCONT[K] = spgcom.NCONT[K]+NDAT[NZC]*512;
                if ( ICO[6][NCM] == 4 ) spgcom.NCONT[M] = spgcom.NCONT[M]+NDAT[NZC]*512;
                goto L335;
L334:
                spgcom.NCONT[I] = iand(spgcom.NCONT[I],2035);
                spgcom.NCONT[K] = iand(spgcom.NCONT[K],1855);
                spgcom.NCONT[M] = iand(spgcom.NCONT[M],511);
L335:
                ICO[4][NCI] = 0;
                ICO[5][NCI] = 0;
                ICO[6][NCI] = 0;
                ICO[4][NCK] = 0;
                ICO[5][NCK] = 0;
                ICO[6][NCK] = 0;
                ICO[4][NCM] = 0;
                ICO[5][NCM] = 0;
                ICO[6][NCM] = 0;
                goto L380;
L350:
                if ( LOD1 != 0 ) goto L380;
                //DB 3
                //     PRINT 9,LOD1,NXC,NYC,NZC,NI4,NK4,NI5,NK5,NI6,NK6
                //   9 FORMAT (* LOD1 = *O10* NXC =*I4* NYC =*I4* NZC =*I4/
                //    1 * NI4 =*I3* NK4 =*I3* NI5 =*I3* NK5 =*I3* NI6 =*I3* NK6 =*I3)
                if ( NXC+NYC+NZC == 0 ) goto L359;
                if ( L[1][2] == 30 ) goto L3500;
                if ( L[1][2] == 15 ) goto L355;
                if ( L[1][2] == 17 ) goto L359;
                if ( L[1][2] == 13 ) goto L351;
                if ( L[1][3] == 13 ) goto L352;
                if ( L[1][4] == 13 ) goto L353;
                goto L500;
L3500:
                if ( NXC == 0 ) goto L359;
                if ( L[4][2] == 4 ) goto L359;
                if ( NXC == NK4 ) goto L359;
                spgcom.NCONT[K] = ior(spgcom.NCONT[K],NDAT[NXC]*4);
                if ( L[1][4] == 13 && L[2][4] == 0 ) goto L3580;
                goto L359;
L351:
                NYC = MOD(NK5+NM5,4);
                NZC = MOD(NK6+NM6,4);
                if ( L[1][3] == 13 ) goto L354;
                if ( L[1][3] == 14 ) goto L354;
                if ( L[1][4] == 13 ) goto L354;
                M2 = I+1;
                //L3511:
                if (L[2][2] == 12 && (L[1][3] == 9  || L[1][4] == 9))  goto L360;
                if ( ICO[5][NCK] == 4 ) spgcom.NCONT[K] = spgcom.NCONT[K]+NDAT[NYC]*64;
                if ( ICO[5][NCM] == 4 ) spgcom.NCONT[M] = spgcom.NCONT[M]+NDAT[NYC]*64;
                //L3510:
                if ( NZC <= 0 ) goto L360;
                if ( ICO[6][NCK] == 4 ) spgcom.NCONT[K] = spgcom.NCONT[K]+NDAT[NZC]*512;
                if ( ICO[6][NCM] == 4 ) spgcom.NCONT[M] = spgcom.NCONT[M]+NDAT[NZC]*512;
                goto L360;
L352:
                NXC = MOD(NI4+NM4,4);
                NZC = MOD(NI6+NM6,4);
                M2 = K+1;
                if (L[2][3] == 12  && (L[1][2] == 9  ||  L[1][4] == 9)) goto L360;
                if ( NXC <= 0 ) goto L3520;
                if ( ICO[4][NCI] == 4 ) spgcom.NCONT[I] = spgcom.NCONT[I]+NDAT[NXC]*4;
                if ( ICO[4][NCM] == 4 ) spgcom.NCONT[M] = spgcom.NCONT[M]+NDAT[NXC]*4;
L3520:
                if ( NZC <= 0 ) goto L360;
                if ( ICO[6][NCI] == 4 ) spgcom.NCONT[I] = spgcom.NCONT[I]+NDAT[NZC]*512;
                if ( ICO[6][NCM] == 4 ) spgcom.NCONT[M] = spgcom.NCONT[M]+NDAT[NZC]*512;
                goto L360;
L353:
                NXC = MOD(NI4+NK4,4);
                NYC = MOD(NI5+NK5,4);
                if (L[2][4] == 12  &&  ( L[1][2] == 9 || L[1][3] == 9)) goto L359;
                if ( NXC <= 0 ) goto L3530;
                if ( ICO[4][NCI] == 4 ) spgcom.NCONT[I] = spgcom.NCONT[I]+NDAT[NXC]*4;
                if ( ICO[4][NCK] == 4 ) spgcom.NCONT[K] = spgcom.NCONT[K]+NDAT[NXC]*4;
L3530:
                if ( NYC <= 0 ) goto L359;
                if ( ICO[5][NCI] == 4 ) spgcom.NCONT[I] = spgcom.NCONT[I]+NDAT[NYC]*64;
                if ( ICO[5][NCK] == 4 ) spgcom.NCONT[K] = spgcom.NCONT[K]+NDAT[NYC]*64;
                goto L359;
L354:
                if ( NYC <= 0 ) goto L3540;
                if ( abs(L[2][2]-13) == 1 ) spgcom.NCONT[I]=spgcom.NCONT[I]+NDAT[NYC]*64;
L3540:
                if ( NZC <= 0 ) goto L3541;
                if ( ICO[6][NCK] == 4 ) spgcom.NCONT[K] = spgcom.NCONT[K]+NDAT[NZC]*512;
L3541:
                if ( NXC <= 0 ) goto L359;
                if ( L[1][4] == 0 || L[1][3] == 14 ) goto L359;
                if ( L[2][4] != 12 ) spgcom.NCONT[K]=spgcom.NCONT[K]+NDAT[NXC]*4;
                goto L359;
L355:
                L[1][2] = 30;
                if ( L[1][3] == 14 ) goto L370;
                if ( L[1][3] == 13 && L[2][3] == 12 ) goto L3561;
                if ( L[1][1] ==  7 && L[2][2] == 12 ) goto L357;
                if ( L[1][1] ==  7 && L[2][2] == 14 ) goto L357;
                if ( L[1][1] ==  6 && L[2][2] == 12 ) goto L358;
                if ( L[1][1] ==  6 && L[2][2] == 14 ) goto L358;
                if ( L[1][1] == 7 && L[1][3] == 13 ) goto L3581;
                if ( MOD(spgcom.NCONT[I],1024) == 19 ) goto L350;
                if ( NXC+NYC > 0 ) goto L356;
                if ( NZC != NM6 ) goto L359;
                if ( NZC <= 0 ) goto L359;
                spgcom.NCONT[K] = spgcom.NCONT[K]+NDAT[NZC]*512;
                goto L359;
L356:
                if ( L[3][2] == 10 || L[4][2] == 10 ) goto L359;
                if ( L[1][3] != 10 ) goto L359;
L3561:
                if ( L[2][2] == 3 ) goto L3560;
                spgcom.NCONT[I] = ior(spgcom.NCONT[I],68);
                goto L3580;
L3560:
                if ( L[1][4] == 2 ) spgcom.NCONT[K]= ior(spgcom.NCONT[K],512);
                goto L359;
L357:
                spgcom.NCONT[I] = spgcom.NCONT[I]+64;
                if ( L[3][2] != 19 ) spgcom.NCONT[I+1] = spgcom.NCONT[I+1]-512;
                if ( L[1][4] == 11 && L[3][2] == 19 ) spgcom.NCONT[I] = spgcom.NCONT[I]+588;
                goto L3580;
L358:
                spgcom.NCONT[I] = spgcom.NCONT[I]+136;
L3580:
                if ( L[1][3] != 13 ) goto L359;
L3581:
                M2 = K+1;
                goto L360;
L359:
                M2 = M+1;
L360:
                if ( M2 > J ) goto L306;
                //DB 2
                //     PRINT 6,M2,I,J,K,M
                //   6 FORMAT (*0M2 =*I3*  I =*I3*  J =*I3* K =*I3*  M =*I3)
                for(M1=M2; M1 <= J; M1++)
                {
                    spgcom.NCONT[M1-1] = spgcom.NCONT[M1];
                    for(M3=1; M3 <= 6; M3++)
                    {
                        ICO[M3][M1-1] = ICO[M3][M1];
                    }
                }
                goto L306;
L370:
                if ( L[1][4] > 12 ) goto L371;
                M2 = I+1;
                goto L360;
L371:
                L[1][2] = 13;
                if ( L[2][2] == 12 && L[1][1] == 5 ) spgcom.NCONT[I] = spgcom.NCONT[I]+200;
                if ( L[2][2] == 12 && L[1][1] == 6 ) spgcom.NCONT[I] = spgcom.NCONT[I]+136;
                if ( L[2][2] == 12 && L[1][1] == 7 ) spgcom.NCONT[I] = spgcom.NCONT[I]+652;
                if ( L[2][2] == 13 )                 spgcom.NCONT[I] = spgcom.NCONT[I]+68;
                if ( L[2][2] == 14 )                 spgcom.NCONT[I] = spgcom.NCONT[I]+140;
                goto L359;
L380:
                ;
            }
L390:
            ;
        }
L400:
        ;
    }
    LD = 0;
    for(I=1; I <= J; I++) LD = LODGDF(LD,spgcom.NCONT[I]);
    if ( LD != 0 ) goto L410;
    spgcom.NCONT[J-1] = spgcom.NCONT[J];
    J = J-1;
L410:
    spgcom.NCONT[J+1] = 0;
    //DB 1
    //     PRINT 4,K,NSPGRP,NAXIS,J,NCONT
L450:
    return;
L500:
    file6 << " Did YOU enter the space group correctly?" << endl
          << "   ERRORS of some sort were detected." << endl
          << endl << "  The card was read as:" << SPG << endl;
    spgcom.NAXIS = 4;
    goto L450;
}

void DBWS::SORT(int IPHASE)
{
    int I, J, K, L[IRS+1], M,  IC, LL, IZ, LX, IOF, INP, INP1, ITEMP[IRS+1], IIPHAS;
    Refs tmp[IRS+1];

    double R,TEMP[IRS+1];

    IOF=0;
    if (IPHASE >= 2 && IPHASE != 1000)
    {
        for(IIPHAS=2; IIPHAS <= IPHASE; IIPHAS++) IOF = IOF + ICR_[IIPHAS-1];
    }
    if (IPHASE == 1000)
    {
        IC=0;
        for(IIPHAS=1; IIPHAS <= 99; IIPHAS++) IC = IC  + ICR_[IIPHAS];
    }
    else
    {
        IC=ICR_[IPHASE];
    }
    for(I=1; I <= IC; I++) L[I]=I;
    M=IC-1;
    for(LL=1; LL <= 5000; LL++)
    {
        K=0;
        for(J=1; J <= 2; J++)
        {
            for(I=J; I <= M; I = I + 2)
            {
                INP=L[I]+IOF;
                INP1=L[I+1]+IOF;
                R=refs[INP1].refs[2]-refs[INP].refs[2];
                if (R < 0) {
                    IZ=L[I];
                    L[I]=L[I+1];
                    L[I+1]=IZ;
                    K=K+1;
                }
            }
        }
        if (K == 0) break;
    }
    for (I=1; I <= IC; I++)
    {
        tmp[I] = refs[I];

    }
    for(I=1; I <= IC; I++)
    {
        LX=L[I];
        refs[I] = tmp[LX];

    }


}

void DBWS::ASSIGN()
{
    int I, J, K, IN1, IN2, ICX;

    double RMIN, RMAX, PX, WT;

    ICX=0;
    for(J=1; J <= nphase; J++) ICX = ICX + ICR_[J];
    if (nphase > 1) SORT(1000);
    for(J=1; J <= 2; J++)
    {
        for(K=1; K <= IDSZ; K++) KRR_[J][K]=0;
    }

    if (r_lst3 != 0)
    {
        for(I=1; I <= ICX; I++)
        {
            if (MOD(I-1,60) == 0) file6 << "NO.  CODE    H   K   L  PHASE  HW       POSN              " << endl;
            file6 << " " << setw(4) << I << setw(4) << refs[I].lambda << "   "
                  << setw(4) <<  refs[I].h << setw(4) << refs[I].k << setw(4) << refs[I].l << setw(6) << refs[I].iphase
                  << setw(8) << setprecision(3) << fixed << refs[I].refs[1]
                  << setw(8) << setprecision(3) << fixed << refs[I].refs[2] << endl;
        }
    }

    for(I=1; I <= ICX; I++)
    {
        if (nprof == 5)
        {
            RMIN=refs[I].refs[2]-WDT*refs[I].FWHM[1];
            RMAX=refs[I].refs[2]+WDT*refs[I].FWHM[2];
        }
        else
        {
            RMIN=refs[I].refs[2]-WDT*refs[I].refs[1];
            RMAX=refs[I].refs[2]+WDT*refs[I].refs[1];
        }
        for(K=(min(max(int((RMIN-THMIN)/STEP+1.5),1),NPTS)); K <= (min(int((RMAX-THMIN)/STEP+1.5),NPTS)); K++)
        {
            KRR_[2][K]=I;
            if (KRR_[1][K] == 0) KRR_[1][K]=I;
        }
    }

    for(J=1; J <= nexcrg; J++)
    {
        if(AHIGH[J] > THMIN)
        {
            IN1=max( int((ALOW[J]-THMIN)/STEP+1.5) ,  1 );
            IN2=min( int((AHIGH[J]-THMIN)/STEP+1.5) , NPTS);
            for(I=IN1; I <= IN2; I++)
            {
                KRR_[2][I]=1;
                KRR_[1][I]=0;
            }
            if (IN2 == NPTS) break;
        }

    }
    if (r_lst2 != 0)
    {
        file6 << "PATTERN FROM" << setw(8) << setprecision(4) << fixed << THMIN << " TO" << setw(8) << setprecision(4) << fixed << THMAX << " IN STEPS OF" << setw(8) << setprecision(4) << fixed << STEP << " DEGREES" << endl;
        file6 <<  "POSN      I+B     B     I       100*W   K11  K21" << endl;
        for(J=1; J <= NPTS; J++)
        {
            PX=THMIN+double(J-1)*STEP;
            if (jobtyp < 3) WT=1.0/VAR_[J];
            file6 << " " << setw(8) << setprecision(4) << fixed << PX
                  << setw(7) << setprecision(0) << fixed << Y_[J]
                  << setw(7) << setprecision(0) << fixed << BK_[J]
                  << setw(7) << setprecision(0) << fixed << Y_[J]-BK_[J]
                  << setw(9) << setprecision(4) << fixed << WT*100
                  << setw(5) << KRR_[1][J]
                  << setw(5) << KRR_[2][J] << endl;
        }
    }


    for(I=1; I <= NPTS; I++)
    {
        if (KRR_[2][I]-KRR_[1][I] > NOV)
        {
            file6 << " EXCESSIVE PEAK OVERLAP" << endl
                  << "     AT THE" << setw(5) << I << "TH STEP THERE ARE " << setw(5) << KRR_[2][I]-KRR_[1][I] << " REFLECTIONS" << endl
                  << "     INCREASE THE VALUE OF *NOV* WHICH IS NOW" << setw(5) << NOV << endl;
            cout << "EXCESSIVE PEAK OVERLAP" << endl;
            exit (EXIT_FAILURE);
        }
    }
    for(I=1; I <= NPTS; I++) KR_[I]=KRR_[1][I]+IRS *KRR_[2][I];

    for(I=1; I <= NPTS; I++)
    {
        if (KR_[I] != 0 && KR_[I] != IRS ) goto L603;
    }
    cout << "NO REFLECTIONS FOUND" << endl;
    exit (EXIT_FAILURE);
    // test for detecting the asymmetry model required
    // new code included in line 2 of ICF
    // iasym = 0 (usual Rietveld asymmetry)
    // iasym = 1 (new asymmetry. Riello, Canton & Fagherazzi.PD 10,3,204-206,1997)
L603:
    if (iasym == 0)
    {
        // THE FOLLOWING TEST IS REALLY ONLY VALID FOR THE SINGLE PHASE CASE
        if (refs[KRR_[1][I]].refs[2] >= RLIM && phases[1].PAR[14].codeword.L != 0)
        {
            file6 << " ASYMMETRY PARAMETER USAGE INVALID" << endl;
            cout << "ASYMMETRY PARAMETER USAGE INVALID" << endl;
            exit (EXIT_FAILURE);
        }
    }
    else
    {
        if (refs[KRR_[1][I]].refs[2] >= (90.0-RLIM) && phases[1].PAR[14].codeword.L != 0)
        {
            file6 << " ASYMMETRY PARAMETER USAGE INVALID" << endl;
            cout << "ASYMMETRY PARAMETER USAGE INVALID" << endl;
            exit (EXIT_FAILURE);
        }
    }
    for(I=1; I <= nphase; I++)
    {
        if (phases[I].PAR[12] == 0.0 && phases[I].PAR[13] == 0.0 && phases[I].PAR[13].codeword.L != 0)
        {
            file6 << " PREFERRED ORIENTATION USAGE INVALID" << endl;
            cout << "PREFERRED ORIENTATION USAGE INVALID" << endl;
            exit (EXIT_FAILURE);
        }
    }
}

void DBWS::CHISQ()
{
    int I,IEXC,NPTHI,NPTLOW;
    double DEL,DELW, DELWP,SDELW, SDELWP;

    R_S1=0.0;
    R_S2=0.0;
    R_SS2=0.0;
    R_S3=0.0;
    R_S4=0.0;
    R_SS4=0.0;
    R_D1=0.0;
    R_D2=0.0;
    R_D4=0.0;
    DELW =1.0E+25;
    DELWP=1.0E+25;
    for(I=1; I <= NPTS; I++)
    {
        if ((nbckgd != 0 && KR_[I] == 0) || KR_[I] == IRS )goto L10;
        if (nexcrg > 0)
        {
            for(IEXC=1; IEXC <= nexcrg; IEXC++)
            {
                NPTLOW = (ALOW[IEXC]-THMIN)/STEP + 1.5;
                NPTHI  = (AHIGH[IEXC]-THMIN)/STEP + 1.5;
                if (I >= NPTLOW && I <= NPTHI) goto L10;
            }
        }
        if (DELW < 1.0E+24) DELWP = DELW;
        if (SDELW < 1.0e+24) SDELWP = SDELW;
        DEL=Y_[I]-BK_[I]-YC_[I];
        DELW = DEL/sqrt(VAR_[I]);
        SDELW = DEL;
        R_S1=R_S1+abs(DEL);
        R_S2=R_S2+DEL*DEL/VAR_[I];
        R_SS2 = R_SS2 + DEL*DEL;
        if (DELWP < 1.0E+24) R_S4=R_S4+(DELW-DELWP)*(DELW-DELWP);
        if (SDELWP < 1.0e+24) R_SS4=R_SS4+(SDELW-SDELWP)*(SDELW-SDELWP);
L10:
        ;
    }
    for(I=1; I <= NPTS; I++)
    {
        if ((nbckgd != 0 && KR_[I] == 0) || KR_[I] == IRS ) goto L15;
        if (nexcrg > 0)
        {
            for(IEXC=1; IEXC <= nexcrg; IEXC++)
            {
                NPTLOW = (ALOW[IEXC]-THMIN)/STEP + 1.5;
                NPTHI  = (AHIGH[IEXC]-THMIN)/STEP + 1.5;
                if (I >= NPTLOW && I <= NPTHI) goto L15;
            }
        }
        R_D1=R_D1+Y_[I];
        R_D2=R_D2+Y_[I]*Y_[I]/VAR_[I];
        R_S3=R_S3+BK_[I]+YC_[I];
L15:
        ;
    }
    R_p =100.0*R_S1/R_D1;
    R_wp=100.0*sqrt(R_S2/R_D2);
}

void DBWS::COMPTON(int K, double STH, double* CISK)
{
//-----THIS SUBROUTINE IS USED TO COMPUTE:
//    CISK = COMPTON INTENSITY SCATTERED BY THE K-TH CRYSTALLINE PHASE
//            AT THE IPM-TH POINT OF THE X-RAY SPECTRUM.
//     THE METHOD FOLLOWED IS THAT REPORTED IN :
//*****A NEW ANALYTIC APPROXIMATION TO ATOMIC INCOHERENT X-RAY SCATTERING
//     INTENSITIES.
//     BY VEDENE H. SMITH JR. AJIT J. THAKKAR AND DOUGLAS C. CHAPMAN
//     ACTA CRYST. (1975). A31, 391-392.
//-----COMPTON SCATTERING OF THE AMORPHOUS PHASE IS CONTAINED INTO AM(S)
//    MOREOVER CISK IS MULTIPLIED BY THE FOLLOWING GEOMETRICAL FACTOR:
//     SEE:
//     RULAND, ACTA CRYST. 1961, 14, 1180.
//     ASS1 = CORRECTION FOR ABSORPTION OF COMPTON SCATTERING BY THE SAMPLE
//     BDF  = BREIT-DIRAC RECOIL FACTOR
//     ASS2 = CORRECTION FOR ABSORPTION BY AIR CONTAINED BETWEEN THE SAMPLE
//            AND THE COUNTER
//     ASS3 = CORRECTION FOR THE CUTTING UP OF COMPTON SCATTERING BY THE
//            MONOCHROMATOR ( ALSO COMPTON SCATTERING IS DIFFRACTING )

    //-----HMC = H/MC
    const double HMC = 0.024263935;

    int I, J,NK,IOF, ICX,IRL;
    double S, S2, S4,BDF,CSP[2+1],ASS1, ASS2, ASS3, FDEN, FNUM;




    //-----NK = ATOMS IN THE ASSIMETRIC UNIT OF K-TH PHASE
    NK = phases[K].NATOM;
    //-----IRL = NUMBER OF EQUIVALENT POSITION - ALSO THE IDENTITY
    //           AND IF IT IS PRESENT THE SIMMETRY CENTRE
    IRL = rtmtx.MLTPHS[K];
    //-----CALCULATE IOF = ALL ATOMS OF THE K-1 PHASES
    IOF = 0;
    if (K > 1)
    {
        for(I = 2; I <= K; I++) IOF = IOF + phases[I-1].NATOM;
    }
    for(ICX = 1; ICX <= 2; ICX++)
    {
        S  =  STH / LAMDA[ICX];
        S2 =  S * S;
        S4 = S2 * S2;
        CSP[ICX] = 0.0;
        for(I = 1; I <= NK; I++)
        {
            J = atoms[I+IOF].PTC;
            FNUM    =   1.0 + comp.CC[1][J] * S2 + comp.CC[2][J] * S4;
            FDEN    = pow(( 1.0 + comp.CC[3][J] * S2 + comp.CC[4][J] * S4 ),2);
            CSP[ICX]=CSP[ICX] + comp.ZEFF[J] * atoms[I+IOF].AtomPAR[5] * (1.0-(FNUM/FDEN));
        }
        CSP[ICX] = CSP[ICX] * double(IRL);
        //-----UPDATE S
        S  = 2.0 * S;
        S2 =   S * S;
        //-----COMPUTE ASS1
        ASS1 =   1.0 + 0.75 * HMC * LAMDA[ICX] * S2;
        //-----COMPUTE BDF
        BDF  = pow( ( 1.0 + 0.50 * HMC * LAMDA[ICX] * S2 ) , 2);
        //-----COMPUTE ASS2 = EXP (-DELTA(MU)*D)
        //      WHERE:
        //      MU       = ABSORPTION COEFFICIENT OF AIR
        //      DELTA(MU)= VARIATION OF MU WITH LAMDA, WAS CALCULATED BY RIELLO
        //                 USING REGRESSION ANALYSIS ON ESTIMATED MU BY ASSUMING
        //                 AIR COMPOSITION 20% O2 AND 80% N2 AT 300øK AND 1 ATM.:
        //                 MU = (E ** 3.40089)*(1.0E-04)*( LAMDA ** 2.79287)
        //      D = 17.3 CM. DISTANCE SPECIMENT-COUNTER OR RADIUS OF THE CAMERA
        ASS2 = exp(-1.5*HMC*17.3*(29.99E-04)*( pow(LAMDA[ICX],3.79287) )*S2);
        //-----COMPUTE ASS3
        //     FORMULA MUST BE CHANGED FOR OTHER RADIATION AND MONOCHROMATOR
        //-----  ASS3 IS A LORENTZIAN FUNCTION
        ASS3=1/(1+GLB[18]* pow(S,GLB[19]) );
        //----- ASS3 IS A GAUSSIAN FUNCTION
        //       ASS3=exp(-params.GLB(18)*S2)
        //     ASS3=0.38*exp(-4.0*S2)+0.62*exp(-0.15*S2)
        CSP[ICX] = CSP[ICX] * ASS2 * ASS3  / ( ASS1 * BDF );
    }
    //     COMPUTE CISK = COMPTON INTENSITY SCATTERED BY THE K-TH PHASE
    *CISK = RATIO[1] * CSP[1] + RATIO[2] * CSP[2];
}

void DBWS::DISORDER(int K,double STH,int IDERIV,double *SDK,double *DYC,int FONDO)
{
    //
    //-----THIS SUBROUTINE COMPUTES SDK = THE SCATTERING DUE TO THE THERMAL
    //     OR LATTICE DISORDER IN THE SAMPLE FOR K-TH PHASE AT THE IPM POINT,
    //     (THEN ALSO IN STEP POINTS THAT DO NOT CONTAIN BRAGG REFLECTIONS),
    //     P.RIELLO, G. FAGHERAZZI, D. CLEMENTE AND P.CANTON IN
    //     J. APPL. CRYST. (1995) 28,115-120

    int I,II, NI, NK, LK,IOF,ICX, IRL;
    double FI,DER[2+1],DIS[2+1],STHL2[2+1];


    //-----COMPUTE IOF = ATOM NUMBER IN THE K-1 PHASE
    IOF = 0;
    if (K > 1)
    {
        for(I = 2; I <= K; I++) IOF = IOF + phases[I-1].NATOM;
    }
    for(I=1; I <= NATS; I++)
    {
        atoms[I].DERDIS[1]=0.0;
        atoms[I].DERDIS[2]=0.0;
    }
    //-----IRL = NUMBER OF EQUIVALENT POSITIONS- ALSO THE IDENTITY POSITION
    //           AND THE SIMMETRY CENTRE IF PRESENT
    IRL = rtmtx.MLTPHS[K];
    //-----NK = NUMBER OF ATOMS IN THE K-TH PHASE
    NK  = phases[K].NATOM;
    for(ICX = 1; ICX <= 2; ICX++)
    {
        STHL2[ICX] = pow(( STH / LAMDA[ICX] ) , 2);
        if (FONDO == 1)
        {
            //-----COMPUTE FI2 = SUM OF SQUARE SCATTERING FACTORS DUE TO ALL ATOMS
            //                   IN THE CELL AT LAMDA(ICX) CORRECTED FOR THE ISOTROPIC
            //                    THERMAL FACTORS.
            atfat.FI2[ICX] = 0.0;
            for(I = 1; I <= NK; I++)
            {
                NI = atoms[I+IOF].PTR;
                FI = 0.0;
                AC_[10][NI] = 0.0;
                for(II = 1; II <= 9; I+=2) FI = FI + AC_[II][NI]*exp(-AC_[II+1][NI]*STHL2[ICX]);
                FI = FI + DFP[NI];
                atfat.FI2[ICX] = atfat.FI2[ICX] + atoms[I+IOF].AtomPAR[5] * double(IRL)*( 1.0 - exp(-atoms[I+IOF].AtomPAR[4]*2.0*STHL2[ICX]) )* (pow(FI,2)+pow(DFPP[NI],2));
                //-----NEXT LINES EVALUATE THE DERIVATES
                if (atoms[I+IOF].AtomPAR[4].codeword.L != 0 && IDERIV == 2)
                {
                    atoms[I+IOF].DERDIS[ICX] = atoms[I+IOF].AtomPAR[5] * 2.0 * STHL2[ICX] * exp(-atoms[I+IOF].AtomPAR[4]*2.0*STHL2[ICX])*double(IRL)*(pow(FI,2)+pow(DFPP[NI],2));
                }
                else
                {
                    atoms[I+IOF].DERDIS[ICX]=0.0;
                }
            }
            DIS[ICX] = atfat.FI2[ICX];
        }
        if (FONDO == 2)
        {
            //-----COMPUTE FI2 = SUM OF SQUARE SCATTERING FACTORS DUE TO ALL ATOMS
            //                   IN THE CELL AT LAMDA(ICX) CORRECTED FOR THE OVERALL
            //                    THERMAL FACTORS.
            atfat.FI2[ICX] = 0.0;
            for(I = 1; I <= NK; I++)
            {
                NI = atoms[I+IOF].PTR;
                FI = 0.0;
                AC_[10][NI] = 0.0;
                for(II = 1; II <= 9; I+=2) FI = FI + AC_[II][NI]*exp(-AC_[II+1][NI]*STHL2[ICX]);
                FI = FI + DFP[NI];
                atfat.FI2[ICX] = atfat.FI2[ICX] + atoms[I+IOF].AtomPAR[5] * (pow(FI,2)+pow(DFPP[NI],2));
            }
            atfat.FI2[ICX] = atfat.FI2[ICX] * double(IRL);
            DIS[ICX] = ( 1.0 - exp(-phases[K].PAR[2]*2.0*STHL2[ICX]) ) * atfat.FI2[ICX];
            LK =phases[K].PAR[2].codeword.L;
            if (LK != 0 && IDERIV == 2)
            {
                DER[ICX] = 2.0 * STHL2[ICX] * atfat.FI2[ICX] * exp(-phases[K].PAR[2]*2.0*STHL2[ICX]);
            }
            else
            {
                DER[ICX] = 0.0;
            }
        }
    }

    //-----COMPUTE SDK = SCATTERING DISORDER DUE TO THE K-TH PHASE
    *SDK = RATIO[1] * DIS[1] + RATIO[2] * DIS[2];

    //-----COMPUTE  DERIVATIVE OF YC RESPECT TO ISOTROPIC THERMAL FACTORS
    //                   XL(I+IOF,4) IN THE K-TH PHASE
    if (FONDO == 1)
    {
        for(I=1; I <= NK; I++)
        {
            if (atoms[I+IOF].AtomPAR[4].codeword.L != 0 && IDERIV == 2)
            {
                atoms[I+IOF].DERISO=RATIO[1] * atoms[I+IOF].DERDIS[1] + RATIO[2] * atoms[I+IOF].DERDIS[2];
            }
            else
            {
                atoms[I+IOF].DERISO=0.0;
            }
        }
    }

    //-----COMPUTE  DERIVATIVE OF YC RESPECT TO OVERALL THERMAL FACTOR
    //                   PAR(K,2) IN THE K-TH PHASE
    if (FONDO == 2)
    {
        if (LK != 0 && IDERIV == 2)
        {
            *DYC = RATIO[1] * DER[1] + RATIO[2] * DER[2];
        }
        else
        {
            *DYC = 0.0;
        }
    }
}

void DBWS::SMTRY2(int IPHASE)
{
    //                             THIS SR GENERATES THE FULL SET OF
    //                           EQUIVALENT HKLS FROM ANY MEMBER OF THE SET.
    //                           IT ALSO DETERMINES THE PHASE SHIFTS RELATIVE
    //                           TO THE INPUT HKL PHASE.

    const int KD[6+1] = {0, 0,6,3,9,4,8 };
    const int KE[3+1] = {0, 0,4,8 };
    const int KF[3+1] = {0, 0,8,4 };

    int I, J, L, M, N,LA, JD, LD[3+1][24+1], MS, NCH[24+1], NCK[24+1],
        NCL[24+1], IPH[24+1], NCO, NCX, K1JD, IXIT;
    double CI;


    if ( spgcom.NC <= 0 )
    {
        if ( hklctl.IHKL[1][1] < 0)
        {
            hklctl.IHKL[1][1] = -hklctl.IHKL[1][1];
            hklctl.IHKL[2][1] = -hklctl.IHKL[2][1];
            hklctl.IHKL[3][1] = -hklctl.IHKL[3][1];
        }
        else if ( hklctl.IHKL[1][1] == 0)
        {
            if ( hklctl.IHKL[2][1] < 0 )
            {
                hklctl.IHKL[2][1] = -hklctl.IHKL[2][1];
                hklctl.IHKL[3][1] = -hklctl.IHKL[3][1];
            }
            else if ( hklctl.IHKL[2][1] == 0 )
            {
                if ( hklctl.IHKL[3][1] < 0) {
                    hklctl.IHKL[3][1] = -hklctl.IHKL[3][1];
                }
            }
        }
    }



    IPH[1] = hklctl.IHKL[3][1]+512*(hklctl.IHKL[2][1]+512*hklctl.IHKL[1][1]);
    CI = 1.0;
    hklctl.ICHKL[IPHASE] = 1;
    hklctl.AZ[1] = 0.0;
    LD[1][1] = 0;
    LD[2][1] = 0;
    LD[3][1] = 0;
    NCH[1] = 0;
    NCK[1] = 0;
    NCL[1] = 1;
    if ( hklctl.N1HKL[IPHASE] != 0 )
    {
        L = 2;
        for(I=1; I <= hklctl.N1HKL[IPHASE]; I++)
        {
            CI = CI*2.0;
            if ( hklctl.NC1[I][1][IPHASE] > 0 ) CI = CI*1.5;
            for(J=1; J <= hklctl.ICHKL[IPHASE]; J++)
            {
                NCO = hklctl.NC1[I][1][IPHASE]+1;
                switch (NCO) {
                case 1:
                    NCH[L] =  ieor(NCH[J],hklctl.NC1[I][2][IPHASE]);
                    if ( MOD(hklctl.NC1[I][2][IPHASE],2) != 0 ) NCH[L] = ieor(NCK[J],hklctl.NC1[I][2][IPHASE]);
                    M = 1+MOD(NCH[L],2);
                    MS = 1-2*MOD(NCH[L]/2,2);
                    N = abs(NCL[J]);
                    hklctl.IHKL[M][L] = hklctl.IHKL[1][N]*MS;
                    M = 1+MOD(hklctl.NC1[I][2][IPHASE],2);
                    MS = 1-2*MOD(hklctl.NC1[I][2][IPHASE]/2,2);
                    NCX = hklctl.NC1[I][3][IPHASE]+1;
                    LD[1][L] = KD[NCX]+LD[M][J]*MS;
                    NCK[L] =  ieor(NCK[J],hklctl.NC1[I][4][IPHASE]);
                    if ( MOD(hklctl.NC1[I][4][IPHASE],2) != 0 ) NCK[L]= ieor(NCH[J],hklctl.NC1[I][4][IPHASE]);
                    M = 2-MOD(NCK[L],2);
                    MS = 1-2*MOD(NCK[L]/2,2);
                    hklctl.IHKL[M][L] = hklctl.IHKL[2][N]*MS;
                    M = 2-MOD(hklctl.NC1[I][4][IPHASE],2);
                    MS = 1-2*MOD(hklctl.NC1[I][4][IPHASE]/2,2);
                    NCX = hklctl.NC1[I][5][IPHASE]+1;
                    LD[2][L] = KD[NCX]+LD[M][J]*MS;
                    MS = (1-2*hklctl.NC1[I][6][IPHASE])*ISIGN(1,NCL[J]);
                    NCL[L] = MS*NCL[N];
                    hklctl.IHKL[3][L] = hklctl.IHKL[3][N]*MS;
                    NCO = hklctl.NC1[I][7][IPHASE]+1;
                    if ( NCO > 5 ) NCO=6;
                    MS = 1-2*hklctl.NC1[I][6][IPHASE];
                    if ( N > 1 && NCK[J] >= 4 && M == 1 ) MS=-MS;
                    LD[3][L] = KD[NCO]+LD[3][J]*MS;
                    IXIT = 0;
                    IPH[L] = hklctl.IHKL[3][L]+512*(hklctl.IHKL[2][L]+512*hklctl.IHKL[1][L]);
                    LA = LD[1][L]*hklctl.IHKL[1][1]+LD[2][L]*hklctl.IHKL[2][1]+LD[3][L]*hklctl.IHKL[3][1];
                    hklctl.AZ[L] = double(LA)/12.0;
                    //DB 2
                    //     if ( J1(20) > 0 ) PRINT 1,L,(IHKL(M,L),M=1,3),(LD(M,L),M=1,3),
                    //    Z AZ(L),NCH(L),NCK(L),NCL(L),(NC1(I,M,IPHASE),M=1,7)
                    if ( spgcom.NC != 0 ) goto L89;
                    if ( spgcom.NSPGRP < 12 ) goto L89;
                    if ( hklctl.NC1[I][1][IPHASE] > 0 ) goto L89;
                    if ( MOD(hklctl.NC1[I][2][IPHASE],2) == 1 ) goto L89;
                    if ( IPH[L] <= 0 ) goto L680;
                    goto L89;
                    break;
                case 2:
                    IXIT = 2;
                    JD = J;
                    goto L750;
                    break;
                case 3:
                    goto L800;
                    break;
                case 4:
                    if (MOD(hklctl.IHKL[1][1]-hklctl.IHKL[2][1]-hklctl.IHKL[3][1],3) != 0 ) goto L1002;
                    goto L900;
                    break;
                default:
                    GOTOER();
                    break;
                }



    L89:
                for(M=2; M <= L; M++)
                {
                    if ( IPH[M-1] == IPH[L] )
                    {
                        if ( AMOD(abs(hklctl.AZ[L]-hklctl.AZ[M-1]),1.0) != 0.0 ) goto L1002;
                        goto L680;
                    }
                    if ( spgcom.NC == 0 )
                    {
                        if ( IPH[M-1] == -IPH[L] )
                        {
                            if ( AMOD(abs(hklctl.AZ[L]-hklctl.AZ[M-1]),1.0) != 0.0 ) goto L1002;
                            goto L680;
                        }
                    }
                }
                L = L+1;


    L680:
                if ( IXIT-1 < 0)
                {
                    goto L890;
                }
                else if ( IXIT-1 == 0)
                {
                    goto L750;
                }
                else
                {
                    goto L850;
                }

    L750:
                IXIT = IXIT-1;
                LD[1][L] = LD[1][JD];
                LD[2][L] = LD[2][JD];
                LD[3][L] = LD[3][JD];
                NCH[L] = 0;
                NCK[L] = 0;
                NCL[L] = L;
                K1JD = hklctl.IHKL[1][JD];
                hklctl.IHKL[1][L] = hklctl.IHKL[2][JD];
                hklctl.IHKL[2][L] = hklctl.IHKL[3][JD];
                hklctl.IHKL[3][L] = K1JD;
                JD = L;
                IPH[L] = hklctl.IHKL[3][L]+512*(hklctl.IHKL[2][L]+512*hklctl.IHKL[1][L]);
                LA = LD[1][L]*hklctl.IHKL[1][1]+LD[2][L]*hklctl.IHKL[2][1]+LD[3][L]*hklctl.IHKL[3][1];
                hklctl.AZ[L] = double(LA)/12.0;
                //DB 2
                //     if ( J1(20) > 0 ) PRINT 1,L,(IHKL(M,L),M=1,3),(LD(M,L),M=1,3),
                //    Z AZ(L),NCH(L),NCK(L),NCL(L),(NC1(I,M,IPHASE),M=1,7)
                if ( spgcom.NC != 0 ) goto L89;
                if ( spgcom.NSPGRP < 12 ) goto L89;
                if ( hklctl.NC1[I][1][IPHASE] > 0 ) goto L89;
                if ( MOD(hklctl.NC1[I][2][IPHASE],2) == 1 ) goto L89;
                if ( IPH[L] <= 0 ) goto L680;
                goto L89;
    L800:
                IXIT = 4;
                JD = J;
                NCO = hklctl.NC1[I][6][IPHASE];
    L850:
                IXIT = IXIT-2;
                NCH[L] = 0;
                NCK[L] = 4;
                NCL[L] = L;
                LD[1][L] = 0;
                LD[2][L] = 0;
                hklctl.IHKL[1][L] = -hklctl.IHKL[1][JD]-hklctl.IHKL[2][JD];
                hklctl.IHKL[2][L] = hklctl.IHKL[1][JD];
                hklctl.IHKL[3][L] = hklctl.IHKL[3][JD];
                LD[3][L] = KF[NCO]+LD[3][JD];
                if ( MOD(NCH[J],2) != 0 ) LD[3][L]=KE[NCO]+LD[3][JD];
                JD = L;
                IPH[L] = hklctl.IHKL[3][L]+512*(hklctl.IHKL[2][L]+512*hklctl.IHKL[1][L]);
                LA = LD[1][L]*hklctl.IHKL[1][1]+LD[2][L]*hklctl.IHKL[2][1]+LD[3][L]*hklctl.IHKL[3][1];
                hklctl.AZ[L] = double(LA)/12.0;
                //DB 2
                //     if ( J1(20) > 0 ) PRINT 1,L,(IHKL(M,L),M=1,3),(LD(M,L),M=1,3),
                //    Z AZ(L),NCH(L),NCK(L),NCL(L),(NC1(I,M,IPHASE),M=1,7)
                if ( spgcom.NC != 0 ) goto L89;
                if ( spgcom.NSPGRP < 12 ) goto L89;
                if ( hklctl.NC1[I][1][IPHASE] > 0 ) goto L89;
                if ( MOD(hklctl.NC1[I][2][IPHASE],2) == 1 ) goto L89;
                if ( IPH[L] <= 0 ) goto L680;
                goto L89;
    L890:
                ;
            }
    L900:
            hklctl.ICHKL[IPHASE] = L-1;
        }
    }
    hklctl.IER = 0;
    if ( spgcom.NC != 0 ) goto L1001;
    for(M=2; M <= hklctl.ICHKL[IPHASE]; M++)
    {
        if ( IPH[M] <= 0 )
        {
            hklctl.IHKL[1][M] = -hklctl.IHKL[1][M];
            hklctl.IHKL[2][M] = -hklctl.IHKL[2][M];
            hklctl.IHKL[3][M] = -hklctl.IHKL[3][M];
        }
    }
L1001:
    return;
L1002:
    hklctl.IER = 1;
    goto L1001;
}

void DBWS::CALCUL(int NN)
{
    double DPRECORX, H[3+1],T[3+1], X, B1, B2, BB, AL[3+1][3+1], EH,
           AV, XI[14], SM[3+1][3+1], CV,DV, BV,TR, SS, TT, SR,
          YY,DA1, DA3, DA4, DA5, BNI, ARG,
          PAK, TAV, TLR, SBI, ARG2, FFX, DER, SRD,
          TLG, TLL, COSA, SINA, SITH,
          SSNN, SNXI, SUMA, SUMB, DHDHG, DHDHL, PAKNN, DERIV[MSZ+1], SINTH, COSTH,
          TANTH, PREXP,
          SNEXI, SLABDA,TANTHE, EXPARG, PRECOR, PREXPX, DPRECOR, PRECORX;
    double SINTL[NOV+1];
    int I, J, K, N, II, IJ,JJ,NX,NM,IR, IV, NI,KL,IOF, IRL, KKL,ICENT,ISITH,IIPHAS;
    bool PAC,VERT;


    IOF = 0;
    if ( refs[NN].iphase > 1 )
    {
        for(IIPHAS=2; IIPHAS <= refs[NN].iphase; IIPHAS++) IOF = IOF + phases[IIPHAS-1].NATOM;
    }
    IRL = rtmtx.MLTPHS[refs[NN].iphase];
    N = phases[refs[NN].iphase].NATOM;
    ICENT = rtmtx.ICNTPHS[refs[NN].iphase];
    //-----ZEROIZE THE DERIVATIVES OF THIS REFLECTION W.R.T. TO PARAMETERS
    NX=0;
    for(IIPHAS=1; IIPHAS <= nphase; IIPHAS++) NX = NX+phases[IIPHAS].NATOM;
    for (I=1; I <= MSZ; I++) DERIV[I]=0.0;
    for(I=1; I <= NX; I++)
    {
        for(J=1; J <= 9; J++)
        {
            atoms[I].SUMBX[J] = 0.0;
            atoms[I].SUMAX[J] = 0.0;
        }
    }
    CV=0.0;
    DV=0.0;
    AV=0.0;
    BV=0.0;
    PAC = refs[NN].phase->PAR[12] != 0.0  ||  refs[NN].phase->PAR[12].codeword.L != 0 ||  refs[NN].phase->PAR[13] != 0.0  ||  refs[NN].phase->PAR[13].codeword.L != 0;

    /*

      a11 a12 a13      a  γ  β
      a21 a22 a23   =  γ  b  α
      a31 a32 a33      β  α  c


    */


    for(I=1; I <= 3; I++) AL[I][I]=refs[NN].phase->PAR[I+5];
    AL[3][2]=refs[NN].phase->PAR[9];
    AL[2][3]=AL[3][2];
    AL[3][1]=refs[NN].phase->PAR[10];
    AL[1][3]=AL[3][1];
    AL[2][1]=refs[NN].phase->PAR[11];
    AL[1][2]=AL[2][1];

    if (nprof == 6)
    {
        EH=refs[NN].phase->PAR[21];
    }
    B1=refs[NN].phase->PAR[12];
    B2=refs[NN].phase->PAR[13];
    NM=MOD(NN,NOV)+1;
    SLABDA=LAMDA[refs[NN].lambda]*LAMDA[refs[NN].lambda]/4.0;
    N=refs[NN].phase->NATOM;
    refs[NN].FMGNTD=0.0;
    PAKNN=0.0;
    PRECOR=1.0;
    TR=0.0;

    //-----CALCULATION OF TEMP.FACTOR,POSITION AND FWHM


    hklctl.IHKL[1][1] = refs[NN].h;
    hklctl.IHKL[2][1] = refs[NN].k;
    hklctl.IHKL[3][1] = refs[NN].l;

    SS = refs[NN].h*AL[1][1]*refs[NN].h+
         refs[NN].h*AL[1][2]*refs[NN].k+
         refs[NN].h*AL[1][3]*refs[NN].l+
         refs[NN].k*AL[2][2]*refs[NN].k+
         refs[NN].k*AL[2][3]*refs[NN].l+
         refs[NN].l*AL[3][3]*refs[NN].l;

    if ( PAC )
    {
        TT = 0.0;
        for(I=1; I <= 3; I++)
        {
            for(J=I; J <= 3; J++) TT = TT+refs[NN].phase->PREF[I]*AL[I][J]*refs[NN].phase->PREF[J];             // GSAS DP2
        }
        SMTRY2(refs[NN].iphase);
        PRECOR = 0.0;
        PREXP = 0.0;
        DPRECOR = 0.0;
        for(IJ=1; IJ <= hklctl.ICHKL[refs[NN].iphase]; IJ++)
        {
            PAK = 0.0;
            for(I=1; I <= 3; I++)
            {
                for(J=I; J <= 3; J++) PAK = refs[NN].phase->PREF[I]*AL[I][J]*double(hklctl.IHKL[J][IJ])+PAK;     // GSAS CA
            }
            PAK = PAK*PAK/(TT*SS);

            if (PAK != 0)
            {
                PAKNN=pow(atan( sqrt(abs( (1.0-PAK) / PAK)) ) , 2);
            }
            else
            {
                PAKNN = _180_pi_sqr;
            }
            if (ipref == 0)
            {
                PREXPX = exp(B1*PAKNN);
                PRECORX = B2+(1.0-B2)*PREXPX;
                DPRECORX = PAKNN*(1.0-B2)*PREXPX/PRECORX;
            }
            else
            {
                PREXPX = B1*B1*PAK+(1.0-PAK)/B1;
                PRECORX = 1.0/pow(PREXPX,1.5);
                DPRECORX = -1.5*(2.0*B1*PAK-(1.0-PAK)/B1/B1)/( pow(PREXPX,2.5) *PRECORX);
            }
            PREXP = PREXP+PREXPX;
            PRECOR = PRECOR+PRECORX;
            DPRECOR = DPRECOR+DPRECORX;
        }
        PREXP = PREXP/double(hklctl.ICHKL[refs[NN].iphase]);
        PRECOR = PRECOR/double(hklctl.ICHKL[refs[NN].iphase]);
        DPRECOR = DPRECOR/double(hklctl.ICHKL[refs[NN].iphase]);
    }
    SINTL[NM] = sqrt(SS);
    SSNN = 0.25*SS;
    TAV = exp(-2.0*refs[NN].phase->PAR[2]*SSNN)*PRECOR;
    SINTH = SLABDA*SS;
    COSTH = 1.0-SINTH;
    TANTH = sqrt(SINTH/COSTH);
    g4.TANN[NM] = TANTH;

    //   Correction of microabsorption
    switch (iabsr) {
    case 1:
        ISITH=(1.0)/(sqrt(SINTH));
        SR = GLB[12]*(1.0-GLB[8]*exp(-GLB[9])+GLB[8]*exp(-GLB[9]/sqrt(SINTH)))+(1.0-GLB[12])*(1+GLB[13]*(asin(sqrt(SINTH)))-M_PI_2);
        break;
    case 2:
        SITH = sqrt(SINTH);
        SR = 1.0-GLB[13]*(asin(SITH)-M_PI_2);
        break;
    case 3:
        ISITH=(1.0)/(sqrt(SINTH));
        SR = 1.0-GLB[8]*exp(-GLB[9])+GLB[8]*exp(-GLB[9]*ISITH);
        break;
    case 4:
        ISITH=(1.0)/(sqrt(SINTH));
        SR = 1.0-GLB[8]*GLB[9]*(1.0-GLB[9])-ISITH*GLB[8]*GLB[9]*(1.0-GLB[9]*ISITH);
        break;
    }


    refs[NN].refs[2]= 2.0 * radtodeg( atan(TANTH) );

    refs[NN].HALFG=(
                refs[NN].phase->PAR[3]*
                TANTH*TANTH+
                refs[NN].phase->PAR[4]*
                TANTH+refs[NN].phase->PAR[5]+refs[NN].phase->PAR[20]/COSTH+EH/(TANTH*TANTH));

    if (refs[NN].HALFG > 0.0)
    {
        refs[NN].HALFG = sqrt(refs[NN].HALFG);
    }
    else
    {
        file6 << endl << "SQUARE OF FWHM NEGATIVE AT TWO-THETA=" << setw(8) << setprecision(3) << refs[NN].refs[2] << "FOR PHASE NO. " << refs[NN].iphase << endl;
        cout << endl << "SQUARE OF FWHM NEGATIVE AT TWO-THETA=" << setw(8) << setprecision(3) << refs[NN].refs[2] << "FOR PHASE NO. " << refs[NN].iphase << endl;
        exit(EXIT_FAILURE);
    }

    if (nprof == 8)
    {
        refs[NN].HALFL =
                refs[NN].phase->PAR[15]
                * TANTH +
                refs[NN].phase->PAR[16]
                *sqrt(1.0+TANTH*TANTH);
        BB = pow(( pow(refs[NN].HALFG,5.0) + 2.69269*
                   pow(refs[NN].HALFG,4.0) * refs[NN].HALFL+ 2.42843*
                   pow(refs[NN].HALFG,3.0) *
                   pow(refs[NN].HALFL,2.0)+4.47163*
                   pow(refs[NN].HALFG,2.0)*
                   pow(refs[NN].HALFL,3.0) + 0.07842*refs[NN].HALFG*
                   pow(refs[NN].HALFL,4.0) + pow(refs[NN].HALFL,5.0)) ,0.2);
        TLR = refs[NN].HALFL/BB;
        refs[NN].GAM = 1.36603*TLR-0.47719*TLR*TLR+0.11116* pow(TLR,3.0);
    }
    else
    {
        BB = refs[NN].HALFG;
    }


    prfx.TL=BB;
    refs[NN].refs[1]=BB;
    BB=BB*BB;

    //-----VERT=.TRUE. IF ASYMMETRY CORRECTION IS TO BE CALCULATED
    VERT=false;
    if (iasym == 0)
    {
        if (refs[NN].refs[2] <= RLIM && nprof != 5)VERT=true;
    }
    else
    {
        if (abs(refs[NN].refs[2]-90.0) >= RLIM) VERT=true;
    }



    // Calculation of cos(h.x),sin(h.x) and temp. factor for each atom

    for(I=1; I <= N; I++)
    {
        SNXI=0.0;
        atoms[I].SA = 0.0;
        //SBI=0.0;
        for(J=1; J <= 11; J++) XI[J]=atoms[I+IOF].AtomPAR[J];
        for(IR=1; IR <= IRL; IR++)
        {
            for(J=1; J <= 3; J++)
            {
                IV=rtmtx.IVEC[refs[NN].iphase][IR]/32768/pow(32,(3-J));
                IV=MOD(IV,32);
                SM[J][1]=IV/9-1;
                SM[J][2]=MOD(IV/3,3)-1;
                SM[J][3]=MOD(IV,3)-1;
                T[J]=double(MOD(rtmtx.IVEC[refs[NN].iphase][IR]/pow(32,(3-J)),32)-16)/12.0;
            }



            X=T[1]*refs[NN].h+T[2]*refs[NN].k+T[3]*refs[NN].l;
            H[1]=SM[1][1]*refs[NN].h+SM[2][1]*refs[NN].k+SM[3][1]*refs[NN].l;
            H[2]=SM[1][2]*refs[NN].h+SM[2][2]*refs[NN].k+SM[3][2]*refs[NN].l;
            H[3]=SM[1][3]*refs[NN].h+SM[2][3]*refs[NN].k+SM[3][3]*refs[NN].l;

            TR=X;

            ARG = 6.28318530718*(TR + H[1]*XI[1]+H[2]*XI[2]+H[3]*XI[3]);
            ARG2=H[1]*H[1]*XI[6]+H[2]*H[2]*XI[7]+H[3]*H[3]*XI[8]+2.0*H[1]*H[2]*XI[9]+2.0*H[1]*H[3]*XI[10]+2.0*H[2]*H[3]*XI[11];

            EXPARG=exp(-ARG2);
            COSA=cos(ARG)*EXPARG;
            SINA=sin(ARG)*EXPARG;

            atoms[I].SA += COSA;
            if (ICENT == 1) atoms[I].SB += SINA;
            for(JJ=1; JJ <= 3; JJ++)
            {
                atoms[I].SUMAX[JJ] += H[JJ]*SINA;
                if (ICENT == 1) atoms[I].SUMBX[JJ] += H[JJ]*COSA;
            }
            atoms[I].SUMAX[4] += H[1]*H[1]*COSA;
            atoms[I].SUMAX[5] += H[2]*H[2]*COSA;
            atoms[I].SUMAX[6] += H[3]*H[3]*COSA;
            atoms[I].SUMAX[7] += H[1]*H[2]*COSA;
            atoms[I].SUMAX[8] += H[1]*H[3]*COSA;
            atoms[I].SUMAX[9] += H[2]*H[3]*COSA;
            if (ICENT == 1)
            {
                atoms[I].SUMBX[4] += H[1]*H[1]*SINA;
                atoms[I].SUMBX[5] += H[2]*H[2]*SINA;
                atoms[I].SUMBX[6] += H[3]*H[3]*SINA;
                atoms[I].SUMBX[7] += H[1]*H[2]*SINA;
                atoms[I].SUMBX[8] += H[1]*H[3]*SINA;
                atoms[I].SUMBX[9] += H[2]*H[3]*SINA;
            }
        }
        atoms[I].TEMP=exp(-atoms[I+IOF].AtomPAR[4]*SSNN);
        //atoms[I].SA=SAI;
        //atoms[I].SB=SBI;
        NI=atoms[I+IOF].PTR;
        BNI=DFPP[NI];
        FFX=DFP[NI];
        AC_[10][NI]=0.0;
        for(II=1; II <= 9; II+=2) FFX=FFX+AC_[II][NI]*exp(-AC_[II+1][NI]*SSNN);
        SNEXI=FFX*atoms[I+IOF].AtomPAR[5]*atoms[I].TEMP;
        SNXI=BNI*atoms[I+IOF].AtomPAR[5]*atoms[I].TEMP;

        //-----CALCULATE A AND B OF F
        AV += SNEXI*atoms[I].SA;
        BV += SNEXI*atoms[I].SB;
        atoms[I].SNEX=2.0*SNEXI*TAV*RATIO[refs[NN].lambda];
        atoms[I].SNX=2.0*SNXI*TAV*RATIO[refs[NN].lambda];
        CV += SNXI*atoms[I].SA;
        DV += SNXI*atoms[I].SB;
    }

    refs[NN].FMGNTD=RATIO[refs[NN].lambda]*(CV*CV+AV*AV+DV*DV+BV*BV)*TAV*SR;

    // PREPARING PHASE and struc fact TO BE PRINTED
    refs[NN].TAVIX=TAV;
    refs[NN].SRIX=SR;
    if (AV == 0) AV=1e-6;
    refs[NN].APHASE=atan(BV/AV);
    if (AV < 0 && BV > 0) refs[NN].APHASE =refs[NN].APHASE + M_PI;
    if (AV < 0 && BV < 0) refs[NN].APHASE =refs[NN].APHASE + M_PI;
    if (AV < 0 && BV == 0)refs[NN].APHASE = -M_PI;
    if (AV > 0 && BV == 0)refs[NN].APHASE = 0.00;
    if (BV < 0 && AV == 0)refs[NN].APHASE = M_PI_2_3;
    if (BV > 0 && AV == 0)refs[NN].APHASE = M_PI_2;

    //-----CALCULATE DERIVATIVES
    if (MAXS != 0)
    {
        for(I=1; I <= N; I++)
        {
            SNEXI=atoms[I].SNEX;
            SNXI=atoms[I].SNX;
            //SAI=atoms[I].SA;
            //SBI=atoms[I].SB;
            for(J=1; J <= 11; J++)
            {
                K=atoms[I+IOF].AtomPAR[J].codeword.L;
                if (K != 0)
                {
                    if (J > 5)
                    {
                        SUMA=atoms[I].SUMAX[J-2];
                        SUMB=atoms[I].SUMBX[J-2];
                        DER=-((AV*SUMA+BV*SUMB)*SNEXI+(CV*SUMA+DV*SUMB)*SNXI);
                        if (J >= 9) DER=2.0*DER;
                    }
                    else if (J > 3)
                    {
                        if (J > 4)
                        {
                            DER=((atoms[I].SA*AV+atoms[I].SB*BV)*SNEXI+(atoms[I].SA*CV+atoms[I].SB*DV)*SNXI)/atoms[I+IOF].AtomPAR[5];
                        }
                        else
                        {
                            DER=-((atoms[I].SA*AV+atoms[I].SB*BV)*SNEXI+(atoms[I].SA*CV+atoms[I].SB*DV)*SNXI)*SSNN;
                        }
                    }
                    else
                    {
                        SUMA=atoms[I].SUMAX[J];
                        SUMB=atoms[I].SUMBX[J];
                        DER=-((AV*SUMA-BV*SUMB)*SNEXI+(CV*SUMA-DV*SUMB)*SNXI)*6.2831853071;
                    }
                    DERIV[K] = SIGN(1.0,atoms[I+IOF].AtomPAR[J].codeword)*DER+DERIV[K];
                }

            }
        }
        //-----CALCULATE DERIVATIVES
        //-----Preferred Orientation Derivatives
        K = refs[NN].phase->PAR[12].codeword.L;
        if ( K != 0 )
        {
            DERIV[K] += refs[NN].FMGNTD *DPRECOR;
            //         print '(3x,i3,3f10.5)',k,fnn,dprecor,deriv(k)         ! ********
        }
        K = refs[NN].phase->PAR[13].codeword.L;
        if (ipref == 0)
        {
            if (K != 0) DERIV[K]=DERIV[K]+(1.0-PREXP)* refs[NN].FMGNTD /PRECOR;
        }
        else
        {
            if (K != 0)
            {
                file6 << "G2 IS NOT A REFINABLE PARAMETER FOR IPREF = 1" << endl;
                exit(EXIT_FAILURE);
            }
        }
        //-----Derivatives for microabsorption parameter
        if (iabsr == 1)
        {
            K = GLB[13].codeword.L;
            if (K != 0)
            {
                SRD = (1.0-GLB[12])*(asin(sqrt(SINTH))-M_PI_2);
                DERIV[K] += SRD* refs[NN].FMGNTD /SR;
            }

            K = GLB[12].codeword.L;
            if (K != 0)
            {
                SRD = 1.0 -GLB[8]*exp(-GLB[9])+GLB[8]*exp(-GLB[9]/sqrt(SINTH))-1.0-GLB[13]*(asin(sqrt(SINTH))-M_PI_2);
                DERIV[K] += SRD* refs[NN].FMGNTD /SR;
            }

            K = GLB[9].codeword.L;
            if (K != 0)
            {
                SRD = GLB[8]*GLB[12]*(exp(-GLB[9])-exp(-GLB[9]/sqrt(SINTH))/sqrt(SINTH));
                DERIV[K] += SRD* refs[NN].FMGNTD /SR;
            }

            K = GLB[8].codeword.L;
            if (K != 0)
            {
                SRD = -GLB[12]*(exp(-GLB[9])+exp(-GLB[9]/sqrt(SINTH)));
                DERIV[K] += SRD* refs[NN].FMGNTD /SR;
            }
        }
        else if (iabsr == 2)
        {
            KKL = GLB[12].codeword.L;
            K  = GLB[9].codeword.L;
            KL = GLB[8].codeword.L;
            if (K != 0 || KL != 0 || KKL != 0)
            {
                file6 << "P AND/OR Q AND/OR R ARE NOT REFINABLE PARAMETERS FOR IABSR=2" << endl;
                cout << "P AND/OR Q AND/OR R ARE NOT REFINABLE PARAMETERS FOR IABSR=2" << endl;
                exit(EXIT_FAILURE);
            }
            K = GLB[13].codeword.L;
            SRD = M_PI_2 - asin(sqrt(SINTH));
            if (K != 0) DERIV[K] += SRD* refs[NN].FMGNTD /SR;
        }
        else if (iabsr == 3)
        {
            KKL = GLB[13].codeword.L;
            K = GLB[12].codeword.L;
            if (K != 0 || KKL != 0)
            {
                file6 << "R AND/OR T IS NOT A REFINABLE PARAMETER FOR THE IABSR CHOICE" << endl;
                cout << "R AND/OR T IS NOT A REFINABLE PARAMETER FOR THE IABSR CHOICE" << endl;
                exit(EXIT_FAILURE);
            }
            K = GLB[9].codeword.L;
            SRD = GLB[8]*exp(-GLB[9])-GLB[8]*ISITH*exp(-GLB[9]*ISITH);
            if (K != 0) DERIV[K] += SRD* refs[NN].FMGNTD ;
            K = GLB[8].codeword.L;
            SRD = -exp(-GLB[9])+exp(-GLB[9]*ISITH);
            if (K != 0) DERIV[K] += SRD* refs[NN].FMGNTD ;
        }
        else if (iabsr == 4)
        {
            KKL = GLB[13].codeword.L;
            K = GLB[12].codeword.L;
            if (K != 0 || KKL != 0)
            {
                file6 << "R AND/OR T IS NOT A REFINABLE PARAMETER FOR THE IABSR CHOICE" << endl;
                cout << "R AND/OR T IS NOT A REFINABLE PARAMETER FOR THE IABSR CHOICE" << endl;
                exit(EXIT_FAILURE);
            }
            K = GLB[9].codeword.L;
            SRD = GLB[8]*(2*GLB[9]-1)+GLB[8]*ISITH*(2*GLB[9]*ISITH-1);
            if (K != 0) DERIV[K] += SRD* refs[NN].FMGNTD /SR;
            K = GLB[8].codeword.L;
            SRD = GLB[9]*(GLB[9]-1)-GLB[9]*ISITH*(1-GLB[9]*ISITH);
            if (K != 0) DERIV[K] += SRD* refs[NN].FMGNTD /SR;
        }
        //----Overall Temperature and Scale Factor
        K=refs[NN].phase->PAR[2].codeword.L;
        if (K != 0) DERIV[K]=DERIV[K]-2.0*SSNN* refs[NN].FMGNTD ;
        K=refs[NN].phase->PAR[1].codeword.L;
        if (K != 0) DERIV[K]=DERIV[K]+ refs[NN].FMGNTD /refs[NN].phase->PAR[1];
        SINTH = 2 * radtodeg(  refs[NN].FMGNTD *SLABDA/(sqrt(SINTH*COSTH)*BB) );
        SS= refs[NN].FMGNTD /prfx.TL;
        X=TANTH*TANTH;
        //-----Broadening Derivatives
        if (nprof != 5 && nprof != 8)
        {
            for(J=3; J <= 5; J++)
            {
                K=refs[NN].phase->PAR[J].codeword.L;
                if (K != 0)
                {
                    DERIV[K]=X*SS+DERIV[K];
                }
                X=X/TANTH;
            }
            K=refs[NN].phase->PAR[21].codeword.L;
            if (K != 0)
            {
                //C for cot^2 case
                DERIV[K]=SS/(TANTH*TANTH)+DERIV[K];
            }
        }

        //-----Split Pearson VII Broadening Derivatives
        if (nprof == 5)
        {
            if (prfx.DELTA < 0.0)
            {
                DA3 = spvii.DA3L;
                DA1 = spvii.DA1L;
            }
            else
            {
                DA3 = spvii.DA3H;
                DA1 = spvii.DA1H;
            }
            for(J=3; J <= 5; J++)
            {
                K=refs[NN].phase->PAR[J].codeword.L;
                if (K != 0)
                {
                    DERIV[K]=DERIV[K]+X*SS*((DA3*prfx.DELT/(1.0+DA1*prfx.DELT))-(1.0/prfx.TL));
                }
                X=X/TANTH;
            }
        }

        //-----TCHZ Broadening Derivatives
        if (nprof == 8)
        {
            prfx.TL = refs[NN].refs[1];
            TLG = refs[NN].HALFG;
            TLL = refs[NN].HALFL;
            DHDHG = 0.2/pow(prfx.TL,4.0)*(5.0*pow(TLG,4.0)+10.77076*pow(TLG,3.0)*TLL+
                                          7.28529*TLG*TLG*TLL*TLL+8.94326*TLG*pow(TLL,3.0) + 0.07842*pow(TLL,4.0));
            DHDHL = 0.2/pow(prfx.TL,4.0)*(2.69269*pow(TLG,4.0)+ 4.85686*pow(TLG,3.0)*TLL
                                          +13.41489*TLG*TLG*TLL*TLL + 0.31368*TLG*pow(TLL,3.0)+5.0*pow(TLL,4.0));
            for(J=3; J <= 5; J++)
            {
                K=refs[NN].phase->PAR[J].codeword.L;
                if (K != 0)
                {
                    DERIV[K]=DHDHG*X*SS+DERIV[K];
                }
                X=X/TANTH;
            }
            K=refs[NN].phase->PAR[20].codeword.L;
            if  (K != 0) DERIV[K]=DHDHG*SS/COSTH+DERIV[K];
            K = refs[NN].phase->PAR[15].codeword.L;
            if (K != 0)
            {
                DERIV[K] = 2.0* refs[NN].FMGNTD *DHDHL*TANTH+DERIV[K];
            }
            K = refs[NN].phase->PAR[16].codeword.L;
            if (K != 0)
            {
                DERIV[K] = 2.0* refs[NN].FMGNTD *DHDHL/sqrt(COSTH) + DERIV[K];
            }
        }

        //-----Profile Shape Derivatives
        K = refs[NN].phase->PAR[17].codeword.L;
        if (K != 0 && (nprof == 6 || nprof == 7)) DERIV[K]=DERIV[K]+  refs[NN].FMGNTD ;

        K = refs[NN].phase->PAR[18].codeword.L;
        if (K != 0 && nprof == 6) DERIV[K]=DERIV[K]+  refs[NN].FMGNTD  * refs[NN].refs[2];
        if (K != 0 && nprof == 7) DERIV[K]=DERIV[K]+  refs[NN].FMGNTD  / refs[NN].refs[2];

        K = refs[NN].phase->PAR[19].codeword.L;
        if (K != 0 && nprof == 7) DERIV[K]=DERIV[K]+ refs[NN].FMGNTD /refs[NN].refs[2]/refs[NN].refs[2];

        //-----Split Pearson VII Shape Derivative
        if (nprof == 5)
        {
            K = refs[NN].phase->PAR[17].codeword.L;
            if (K != 0.0)
            {
                if (prfx.DELTA < 0.0)
                {
                    DERIV[K] +=  refs[NN].FMGNTD *(-log(1.0+spvii.DA1L*prfx.DELT/BB)+spvii.DA7L*prfx.DELT/BB/(1.0+spvii.DA1L*prfx.DELT/BB));
                }
                else
                {
                    DERIV[K] +=  refs[NN].FMGNTD *spvii.DA6L;
                }
            }
            K = refs[NN].phase->PAR[18].codeword.L;
            if (K != 0.0)
            {
                if (prfx.DELTA < 0.0)
                {
                    DERIV[K] +=  refs[NN].FMGNTD *(-log(1.0+spvii.DA1L*prfx.DELT/BB)+spvii.DA7L*prfx.DELT/BB/(1.0+spvii.DA1L*prfx.DELT/BB))/refs[NN].refs[2];
                }
                else
                {
                    DERIV[K] +=  refs[NN].FMGNTD *spvii.DA6L/refs[NN].refs[2];
                }
            }
            K = refs[NN].phase->PAR[19].codeword.L;
            if (K != 0.0)
            {
                if (prfx.DELTA < 0.0)
                {
                    DERIV[K] +=  refs[NN].FMGNTD *(-log(1.0+spvii.DA1L*prfx.DELT/BB)+spvii.DA7L*prfx.DELT/BB/(1.0+spvii.DA1L*prfx.DELT/BB))/refs[NN].refs[2]/refs[NN].refs[2];
                }
                else
                {
                    DERIV[K] +=  refs[NN].FMGNTD *spvii.DA6L/refs[NN].refs[2]/refs[NN].refs[2];
                }
            }
            K = refs[NN].phase->PAR[24].codeword.L;
            if (K != 0.0)
            {
                if (prfx.DELTA < 0.0)
                {
                    DERIV[K] +=  refs[NN].FMGNTD *spvii.DA6H;
                }
                else
                {
                    DERIV[K] +=  refs[NN].FMGNTD *(-log(1.0+spvii.DA1H*prfx.DELT/BB)+spvii.DA7H*prfx.DELT/BB/(1.0+spvii.DA1H*prfx.DELT/BB));
                }
            }
            K = refs[NN].phase->PAR[25].codeword.L;
            if (K != 0.0)
            {
                if (prfx.DELTA < 0.0)
                {
                    DERIV[K] +=  refs[NN].FMGNTD *spvii.DA6H/refs[NN].refs[2];
                }
                else
                {
                    DERIV[K] +=  refs[NN].FMGNTD *(-log(1.0+spvii.DA1H*prfx.DELT/BB)+spvii.DA7H*prfx.DELT/BB/(1.0+spvii.DA1H*prfx.DELT/BB))/refs[NN].refs[2];
                }
            }
            K = refs[NN].phase->PAR[26].codeword.L;
            if (K != 0.0)
            {
                if (prfx.DELTA < 0.0)
                {
                    DERIV[K] +=  refs[NN].FMGNTD *spvii.DA6H/refs[NN].refs[2]/refs[NN].refs[2];
                }
                else
                {
                    DERIV[K] +=  refs[NN].FMGNTD *(-log(1.0+spvii.DA1H*prfx.DELT/BB)+spvii.DA7H*prfx.DELT/BB/(1.0+spvii.DA1H*prfx.DELT/BB))/refs[NN].refs[2]/refs[NN].refs[2];
                }
            }
        }

        //-----Split Pearson VII Asymmetry Derivative
        K = refs[NN].phase->PAR[27].codeword.L;
        if (prfx.DELTA < 0.0)
        {
            DA1 = spvii.DA1L;
            DA4 = spvii.DA4L;
            DA5 = spvii.DA5L;
        }
        else
        {
            DA1 = spvii.DA1H;
            DA4 = spvii.DA4H;
            DA5 = spvii.DA5H;
        }
        if (K != 0 && nprof == 5)
        {
            DERIV[K]=DERIV[K]+ refs[NN].FMGNTD *(DA4+DA5*prfx.DELT/BB/(1.0+DA1*prfx.DELT/BB));
        }

        //-----Zero, Displacement, and Transparancy Derivatives
        K=GLB[1].codeword.L;
        if (K != 0) DERIV[K]=DERIV[K]+2.0* refs[NN].FMGNTD /BB;

        K=GLB[10].codeword.L;
        if (K != 0) DERIV[K]=DERIV[K]+2.0* refs[NN].FMGNTD /BB*sqrt(COSTH);

        K=GLB[11].codeword.L;
        if (K != 0) DERIV[K]=DERIV[K]+2.0* refs[NN].FMGNTD /BB*sin(refs[NN].refs[2]/57.2958);



        //-----Lattice Parameter Derivatives

        K=refs[NN].phase->PAR[6].codeword.L;
        if (K != 0)
        {
            DERIV[K] += refs[NN].h*refs[NN].h*SINTH;
        }

        K=refs[NN].phase->PAR[7].codeword.L;
        if (K != 0)
        {
            DERIV[K] += refs[NN].k*refs[NN].k*SINTH;
        }

        K=refs[NN].phase->PAR[8].codeword.L;
        if (K != 0)
        {
            DERIV[K] += refs[NN].l*refs[NN].l*SINTH;
        }

        K=refs[NN].phase->PAR[9].codeword.L;
        if (K != 0)
        {
            DERIV[K] += refs[NN].k*refs[NN].l*SINTH;
        }

        K=refs[NN].phase->PAR[10].codeword.L;
        if (K != 0)
        {
            DERIV[K] += refs[NN].h*refs[NN].l*SINTH;
        }

        K=refs[NN].phase->PAR[11].codeword.L;
        if (K != 0)
        {
            DERIV[K] += refs[NN].h*refs[NN].k*SINTH;
        }

        //-Asymmetry Derivative.  Test for asymmetry model included
        K=refs[NN].phase->PAR[14].codeword.L;
        if ((K != 0) && VERT)
        {
            if (iasym == 0)
            {
                DERIV[K]=- refs[NN].FMGNTD /TANTH+DERIV[K];
            }
            else
            {
                TANTHE=TANTH;
                if (TANTHE >= 1.0) TANTHE=tan(atan( TANTHE - M_PI_2 ));
                DERIV[K]=- refs[NN].FMGNTD /TANTH+DERIV[K];
            }
        }

        //-----STORE DERIVATIVES FOR LIMO REFLECTIONS AT A TIME
        for(I=1; I <= MAXS; I++) g4.DERSTO[NM][I]=DERIV[I];
    }


}

double DBWS::GAMMA(double X)
{
    int I,IN;
    double GG,GX,DU1, DU2, DU4,ret_val;

    if (X - 1.0 >= 0.0) {
        if (X - 2.0 <= 0.0) {
            GX = X;
            goto L21;
        } else {
            if (X - 8.0 <= 0.0) {
                for (I = 1; I <= 8; ++I)
                {
                    IN = I;
                    GX = X - (double) I;
                    if (GX >= 1.0 && GX <= 2.0) break;
                }
                goto L21;
            } else {
                cout << "X IN GAMMA(X) IS GREATER THAN 8.0   X =" << setw(8) << setprecision(4) << X << endl;
                ret_val = 5040.0;
                goto L99;
            }
        }
    } else {
        if (X - 0.1 >= 0.0) {
            GX = X + 1.0;
            goto L21;
        } else {
            cout << "X IN GAMMA(X) IS LESS THAN 0.1   X =" << setw(8) << setprecision(4) << X << endl;
            ret_val = 9.513508;
            goto L99;
        }
    }


L21:
    DU1 = GX - 1.0;
    DU2 = DU1 * DU1;
    DU4 = DU2 * DU2;
    GG = 1.0-0.5771917*DU1+0.9882059*DU2-0.8970569*DU1*DU2+0.9182069*DU4-0.7567041*DU4*DU1+0.4821994*DU4*DU2-0.1935278*DU1*DU2*DU4+0.0358683*DU4*DU4;
    if (X - 1.0 >= 0.0) {
        if (X - 2.0 <= 0.0) {
            ret_val = GG;
        } else {
            ret_val = X - 1.0;
            if (IN - 1 <= 0) {
                ret_val *= GG;
            } else {
                for (I = 2; I <= IN; ++I) {
                    ret_val *= X - (double) I;
                }
                ret_val *= GG;
            }
        }
    } else {
        ret_val = GG / X;
    }
    goto L99;


L99:
    return ret_val;
}

void DBWS::PRSVII(double T)
{
//    CALCULATES THE COEFFICIENT C4 AND ITS DERIVATIVE WRT T FOR PHASE K
//    THIS SUBROUTINE OBTAINED FROM IMMIRZI'S CODE
//    RGD = GAMMA(T)/GAMMA(T-0.5)
//    DGD = D(RGD)/D(T)

    double RGD[52+1] = {0.0, 0.156535,0.183771,0.209926,0.235089,0.259339,0.282749,0.30538,
                       0.327289,0.348527,0.369141,0.38917,
                       0.408654,0.427625,0.446115,0.464153,
                       0.481764,0.498972,0.515799,0.532265,
                       0.54839,0.56419,0.57968,0.594877,0.609794,
                       0.624443,0.638837,0.652986,0.666902,
                       0.680594,0.694071,0.707342,0.720415,
                       0.733297,0.754996,0.758519,0.770871,
                       0.783059,0.795089,0.806966,0.818696,
                       0.830282,0.841731,0.853045,0.86423,0.87529,
                       0.886227,0.897046,0.90775,0.918344,
                       0.928828,0.939207,0.949484
                      };

    double DGD[52+1] = {0.0, 1.390576,1.334036,1.282282,1.234747,1.190975,1.150537,1.113079,
                       1.078304,1.04595,1.015831,0.987556,
                       0.961144,0.936314,0.913013,0.891052,
                       0.870228,0.850726,0.832193,0.814684,
                       0.798032,0.782274,0.767112,0.752807,
                       0.739098,0.726022,0.713542,0.701621,
                       0.69011,0.679232,0.66869,0.658669,0.648871,
                       0.639521,0.63058,0.621825,0.613555,
                       0.605434,0.59776,0.590086,0.582896,
                       0.575967,0.569075,0.562482,0.555962,
                       0.54989,0.543743,0.538044,0.532381,
                       0.526905,0.521578,0.5164,0.511296
                      };


    int I, N1,IT;
    double DG, RG, FT,FL1;

    if (T < 0.6)
    {
        file6 << endl << endl
              << "UNACCEPTABLE M VALUE IN CALCULATING PEARSON VII FUNCTION " << setw(6) << setprecision(2) << T << endl << endl;
        exit(EXIT_FAILURE);
    }
    IT=IFIX(T-0.6);
    FT=T-double(IT);
    N1=(FT-0.6)/0.02+1.0001;
    DG=DGD[N1]+(DGD[N1+1]-DGD[N1])*(FT-0.58-0.02*double(N1))/0.02;
    RG=RGD[N1]+(RGD[N1+1]-RGD[N1])*(FT-0.58-0.02*double(N1))/0.02;
    if (IT > 0)
    {
        for(I=1; I <= IT; I++)
        {
            FL1=FT+double(I-1);
            DG=DG*(FL1)/(FL1-0.5)-0.5*RG/pow((FL1-0.5),2);
            RG=RG*FL1/(FL1-0.5);
        }
    }
    pvii.TF1=sqrt( pow(2.0,(1.0/T))-1.0);
    pvii.C4=2.0*RG*pvii.TF1 / sqrt(M_PI);
    pvii.TF2= M_LN2l * pow(2.0,(1.0/T))/(2.0*pow(pvii.TF1,2));
    //     DC4DT= 2./SQRT(PIG)*(TF1*DG - RG*TF2/T**2)
    pvii.TF4=4.0* M_LN2l *pow(2.0,(1.0/T))/T;
    pvii.TF6=4.0*T*pow(pvii.TF1,2);
    pvii.TF8=DG/RG-pvii.TF2/pow(T,2);
    pvii.TF9=4.0*pow(pvii.TF1,2);
    //     TF3=360.0*TF6/PIG
}

void DBWS::MSPVII(double A, double W)
{
    //    Split Pearson VII coding for function and derivatives
    //    Based on Toraya's Code from Profit, Ver 1.22N
    double DH, DL, DHD, DLD;

    DL = GAMMA(spvii.RL-0.5)/(sqrt( pow(2.0,(1.0/spvii.RL)) -1.0)*GAMMA(spvii.RL));
    DH = GAMMA(spvii.RH-0.5)/(sqrt( pow(2.0,(1.0/spvii.RH))-1.0)*GAMMA(spvii.RH));
    DLD = GAMMA(spvii.RL-0.5+0.001)/(sqrt( pow(2.0,(1.0/(spvii.RL+0.001))) -1.0)*GAMMA(spvii.RL+0.001));
    DHD = GAMMA(spvii.RH-0.5+0.001)/(sqrt( pow(2.0,(1.0/(spvii.RH+0.001))) -1.0)*GAMMA(spvii.RH+0.001));
    spvii.DA1L = ( pow( ((1.0+A)/A),2.0) )*(  pow(2.0,(1.0/spvii.RL)) -1.0);
    spvii.DA1H = ( pow((1.0+A),2.0) )*( pow(2.0,(1/spvii.RH)) -1.0);
    spvii.DA2L = M_2_SQRTPI*(1.0+A)*(1.0/(A*DL+DH))/W;
    spvii.DA2H = spvii.DA2L;
    spvii.DA3L = 2.0*spvii.RL*spvii.DA1L/W;
    spvii.DA3H = 2.0*spvii.RH*spvii.DA1H/W;
    spvii.DA4L = (1.0/(1.0+A))-(DL/(A*DL+DH));
    spvii.DA4H =spvii. DA4L;
    spvii.DA5L = 2.0*spvii.RL* pow(((1+A)/A),2.0) *(1.0+A)/(pow(A,3));
    spvii.DA5H = -2.0*spvii.RH* pow((1+A),2.0) *(1+A);
    spvii.DA6L = -A*1000.0*(DLD-DL)/(A*DL+DH);
    spvii.DA6H = -1000.0*(DHD-DH)/(A*DL+DH);
    spvii.DA7L = log(2.0)* pow(((1.0+A)/A),2.0) *( pow(2.0,(1.0/spvii.RL)) -1.0+1.0)/spvii.RL;
    spvii.DA7H = log(2.0)* pow((1.0+A),2.0) *( pow(2.0,(1.0/spvii.RH))-1.0+1.0)/spvii.RH;
}

double DBWS::PROFIL(int N, double X)
{
    double value = 0.0;


    switch (N) {
    case 1:
        /*
         *  Gaussian function.
         *
         *  As constantes C0 e C0_1 são tais que a integral da função seja normalizada, igual  a 1.
         *
         *  F() = (√C0/ (Hk * √π)) exp( -C0( 2Θi - 2Θk )²/ (Hk)² )
         *
         *  C0   = 4*ln(2)
         *
         *  C0_1 =  sqrt(C0/π)
         *
         */
        value = C0_1 * exp(- C0 *X);
        prfx.PRFDER =C0;
        return value;
    case 2:
        value=M_2_PI/(1.0+4.0*X);
        prfx.PRFDER=4.0/(1.0+4.0*X);
        return value;
    case 3:
        value=0.819449653/pow((1.0+1.0656854248*X),2.0);
        prfx.PRFDER=3.313708496/(1.0+_4_SQRT2_1*X);
        return value;
    case 4:
        value=0.766420937/ pow((1.0+2.349604208*X),1.5);
        prfx.PRFDER=3.5244063/(1.0+2.349604208*X);
        return value;
    case 5:
        if (prfx.DELTA < 0.0)
        {
            value = pow((1.0+spvii.DA1L*X),(-spvii.RL))*spvii.DA2L;
            prfx.PRFDER = spvii.DA1L*spvii.RL/(1.0+spvii.DA1L*X);
        }
        else
        {
            value = pow((1.0+spvii.DA1H*X),(-spvii.RH))*spvii.DA2H;
            prfx.PRFDER = spvii.DA1H*spvii.RH/(1.0+spvii.DA1H*X);
        }
        return value;
    case 6:
        value=prfx.GAM1*M_2_PI/(1.0+4.0*X)+(1-prfx.GAM1)*0.939437279*exp(-C0*X);
        prfx.PRFDER=(prfx.GAM1*2.546479088/pow((1.0+4.0*X),2) +(1-prfx.GAM1)*2.6046732048*exp(-C0*X))/value;
        return value;
    case 7:
        value=pvii.C4/pow((1.0+4.0*(pow(2,(1.0/prfx.GAM1))-1)*X),prfx.GAM1);
        prfx.PRFDER=pvii.TF6*prfx.GAM1/(1.0+4.0*( pow(2,(1.0/prfx.GAM1))-1)*X);
        return value;
    case 8:
        value=prfx.GAM1*M_2_PI/(1.0+4.0*X)+(1-prfx.GAM1)*0.939437279*exp(-C0*X);
        prfx.PRFDER=(prfx.GAM1*2.546479088/pow((1.0+4.0*X),2)+(1-prfx.GAM1)*2.6046732048*exp(-C0*X))/value;
        return value;
    }
    cout << "ILLEGAL PROFILE FUNCTION REQUEST" << endl;
    exit(EXIT_FAILURE);


}

void DBWS::SUMMAT(int IPM,double CSK[], double DISK[], double DYCDD[],double TOTCS)
{
    int I, J, K, M,II, IL, KK, LK, KM,LK1, LK2,IOF, IISO,LAMBDAM;
    double X, Z, X1, BB,YX,DER, TLL, TLR,ASS5,ESSE,OMEGA, YCALC, DERIV[MSZ+1], TANNJ, SHIFT, TANTH, OMEGA8, DERMON,PRTEMP;
    bool VERT;


    for(J=1; J <= MSZ; J++) DERIV[J]=0.0;
    YCALC=0.0;
    IL=0;
    //-----CALCULATE THE CONTRIBUTION OF THE REFLECTIONS ORD1 TO ORD2 TO THE
    //-----DERIVATIVES W.R.T. THE PROFILE INTENSITY YOBS
    if (g3.IORD1 == 0) goto L12;
    for(I=g3.IORD1; I <= g3.IORD2; I++)
    {
        //prfx.IPH_=refs[I].iphase;
        IL=IL+1;
        J=MOD(I,NOV)+1;
        // test for asymmetry function
        if (iasym == 0)
        {
            VERT = refs[I].refs[2] <= RLIM;
        }
        else
        {
            VERT = abs(refs[I].refs[2]-90.0 ) >= RLIM;
        }
        SHIFT = GLB[10] * cos(refs[I].refs[2]/2./57.2958) + GLB[11] * sin(refs[I].refs[2]/57.2958);
        prfx.DELTA=g3.TH- refs[I].refs[2] -GLB[1]-SHIFT;
        TANTH = tan( degtorad( 2.0 * g3.TH ) );
        prfx.DELT=prfx.DELTA*prfx.DELTA;
        prfx.TL=refs[I].refs[1];
        if (nprof == 6) prfx.GAM1 = refs[I].phase->PAR[17] + refs[I].phase->PAR[18] * refs[I].refs[2];
        if (nprof == 7) prfx.GAM1 = refs[I].phase->PAR[17] + refs[I].phase->PAR[18] / refs[I].refs[2] + refs[I].phase->PAR[19]/refs[I].refs[2]/refs[I].refs[2];
        if (nprof == 7) PRSVII(prfx.GAM1);
        if (nprof == 5)
        {
            spvii.RL=refs[I].phase->PAR[17]+(refs[I].phase->PAR[18]+refs[I].phase->PAR[19]/refs[I].refs[2])/refs[I].refs[2];
            spvii.RH=refs[I].phase->PAR[24]+(refs[I].phase->PAR[25]+refs[I].phase->PAR[26]/refs[I].refs[2])/refs[I].refs[2];
            MSPVII(refs[I].phase->PAR[27],prfx.TL);
        }
        if (nprof == 8)
        {
            TLL = refs[I].HALFL;
            prfx.GAM1 = refs[I].GAM;
            TLR = TLL/prfx.TL;
        }
        BB= prfx.TL* prfx.TL;
        //-----NEXT LINE IS NECESSEARY FOR 2 PHASES WITH VERY DIFFERENT FWHM.
        if (prfx.DELT/BB <= WDT*WDT)
        {
            if (VERT)
            {
                //       test for asymmetry model
                if (iasym == 0)
                {
                    YX=prfx.DELT*SIGN(1.0,prfx.DELTA);
                    Z=1.0-refs[I].phase->PAR[14]*YX/g4.TANN[J];
                    if ( Z <= 0.0 ) Z=0.0001;
                }
                else
                {
                    YX=SIGN(1.0,prfx.DELTA)*prfx.DELTA/(2*prfx.TL);
                    TANNJ=g4.TANN[J];
                    if (TANNJ >= 1.0)
                    {
                        TANNJ= tan( atan(TANNJ)- M_PI_2 );
                    }
                    Z=(refs[I].phase->PAR[14]/TANNJ) * (2.0*(prfx.DELTA/(2*prfx.TL))*exp(-YX));
                    Z=1+Z;
                    if ( Z <= 0.0 ) Z=.0001;
                }
            }
            else
            {
                Z=1.0;
            }
            PRTEMP = PROFIL(nprof,prfx.DELT/BB);
            if (nprof == 5)
            {
                OMEGA = refs[I].refs[3]*Z*PRTEMP*refs[I].phase->PAR[1];
            }
            else
            {
                OMEGA = refs[I].refs[3]*Z*PRTEMP*refs[I].phase->PAR[1]/prfx.TL;
            }

            YCALC += OMEGA*refs[I].FMGNTD;


            if ( jobtyp <= 2 )
            {
                X = prfx.PRFDER*2.0*prfx.DELT/BB-1.0;
                for(K=1; K <= MAXS; K++)
                {
                    DER=1.0;
                    //-----Broadening Coeficients Derivatives
                    if (nprof != 5)
                    {
                        for(M=3; M <= 5; M++) if (refs[I].phase->PAR[M].codeword.L == K) DER=X/prfx.TL/2.0;
                    }
                    if (refs[I].phase->PAR[20].codeword.L == K) DER=X/prfx.TL/2.0;
                    X1=0.0;
                    //-----Asymmetry Derivative
                    if (VERT)
                    {
                        if (iasym == 0)
                        {
                            X1=refs[I].phase->PAR[14]*SIGN(1.0,prfx.DELTA)*BB/g4.TANN[J]/Z;
                        }
                        else
                        {
                            X1=-refs[I].phase->PAR[14]*exp(-YX)*(prfx.TL/(2*prfx.DELTA)-SIGN(1.0,prfx.DELTA)*1.0/4)/TANNJ/Z;
                        }
                    }
                    //-----Zero, Displacement, and Transparancy Derivative
                    if ( GLB[1].codeword.L == K ) DER=prfx.DELTA*(prfx.PRFDER+X1);
                    if ( GLB[10].codeword.L == K ) DER=prfx.DELTA*(prfx.PRFDER+X1);
                    if ( GLB[11].codeword.L == K ) DER=prfx.DELTA*(prfx.PRFDER+X1);
                    if ( (refs[I].phase->PAR[14].codeword.L == K)  &&  VERT )
                    {
                        if (iasym == 0 )
                        {
                            DER = YX/Z;
                        }
                        else
                        {
                            DER = -2.0*(prfx.DELTA/(2.0*prfx.TL))*exp(-YX)/Z;
                        }
                    }
                    if ( nprof != 8 )
                    {
                        //-----Pseudo-Voigt Shape Derivatives
                        if (nprof == 6)
                        {
                            if (K == refs[I].phase->PAR[17].codeword.L)
                            {
                                DER=(M_2_PI/(1.0+4.0*prfx.DELT/BB)-0.939437279*exp(-2.772588722*prfx.DELT/BB))/PRTEMP;
                            }
                            if (K == refs[I].phase->PAR[18].codeword.L)
                            {
                                DER=(M_2_PI/(1.0+4.0*prfx.DELT/BB)-0.939437279*exp(-2.772588722*prfx.DELT/BB))/PRTEMP;
                            }
                        }
                        //-----Pearson VII Shape Derivatives
                        if (nprof == 7)
                        {
                            if (K == refs[I].phase->PAR[17].codeword.L)
                            {
                                DER=-log(1.0+pvii.TF9*prfx.DELT/BB)+pvii.TF4*(prfx.DELT/BB)/(1.0+pvii.TF9*prfx.DELT/BB)+pvii.TF8;
                            }
                            if (K == refs[I].phase->PAR[18].codeword.L)
                            {
                                DER=-log(1.0+pvii.TF9*prfx.DELT/BB)+pvii.TF4*(prfx.DELT/BB)/(1.0+pvii.TF9*prfx.DELT/BB)+pvii.TF8;
                            }
                            if (K == refs[I].phase->PAR[19].codeword.L)
                            {
                                DER=-log(1.0+pvii.TF9*prfx.DELT/BB)+pvii.TF4*(prfx.DELT/BB)/(1.0+pvii.TF9*prfx.DELT/BB)+pvii.TF8;
                            }
                        }
                    }

                    //-----Lattice Parameter Derivatives
                    for(M=6; M <= 11; M++) if (refs[I].phase->PAR[M].codeword.L == K) DER=(prfx.PRFDER+X1)*prfx.DELTA;
                    DERIV[K]=g4.DERSTO[J][K]*DER*OMEGA+DERIV[K];
                }
                //----TCHZ Profile Derivatives
                if (nprof == 8)
                {
                    OMEGA8 = Z*refs[I].phase->PAR[1]*refs[I].refs[3]/prfx.TL;
                    for(K = 1; K <= MAXS; K++)
                    {
                        for(M=3; M <= 5; M++)
                        {
                            if (refs[I].phase->PAR[M].codeword.L == K)
                            {
                                DERIV[K] +=  OMEGA8*g4.DERSTO[J][K]/2.0* (0.939437279*exp(-2.772588722*prfx.DELT/BB) - M_2_PI/(1.0+4.0*prfx.DELT/BB)) *
                                           (1.36603*TLR/prfx.TL-0.95438*TLR*TLR/prfx.TL+0.33348*pow(TLR,3.0)/prfx.TL);
                            }
                        }
                        if (refs[I].phase->PAR[20].codeword.L == K)
                        {
                            DERIV[K] += OMEGA8*g4.DERSTO[J][K]/2.0* (0.939437279*exp(-2.772588722*prfx.DELT/BB) - M_2_PI/(1.0+4.0*prfx.DELT/BB)) * (1.36603*TLR/prfx.TL-0.95438*TLR*TLR/prfx.TL+0.33348*pow(TLR,3.0)/prfx.TL);
                        }
                        if (refs[I].phase->PAR[15].codeword.L == K)
                        {
                            DERIV[K] += DERIV[K]+ OMEGA8* (0.939437279*exp(-2.772588722*prfx.DELT/BB)-M_2_PI/(1.0+4.0*prfx.DELT/BB))*
                                        ((1.36603*TLR/prfx.TL-0.95438*TLR*TLR/prfx.TL+0.33348*pow(TLR,3.0)/prfx.TL)*g4.DERSTO[J][K]/2.0-refs[I].FMGNTD*g4.TANN[J]*(1.36603/prfx.TL-0.95438*TLR/prfx.TL+0.33348*TLR*TLR/prfx.TL));
                        }

                        if (refs[I].phase->PAR[16].codeword.L == K)
                        {
                            DERIV[K] +=  OMEGA8*(0.939437279*exp(-2.772588722*prfx.DELT/BB)-M_2_PI/(1.0+4.0*prfx.DELT/BB)) *
                                       ((1.36603*TLR/prfx.TL-0.95438*TLR*TLR/prfx.TL+0.33348*pow(TLR,3.0)/prfx.TL)* g4.DERSTO[J][K]/2.0 - refs[I].FMGNTD*
                                        sqrt(1+g4.TANN[J]*g4.TANN[J])*(1.36603/prfx.TL-0.95438*TLR/prfx.TL+0.33348*TLR*TLR/prfx.TL));
                        }

                    }
                }
            }
        }
    }

    //-----FORM SUMS
L12:
    if (nbckgd == 0)
    {
        for(II=2; II <= 7; II++)
        {
            if(GLB[II].codeword.L != 0.0)
            {
                KM=GLB[II].codeword.L;
                if (II == 2)DERIV[KM] += 1.0;
                if (II != 2)
                {
                    DERIV[KM] += pow( ((THMIN+double(IPM-1)*STEP)/BKPOS-1.0) , (II-2));
                }
            }
        }
    }


    YC_[IPM]=YCALC;

    if (jobtyp <= 2)
    {
        for(K = 1; K <= nphase; K++)
        {
            //-----UPDATING GLOBAL SCALE DERIVATE FOR BKG CONTRIBUTE
            if (fondo == 1 || fondo == 2)
            {
                LK1  = phases[K].PAR[1].codeword.L;
                if (LK1 != 0) DERIV[LK1] += volume.GCOM[K]*CSK[K]+volume.GCOM[K]*DISK[K];
            }

            //-----UPDATING DERIVATE OF Q OVERALL FOR BKG CONTRIBUTE
            if (fondo == 2)
            {
                LK2  = phases[K].PAR[2].codeword.L;
                if (LK2 != 0) DERIV[LK2] += DYCDD[K];
            }

            //-----UPDATING DERIVATE OF ISOTROPIC THERMAL PARAMETERS FOR BKG CONTRIBUTE
            if (fondo == 1)
            {
                IOF = 0;
                if (K > 1)
                {
                    for(I = 2; I <= K; I++) IOF = IOF + phases[I-1].NATOM;
                }
                for(I = 1; I <= phases[K].NATOM; I++)
                {
                    IISO=atoms[I+IOF].AtomPAR[4].codeword.L;
                    if (IISO != 0) DERIV[IISO] = DERIV[IISO] + atoms[I+IOF].ISODER;
                    atoms[I+IOF].ISODER=0.0;
                }
            }
        }

        //-----DYC RESPECT TO AMORPHOUS SCALE FACTOR
        LK = GLB[20].codeword.L;
        if (LK != 0) DERIV[LK] += AMORPHOUS_[IPM];

        //-----MONOCHROMATOR PARAMETERS DERIVATIVES
        LAMBDAM=(LAMDA[1]*RATIO[1]+LAMDA[2]*RATIO[2])/(RATIO[1]+RATIO[2]);
        ESSE=2*sin( degtorad( 2.0*(g3.TH-GLB[1]-SHIFT) ) )/LAMBDAM;
        LK=GLB[18].codeword.L;
        if ( LK != 0 )
        {
            //-------NEXT LINE FOR A LORENTZIAN MONOCHROMATOR BASS-BAND  FUNCTION
            ASS5=1/(1+GLB[18]*pow(ESSE,GLB[19]));
            DERMON=-(pow(ESSE,(GLB[19])))/ (  pow((1+GLB[18]*pow(ESSE,GLB[19])),2)  );
            DERIV[LK] += TOTCS/ASS5*DERMON;
        }

        LK=GLB[19].codeword.L;
        ASS5=1/(1+GLB[18]*pow(ESSE,GLB[19]));
        if ( LK != 0 )
        {
            DERMON=-GLB[18]*log(ESSE)*(pow(ESSE,GLB[19]))/ pow((1+GLB[18]*(pow(ESSE,GLB[19]))) , 2);
            DERIV[LK] += TOTCS/ASS5*DERMON;
        }

        //-----FORM THE UPPER TRIANGULAR OF "RJAC" = MATRIX OF NORMAL EQUATIONS
        prfx.DELTA = Y_[IPM]-BK_[IPM]-YCALC;
        for(J=1; J <= MAXS; J++)
        {
            X = DERIV[J]/(VAR_[IPM]);
            Fx[J] = Fx[J]+prfx.DELTA*X;
            for(KK=J; KK <= MAXS; KK++) matrix[J][KK] = matrix[J][KK]+X*DERIV[KK];
        }
    }
}

double DBWS::DPINV(int N)
{
    double C,D,T,S,A[MSZ+1][MSZ+1],B[MSZ+1],U[MSZ+1];
    int I, J, K, M[MSZ+1],I1, MI, MJ, MI1, MK1;
    double value;

    if ( N == 1 )
    {
        matrix[1][1] = 1.0/matrix[1][1];
        Fx[1] = Fx[1]*matrix[1][1];
        value = 1;
    }
    else
    {
        value = 0;
        for(I=1; I <= N; I++)
        {
            B[I]=Fx[I];
            for(J=1; J <= N; J++) A[I][J]=matrix[I][J];
        }
        for(I=1; I <= N; I++)
        {
            U[I]=abs(A[I][1]);
            C=U[I];
            for(J=2; J <= N; J++)
            {
                U[I]=max(U[I],abs(A[I][J]));
                C=C+abs(A[I][J]);
            }
            value=max(value,C);
            M[I]=I;
            B[I]=B[I]/U[I];
            for(J=1; J <= N; J++) A[I][J]=A[I][J]/U[I];
        }
        for(I=1; I <= N; I++)
        {
            if (I != N)
            {
                J=I;
                I1=I+1;
                MI=M[I];
                S=abs(A[MI][I]);
                for(K=I1; K <= N; K++)
                {
                    MI=M[K];
                    if (abs(A[MI][I]) > S)
                    {
                        S=abs(A[MI][I]);
                        J=K;
                    }
                }
                MK1=M[J];
                M[J]=M[I];
                M[I]=MK1;
            }

            MI1=M[I];
            A[MI1][I]=1.0/A[MI1][I];
            B[MI1]=B[MI1]*A[MI1][I];
            for(J=1; J <= N; J++)
            {
                if (I != J) A[MI1][J]=A[MI1][J]*A[MI1][I];
            }
            for(J=1; J <= N; J++)
            {
                if (J != I)
                {
                    MJ=M[J];
                    T=A[MJ][I];
                    MI1=M[I];
                    B[MJ]=B[MJ]-T*B[MI1];
                    A[MJ][I]=-T*A[MI1][I];
                    for(K=1; K <= N; K++)
                    {
                        if (K != I) A[MJ][K]=A[MJ][K]-T*A[MI1][K];
                    }
                }
            }
        }
        for(I=1; I <= N; I++)
        {
            MI1=M[I];
            Fx[I]=B[MI1];
            for(J=1; J <= N; J++)
            {
                MJ=M[J];
                matrix[I][MJ]=A[MI1][J]/U[MJ];
            }
        }
        C=0;
        for(I=1; I <= N; I++)
        {
            D=abs(matrix[I][1]);
            for(J=2; J <= N; J++) D=D+abs(matrix[I][J]);
            C=max(C,D);
        }
        value=value*C;
    }

    return value;
}

void DBWS::outscr(int I, double R2, double R3, double X)
{
    cout << "CYCLE NUMBER - " << I
         << " R-P =" << setw(8) << setprecision(2) << fixed << R2 << "%"
         << "    R-WP =" << setw(8) << setprecision(2) << fixed << R3 << "%"
         << "       R-EXPECTED =" << setw(8) << setprecision(2) << fixed << X << "%"
         << "  S = " << setw(8) << setprecision(2) << fixed << R3 / X << endl;
}

double DBWS::ERROR(double A[][6+1],double B[],double OMEGA)
{
    int I, J;
    double X, SUM;

    SUM=0.0;
    for(I=1; I <= 6; I++)
    {
        for(J=I; J <= 6; J++)
        {
            X=2.0;
            if (I == J)X=1.0;
            SUM=SUM+A[I][J]*B[I]*B[J]*X;
        }
    }
    if (SUM < 0.0)SUM=0.0;
    return sqrt(SUM*OMEGA);
}

void DBWS::ESD(double SM[][6+1], double V[], double SUM)
{
    double E[6+1],R[6+1], S[6+1],DEN, DENL, FNUM, FNUML;
    int I,IA, IB, IC, ID, IE, IP;



    I=0;
    for(IA=1; IA <= 3; IA++)
    {
        I=I+1;
        IB=IA+1;
        if (IB > 3)IB=IB-3;
        IC=IB+1;
        if (IC > 3)IC=IC-3;
        ID=IA+3;
        IE=IB+3;
        IP=IC+3;
        FNUM=4.0*V[IB]*V[IC]-V[ID]*V[ID];
        DEN=4.0*V[IA]*V[IB]*V[IC]-V[IA]*V[ID]*V[ID]-V[IB]*V[IE]*V[IE]-V[IC]*V[IP]*V[IP]+V[ID]*V[IE]*V[IP];
        S[I]=sqrt(FNUM/DEN);
        R[IA]=-pow(S[I],4);
        DENL=1.0/(DEN*DEN);
        R[IB]=DENL*(4.0*V[IC]*DEN-(4.0*V[IA]*V[IC]-V[IE]*V[IE])*FNUM);
        R[IC]=DENL*(4.0*V[IB]*DEN-(4.0*V[IA]*V[IB]-V[IP]*V[IP])*FNUM);
        R[ID]=-DENL*(2.0*V[ID]*DEN-(2.0*V[IA]*V[ID]-V[IE]*V[IP])*FNUM);
        R[IE]=DENL*FNUM*(2.0*V[IB]*V[IE]-V[ID]*V[IP]);
        R[IP]=DENL*FNUM*(2.0*V[IC]*V[IP]-V[ID]*V[IE]);
        E[I]=ERROR(SM,R,SUM);
        E[I]=E[I]/(2.0*S[I]);
        FNUM=V[IE]*V[IP]-2.0*V[IA]*V[ID];
        DEN=16.0*V[IA]*V[IA]*V[IB]*V[IC]+V[IE]*V[IE]*V[IP]*V[IP]-4.0*(V[IA]*V[IB]*V[IE]*V[IE]+V[IC]*V[IA]*V[IP]*V[IP]);
        DENL=1.0/(DEN*DEN);
        FNUML=FNUM*FNUM;
        S[I+3]=FNUML/DEN;
        R[IA]=-4.0*FNUM*DENL*(V[ID]*DEN+FNUM*(8.0*V[IA]*V[IB]*V[IC]-V[IB]*V[IE]*V[IE]-V[IC]*V[IP]*V[IP]));
        R[IB]=-4.0*FNUML*DENL*(4.0*V[IA]*V[IA]*V[IC]-V[IA]*V[IE]*V[IE]);
        R[IC]=-4.0*FNUML*DENL*(4.0*V[IA]*V[IA]*V[IB]-V[IA]*V[IP]*V[IP]);
        R[ID]=-4.0*FNUM/DEN*V[IA];
        R[IE]=2.0*FNUM*DENL*(V[IP]*DEN-FNUM*(V[IE]*V[IP]*V[IP]-4.0*V[IA]*V[IB]*V[IE]));
        R[IP]=2.0*FNUM*DENL*(V[IE]*DEN-FNUM*(V[IE]*V[IE]*V[IP]-4.0*V[IC]*V[IA]*V[IP]));
        E[I+3]=ERROR(SM,R,SUM);
        if (S[I+3] == 0.0)
        {
            S[I+3]=90.0;
            E[I+3]=0.0;
        }
        else
        {
            E[I+3]= radtodeg( E[I+3]/(2.0*sqrt(S[I+3]*(1.0-S[I+3]))) );
            S[I+3]= radtodeg( atan(sqrt((1.0-S[I+3])/S[I+3])) );
        }
        if (FNUM > 0.0) S[I+3]=180.0-S[I+3];
        if (SM[ID][ID] == 0.0) E[ID]=0.0;
    }
    if (abs(S[1]-S[2]) < 0.00008) E[1]=E[2];
    for(I=1; I <= 6; I++)
    {
        SM[I][I]=E[I];
        V[I]=S[I];
    }
}

void DBWS::DIRECT(double SM[][6+1],double V[], int IPH)
{
    int J, K, L, M;
    double X;


    for(J=1; J <= 6; J++)
    {
        V[J]=phases[IPH].PAR[J+5];
        K=phases[IPH].PAR[J+5].codeword.L;        
        if (K == 0)
        {
            X=0.0;
        }
        else
        {
            X=phases[IPH].PAR[J+5].codeword;
        }
        for(L=J; L <= 6; L++)
        {
            M=phases[IPH].PAR[L+5].codeword.L;
            SM[L][J]=0.0;
            if ( (M != 0) && (K != 0) )
            {
                SM[L][J]=matrix[M][K]*X*phases[IPH].PAR[L+5].codeword;
            }
            SM[J][L]=SM[L][J];
        }
    }
    ESD(SM,V,1.0);
}

void DBWS::OUTPTR(int ICYCLE)
{
    int I, J, N,IP, KM,IOF, MMM,ILOC1, ILOC2, MATCH, ICOCO,IIPHAS,IINNMOL;
    double W[99+1], X, V0,FR[99+1],DW[99+1], FT, DCV[6+1], DFR[99+1],
          FRP[99+1], VOL[99+1], ARG1, ARG2, ARG3, DCSM[6+1][6+1], DVOL[99+1], VOSQ,
          DMASS[99+1], SMASS[99+1], DUMMY[2*MSZ+4+1], XMASS[99+1],ARGCOS, WTOTAL,
          STMASSA[99+1], DWTOTAL;

    for(I=1; I <= 2*MSZ+4; I++) DUMMY[I] = 0.0;
    file6 << endl
          << " R-P        = " << setw(8) << setprecision(2) << R_p << "%" << endl
          << " R-WP       = " << setw(8) << setprecision(2) << R_wp << "%" << endl;
    if ( MAXS == 0  &&   cntrls.MAXSX != 0 )
    {
        X=100.0*sqrt((double(g3.NUM)-double(cntrls.MAXSX))*1.0/R_D2);
    }
    else
    {
        X=100.0*sqrt((double(g3.NUM)-double(MAXS))*1.0/R_D2);
    }
    if ( MAXS == 0  &&  mcycle == 1 )
    {
        outscr(cntrls.MCYCLX,R_p,R_wp,X);
    }
    else
    {
        outscr(ICYCLE-1,R_p,R_wp,X);
    }
    file6 << "R-EXPECTED = " << setw(8) << setprecision(2) << X << "%" << endl;
    file6 << "S          = " << setw(8) << setprecision(2) << sqrt(R_S2 / (double) (g3.NUM - MAXS)) << "     SQRT(RESIDUAL/N-P)GOODNESS OF FIT" << endl
          << "D - W D    = " << setw(8) << setprecision(2) << R_SS4 / R_SS2 << "     UNWEIGHTED DURBIN-WATSON STATISTIC D" << endl;
    I=g3.NUM-MAXS;
    file6 << "N-P        = " << I << endl;
    file6 << "       SUMYDIF       SUMYOBS      SUMYCALC      SUMWYOBSSQ      RESIDUAL      CONDITION" << endl
          << setw(14) << setprecision(4) << scientific << R_S1
          << setw(14) << setprecision(4) << scientific << R_D1
          << setw(14) << setprecision(4) << scientific << R_S3
          << setw(14) << setprecision(4) << scientific << R_D2
          << setw(14) << setprecision(4) << scientific << R_S2
          << setw(14) << setprecision(4) << scientific << g3.COND << endl;

    DUMMY[2*MSZ+1] = R_p;
    DUMMY[2*MSZ+2] = R_wp;
    DUMMY[2*MSZ+3] = sqrt(R_S2/double(g3.NUM));
    DUMMY[2*MSZ+4] = R_SS4/R_SS2;
    //     FINAL PARAMETERS AND R-FACTORS
    if (r_iplst != 0 && MAXS == 0)
    {
        for(IP=1; IP <= nphase; IP++)
        {
            IOF=0;
            if (IP > 1)
            {
                for(IIPHAS=2; IIPHAS <= IP; IIPHAS++) IOF = IOF + phases[IIPHAS-1].NATOM;
            }
            N=phases[IP].NATOM;
            for(I=1; I <= N; I++)
            {
                for(J=1; J <= 5; J++)
                {
                    KM=atoms[I+IOF].AtomPAR[J].codeword.L;
                    if (KM != 0)
                    {
                        if (J ==  5)
                        {
                            DUMMY[KM] = atoms[I+IOF].AtomPAR[J]*multip.XMLTP[IP]/atoms[I+IOF].MURT;
                        }
                        else
                        {
                            DUMMY[KM]  =atoms[I+IOF].AtomPAR[J];
                        }
                    }
                }
            }
            for(I=1; I <= N; I++)
            {
                for(J=6; J <= 11; J++)
                {
                    KM=atoms[I+IOF].AtomPAR[J].codeword.L;
                    if (KM != 0)
                    {
                        if (J ==  5)
                        {
                            DUMMY[KM] = atoms[I+IOF].AtomPAR[J]*multip.XMLTP[IP]/atoms[I+IOF].MURT;
                        }
                        DUMMY[KM]  =atoms[I+IOF].AtomPAR[J];
                    }
                }
            }
            for(J=1; J <= 27; J++)
            {
                KM=phases[IP].PAR[J].codeword.L;
                if (KM != 0) DUMMY[KM] = phases[IP].PAR[J];
            }
            DIRECT(DCSM,DCV,IP);
            for(I=1; I <= 6; I++)
            {
                KM = phases[IP].PAR[I+5].codeword.L;
                MATCH = 0;
                if (KM != 0)
                {
                    if (I >= 4)
                    {
                        for(MMM=1; MMM <= 3; MMM++) if (KM == phases[IP].PAR[MMM+5].codeword.L) MATCH=1;
                    }
                    if (MATCH == 0) DUMMY[KM] = dc.SAVE[IP][I];
                }
            }
        }
        for(J=1; J <= 20; J++)
        {
            //        if (NPROF == 8 && (J == 8 || J == 9)) goto 6019
            //        if (NPROF == 7 && J == 8) goto 6019
            //        if (NPROF == 6 && J == 8) goto 6019
            //        if (nprof == 5 && (j == 8 || j == 9)) goto 6019
            // glb(8) and gkb(9) are now used to surface roughness
            // and glb(14), glb(15), glb(16) aree unused
            if (nprof == 8 && (J == 14 || J == 15 || J == 16)) goto L6019;
            if (nprof == 7 && (J == 14 || J == 15 || J == 16)) goto L6019;
            if (nprof == 6 && (J == 14 || J == 15 || J == 16)) goto L6019;
            if (nprof == 5 && (J == 14 || J == 15 || J == 16)) goto L6019;
            KM=GLB[J].codeword.L;
            if (KM != 0) DUMMY[KM] = GLB[J];
L6019:
            ;
        }
        for(I=1; I <= 4; I++)
        {
            if (MOD(I,2) == 1) allp.ILOC = allp.ILOC + 1;
            allp.FINAL[allp.ILOC][2-MOD(I,2)] = DUMMY[2*MSZ+I];
        }
    }
    if (MAXS == 0 && mcycle == 1) return;
    allp.ILOC = 0;
    for(I=1; I <= NFINAL; I++)
    {
        for(J=1; J <= 2; J++) allp.FINAL[I][J] = 0.0;
    }
    file6 << endl << "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << endl << endl;
    file6 << "CYCLE NUMBER= " << ICYCLE << endl;

    for(IP=1; I <= nphase; I++)
    {
        IOF=0;
        if (IP > 1)
        {
            for(IIPHAS=2; IIPHAS <= IP; IIPHAS++) IOF = IOF + phases[IIPHAS-1].NATOM;
        }
        file6 << endl << "PHASE " << setw(2) << IP << ": " << phases[IP].name << endl
              << " NEW PARAMETERS, SHIFTS, AND STANDARD DEVIATIONS=" << endl << endl
              << " ATOM     X      DX     SX      Y      DY     SY      Z      DZ     SZ      B      DB     SB      So     DSo    SSo" << endl;
        N=phases[IP].NATOM;
        multip.TMASSA[IP]=0.0;
        STMASSA[IP]=0.0;
        for(I=1; I <= N; I++)
        {
            for(J=1; J <= 5; J++)
            {
                allp.ILOC =allp. ILOC + 1;
                KM=atoms[I+IOF].AtomPAR[J].codeword.L;
                if (KM != 0)
                {
                    atoms[I+IOF].AtomPAR[J].increase = sqrt(abs(matrix[KM][KM]));
                    atoms[I+IOF].AtomPAR[J].error = Fx[KM]*atoms[I+IOF].AtomPAR[J].codeword*RELAX[1];
                    if (J ==  5)
                    {
                        DUMMY[KM] = atoms[I+IOF].AtomPAR[J]*multip.XMLTP[IP]/atoms[I+IOF].MURT;
                        atoms[I+IOF].AtomPAR[J]=atoms[I+IOF].AtomPAR[J] + atoms[I+IOF].AtomPAR[J].error;
                        DUMMY[KM+MSZ]  = atoms[I+IOF].AtomPAR[J].error * multip.XMLTP[IP]/atoms[I+IOF].MURT;
                        allp.FINAL[allp.ILOC][1] = atoms[I+IOF].AtomPAR[J]*multip.XMLTP[IP]/atoms[I+IOF].MURT;
                        allp.FINAL[allp.ILOC][2] = atoms[I+IOF].AtomPAR[J].increase * multip.XMLTP[IP]/atoms[I+IOF].MURT;
                    }
                    else
                    {
                        DUMMY[KM]  = atoms[I+IOF].AtomPAR[J];
                        atoms[I+IOF].AtomPAR[J]=atoms[I+IOF].AtomPAR[J] + atoms[I+IOF].AtomPAR[J].error;
                        DUMMY[KM+MSZ]  = atoms[I+IOF].AtomPAR[J].error;
                        allp.FINAL[allp.ILOC][1] = atoms[I+IOF].AtomPAR[J];
                        allp.FINAL[allp.ILOC][2] = atoms[I+IOF].AtomPAR[J].increase;
                        SMASS[IP] = atoms[I+IOF].AtomPAR[J].increase;
                    }
                }
                else
                {
                    atoms[I+IOF].AtomPAR[J].error=0.0;
                    atoms[I+IOF].AtomPAR[J].increase=0.0;
                    if (J == 5)
                    {
                        allp.FINAL[allp.ILOC][1] = atoms[I+IOF].AtomPAR[J]*multip.XMLTP[IP]/atoms[I+IOF].MURT;
                    }
                    else
                    {
                        allp.FINAL[allp.ILOC][1] = atoms[I+IOF].AtomPAR[J];
                    }
                }
            }
            file6 << atoms[I + IOF].ATEXT << "  ";
            for (J = 1; J <= 4; ++J)
            {
                file6 << setw(7) << setprecision(4) << fixed << atoms[I+IOF].AtomPAR[J] << " "
                      << setw(7) << setprecision(4) << fixed << atoms[I+IOF].AtomPAR[J].error << " "
                      << setw(7) << setprecision(4) << fixed << atoms[I+IOF].AtomPAR[J].increase << " ";
            }
            file6 << setw(7) << setprecision(4) << fixed << atoms[I+IOF].AtomPAR[5] * multip.XMLTP[IP] / atoms[I + IOF].MURT << " "
                  << setw(7) << setprecision(4) << fixed << atoms[I+IOF].AtomPAR[5].error * multip.XMLTP[IP] / atoms[I + IOF].MURT << " "
                  << setw(7) << setprecision(4) << fixed << atoms[I+IOF].AtomPAR[5].increase * multip.XMLTP[IP] / atoms[I + IOF].MURT << " " << endl;
        }
        for(I=1; I <= N; I++)
        {
            for(J=6; J <= 11; J++)
            {
                allp.ILOC = allp.ILOC + 1;
                KM=atoms[I+IOF].AtomPAR[J].codeword.L;
                if (KM != 0)
                {
                    atoms[I+IOF].AtomPAR[J].increase = sqrt(abs(matrix[KM][KM]));
                    atoms[I+IOF].AtomPAR[J].error = Fx[KM]*atoms[I+IOF].AtomPAR[J].codeword*RELAX[2];
                    if (J ==  5)
                    {
                        DUMMY[KM] = atoms[I+IOF].AtomPAR[J]*multip.XMLTP[IP]/atoms[I+IOF].MURT;
                        atoms[I+IOF].AtomPAR[J]=atoms[I+IOF].AtomPAR[J] + atoms[I+IOF].AtomPAR[J].error;
                        DUMMY[KM+MSZ] = atoms[I+IOF].AtomPAR[J].error * multip.XMLTP[IP]/atoms[I+IOF].MURT;
                        allp.FINAL[allp.ILOC][1] = atoms[I+IOF].AtomPAR[J]*multip.XMLTP[IP]/atoms[I+IOF].MURT;
                        allp.FINAL[allp.ILOC][2] = atoms[I+IOF].AtomPAR[J].increase * multip.XMLTP[IP]/atoms[I+IOF].MURT;
                    }
                    else
                    {
                        DUMMY[KM]  =atoms[I+IOF].AtomPAR[J];
                        atoms[I+IOF].AtomPAR[J]=atoms[I+IOF].AtomPAR[J]+atoms[I+IOF].AtomPAR[J].error;
                        DUMMY[KM+MSZ]  = atoms[I+IOF].AtomPAR[J].error;
                        allp.FINAL[allp.ILOC][1] = atoms[I+IOF].AtomPAR[J];
                        allp.FINAL[allp.ILOC][2] = atoms[I+IOF].AtomPAR[J].increase;
                    }
                }
                else
                {
                    atoms[I+IOF].AtomPAR[J].error=0.0;
                    atoms[I+IOF].AtomPAR[J].increase=0.0;
                    allp.FINAL[allp.ILOC][1] = atoms[I+IOF].AtomPAR[J];
                }
            }
            file6 << atoms[I + IOF].ATEXT;
            for (J = 6; J <= 11; ++J)
            {
                file6 << setw(10) << setprecision(6) << fixed << atoms[I+IOF].AtomPAR[J]
                      << setw(10) << setprecision(6) << fixed << atoms[I+IOF].AtomPAR[J].error
                      << setw(10) << setprecision(6) << fixed << atoms[I+IOF].AtomPAR[J].increase;
            }
            file6 << endl;
        }
        for(J=1; J<=27; J++)
        {
            if ( J == 12 )
            {
                allp.ILOC = allp.ILOC + 1;
                allp.FINAL[allp.ILOC][1] = phases[IP].PREF[1];
                allp.FINAL[allp.ILOC][2] = phases[IP].PREF[2];
                allp.ILOC = allp.ILOC + 1;
                allp.FINAL[allp.ILOC][1] = phases[IP].PREF[3];
            }
            allp.ILOC = allp.ILOC + 1;
            if ( J == 6 ) ILOC1 = allp.ILOC;
            KM = phases[IP].PAR[J].codeword.L;
            if ( KM == 0 )
            {
                phases[IP].PAR[J].error = 0.0;
                phases[IP].PAR[J].increase = 0.0;
                allp.FINAL[allp.ILOC][1] = phases[IP].PAR[J];
            }
            else
            {
                phases[IP].PAR[J].increase = sqrt(abs(matrix[KM][KM]));
                phases[IP].PAR[J].error = Fx[KM]*phases[IP].PAR[J].codeword*RELAX[3];
                DUMMY[KM] = phases[IP].PAR[J];
                phases[IP].PAR[J] = phases[IP].PAR[J] + phases[IP].PAR[J].error;
                DUMMY[KM+MSZ] = phases[IP].PAR[J].error;
                allp.FINAL[allp.ILOC][1] = phases[IP].PAR[J];
                allp.FINAL[allp.ILOC][2] = phases[IP].PAR[J].increase;
            }
        }
        DIRECT(DCSM,DCV,IP);
        ILOC2 = allp.ILOC;
        allp.ILOC = ILOC1-1;
        for(I=1; I <= 6; I++)
        {
            allp.ILOC = allp.ILOC + 1;
            KM = phases[IP].PAR[I+5].codeword.L;
            MATCH=0;
            phases[IP].PAR[I+5].error = DCV[I]-dc.SAVE[IP][I];
            if (KM != 0)
            {
                if (I >= 4)
                {
                    for(MMM=1; MMM <= 3; MMM++)
                    {
                        if (KM == phases[IP].PAR[MMM+5].codeword.L) MATCH=1;
                    }
                }
                if (MATCH == 0)
                {
                    DUMMY[KM] = dc.SAVE[IP][I];
                    DUMMY[KM+MSZ] = phases[IP].PAR[I+5].error;
                }
            }
            allp.FINAL[allp.ILOC][1] = DCV[I];
            allp.FINAL[allp.ILOC][2] = DCSM[I][I];
            dc.SAVE[IP][I]=DCV[I];
        }
        allp.ILOC = ILOC2;

        phases[IP].PAR[6].increase = DCSM[1][1];
        phases[IP].PAR[7].increase = DCSM[2][2];
        phases[IP].PAR[8].increase = DCSM[3][3];
        phases[IP].PAR[9].increase = DCSM[4][4];
        phases[IP].PAR[10].increase = DCSM[5][5];
        phases[IP].PAR[11].increase = DCSM[6][6];

        file6 << endl
              << "OVERALL SCALE FACTOR="
              << setw(3) << setprecision(9) << scientific << phases[IP].PAR[1]
              << setw(3) << setprecision(9) << scientific << phases[IP].PAR[1].error
              << setw(3) << setprecision(9) << scientific << phases[IP].PAR[1].increase << endl
              << "OVERALL TEMP. FACTOR="
              << setw(9) << setprecision(4) << fixed << phases[IP].PAR[2]
              << setw(9) << setprecision(4) << fixed << phases[IP].PAR[2].error
              << setw(9) << setprecision(4) << fixed << phases[IP].PAR[2].increase << endl
              << "CELL PARAMETERS=" << endl
              << setw(11) << setprecision(6) << fixed << DCV[1]
              << setw(11) << setprecision(6) << fixed << phases[IP].PAR[6].error
              << setw(11) << setprecision(6) << fixed << phases[IP].PAR[6].increase << endl
              << setw(11) << setprecision(6) << fixed << DCV[2]
              << setw(11) << setprecision(6) << fixed << phases[IP].PAR[7].error
              << setw(11) << setprecision(6) << fixed << phases[IP].PAR[7].increase << endl
              << setw(11) << setprecision(6) << fixed << DCV[3]
              << setw(11) << setprecision(6) << fixed << phases[IP].PAR[8].error
              << setw(11) << setprecision(6) << fixed << phases[IP].PAR[8].increase << endl
              << setw(11) << setprecision(4) << fixed << DCV[4]
              << setw(11) << setprecision(4) << fixed << phases[IP].PAR[9].error
              << setw(11) << setprecision(4) << fixed << phases[IP].PAR[9].increase << endl
              << setw(11) << setprecision(4) << fixed << DCV[5]
              << setw(11) << setprecision(4) << fixed << phases[IP].PAR[10].error
              << setw(11) << setprecision(4) << fixed << phases[IP].PAR[10].increase << endl
              << setw(11) << setprecision(4) << fixed << DCV[6]
              << setw(11) << setprecision(4) << fixed << phases[IP].PAR[11].error
              << setw(11) << setprecision(4) << fixed << phases[IP].PAR[11].increase << endl
              << "PREFERRED ORIENTATION PARAMETERS=" << endl
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[12]
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[12].error
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[12].increase << endl
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[13]
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[13].error
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[13].increase << endl
              << "ASYMMETRY PARAMETER=" << endl
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[14]
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[14].error
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[14].increase << endl
              << "LORENTZIAN HALF WIDTH PARAMS (X AND Y)" << endl
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[15]
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[15].error
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[15].increase << endl
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[16]
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[16].error
              << setw(8) << setprecision(5) << fixed << phases[IP].PAR[16].increase << endl;
        //-----CHECK FOR THE SPLIT PEARSON VII PROFILE
        if (nprof == 5)
        {
            file6 << "LOW SIDE EXPONENT PARAMETERS (NA, NB, NC)="
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[17]
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[17].error
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[17].increase << endl
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[18]
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[18].error
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[18].increase << endl
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[19]
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[19].error
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[19].increase << endl
                  << "HIGH SIDE EXPONENT PARAMETERS (NA, NB, NC)="
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[24]
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[24].error
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[24].increase << endl
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[25]
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[25].error
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[25].increase << endl
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[26]
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[26].error
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[26].increase << endl
                  << "0SPLIT PEARSON VII ASSYMETRY PARAMETER="
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[27]
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[27].error
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[27].increase << endl;
        }
        else
        {
            //-----IF NOT A SPLIT PEARSON VII PROFILE
            file6 << "MIXING PARAMETERS (NA, NB, NC)=" << endl
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[17]
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[17].error
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[17].increase << endl
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[18]
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[18].error
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[18].increase << endl
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[19]
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[19].error
                  << setw(10) << setprecision(4) << scientific << phases[IP].PAR[19].increase << endl;
        }
        file6 << "FWHM PARAMETERS=" << endl
              << " U = "
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[3]
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[3].error
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[3].increase << endl
              << " V = "
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[4]
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[4].error
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[4].increase << endl
              << " W = "
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[5]
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[5].error
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[5].increase << endl
              << " CT= "
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[21]
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[21].error
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[21].increase << endl
              << " Z = "
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[20]
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[20].error
              << setw(10) << setprecision(4) << scientific << phases[IP].PAR[20].increase << endl;

        //-----Modification introduced by Carlos O. Paiva-Santos to perform
        //-----Quantitative phase analysis, 03/94. Added 05/94, T.S. Moss
        //-----CHANGES TO INCORPORATE THE REFINED OCCUPANCY.
        for(I=1; I <= N; I++)
        {
            ICOCO=atoms[I+IOF].PTR;
            multip.TMASSA[IP] = multip.TMASSA[IP] + atoms[I+IOF].AtomPAR[5]*XMAS[ICOCO]*multip.XMLTP[IP];
            STMASSA[IP] = STMASSA[IP] + SMASS[IP]*XMAS[ICOCO]*multip.XMLTP[IP];
        }
        //      print '(a,f12.5, I2)', ' stmassa = ', stmassa(ip), ip



        DCV[4] = degtorad( DCV[4] );
        DCSM[4][4] = degtorad( DCSM[4][4] );

        DCV[5] = degtorad( DCV[5] );
        DCSM[5][5] = degtorad( DCSM[5][5] );

        DCV[6] = degtorad( DCV[6] );
        DCSM[6][6] = degtorad( DCSM[6][6] );
        //-----Calculations of VOLUME and SVZM (=W) for each phase
        //-----and respectives standard deviations
        ARGCOS= 1-pow((cos(DCV[4])),2)-pow((cos(DCV[5])),2)-pow((cos(DCV[6])),2) + 2 * (cos(DCV[4])) * (cos(DCV[5])) * (cos(DCV[6]));
        V0 = DCV[1] * DCV[2] * DCV[3];
        VOL[IP] = V0 * sqrt(ARGCOS);
        VOSQ = 0.5*VOL[IP]/ARGCOS;
        ARG1 = VOSQ*(2 * cos(DCV[4]) * sin(DCV[4]) - 2*sin(DCV[4]) *cos(DCV[5]) *cos(DCV[6])) *DCSM[4][4];
        ARG2 = VOSQ*(2 * cos(DCV[5]) * sin(DCV[5]) - 2*sin(DCV[5]) *cos(DCV[4]) *cos(DCV[6])) *DCSM[5][5];
        ARG3 = VOSQ*(2 * cos(DCV[6]) * sin(DCV[6]) - 2*sin(DCV[6]) *cos(DCV[4]) *cos(DCV[5])) *DCSM[6][6];
        DVOL[IP] = sqrt(pow((VOL[IP] * DCSM[1][1] / DCV[1]),2) + pow((VOL[IP] * DCSM[2][2] / DCV[2]),2) + pow((VOL[IP] * DCSM[3][3] / DCV[3]),2) + pow(ARG1,2) + pow(ARG2,2) + pow(ARG3,2));
        // standard deviations are calculed below
        W[IP] = phases[IP].PAR[1] * multip.TMASSA[IP] * VOL[IP]/phases[IP].SAQF;
        DW[IP] =  (phases[IP].PAR[1].increase/phases[IP].PAR[1]) + (DVOL[IP]/VOL[IP]) + (STMASSA[IP]/multip.TMASSA[IP])/phases[IP].SAQF;
        //   end of std
        file6 << "Volume= "
              << setw(9) << setprecision(3) << fixed << VOL[IP]
              << "(+/-)"
              << setw(7) << setprecision(3) << fixed << DVOL[IP]
              << " UCW= "
              << setw(7) << setprecision(2) << fixed << multip.TMASSA[IP]
              << " U.C.Density = "
              << setw(7) << setprecision(3) << fixed << multip.TMASSA[IP] * 1.66113 / VOL[IP]
              << " gr/cm^3" << endl
              << "                     _____________________________" << endl;
    }

    // ****** QUANTITATIVE ANALYSIS ***************
    WTOTAL = 0.000000;
    DWTOTAL = 0.000000;
    for(I = 1; I <= nphase; I++)
    {
        WTOTAL = WTOTAL + W[I];
        //      DWTOTAL = DWTOTAL + DW(I)
    }
    for(I = 1; I <= nphase; I++)
    {
        if (nphase == 1)
        {
            XMASS[I] = 100.0 * W[I] / WTOTAL;
            DMASS[1]= 0.0;
        }
        else
        {
            XMASS[I] = 100.0 * W[I] / WTOTAL;
            DMASS[I] = 100*DW[I];
        }
    }
    IINNMOL = 0;
    for(I = 1; I <= nphase; I++)
    {
        if (IINNMOL != 1)
        {
            if (phases[I].NMOL == 0) IINNMOL=1;
        }
    }
    if (IINNMOL == 1)
    {
        for(I = 1; I <= nphase; I++)
        {
            // ** printing results
            file6 << "PHASE = " << I << " => %MASS = " << setw(6) << setprecision(2) << fixed << XMASS[I] << "(+/-)"
                  << setw(6) << setprecision(2) << fixed << DMASS[I] << "%MOLAR = NOT COMPUTED" << endl;
        }
    }
    else
    {
        // ****    CALCULATION OF MOLAR FRACTION  ****
        FT = 0.0000000;
        for(I = 1; I <= nphase; I++)
        {
            FRP[I] = XMASS[I] * phases[I].NMOL / multip.TMASSA[I];
            FT = FT + FRP[I];
        }
        for(I = 1; I <= nphase; I++)
        {
            FR[I] = 100.0 * FRP[I] / FT;
            //      dfr(I) = dmass(i)*nmol(i)/tmassa(i)
            DFR[I] = FR[I] * DMASS[I]/XMASS[I];
            // ** printing results
            file6 << "PHASE = " << I << " => %MASS = "
                  << setw(6) << setprecision(2) << fixed << XMASS[I] << "(+/-)"
                  << setw(6) << setprecision(2) << fixed << DMASS[I] << "%MOLAR = "
                  << setw(6) << setprecision(2) << fixed << FR[I] << "(+/-)"
                  << setw(6) << setprecision(2) << fixed << DFR[I] << endl;
        }
    }
    file6 << endl;
    for(J=1; J <= 20; J++)
    {
        allp.ILOC = allp.ILOC +1;
        KM=GLB[J].codeword.L;
        if (KM != 0)
        {
            GLB[J].increase=sqrt(abs(matrix[KM][KM]));
            GLB[J].error=Fx[KM]*GLB[J].codeword*RELAX[4];
            DUMMY[KM] = GLB[J];
            GLB[J]=GLB[J]+GLB[J].error;
            DUMMY[KM+MSZ]  = GLB[J].error;
            allp.FINAL[allp.ILOC][1] = GLB[J];
            allp.FINAL[allp.ILOC][2] = GLB[J].increase;
        }
        else
        {
            GLB[J].error=0.0;
            GLB[J].increase=0.0;
            allp.FINAL[allp.ILOC][1] = GLB[J];
        }
    }
    if (allp.ILOC  >  NFINAL)
    {
        cout << "Parameter NFINAL in PARAM.INC file too small" << endl;
        exit(EXIT_FAILURE);
    }
    file6 << "GLOBAL PARAMETERS" << endl
          << "ZEROPOINT (ZER)             :"
          << setw(8) << setprecision(4) << fixed << GLB[1]
          << setw(8) << setprecision(4) << fixed << GLB[1].error
          << setw(8) << setprecision(4) << fixed << GLB[1].increase << endl;

    file6 << "SAMPLE DISPLACEMENT (DISP)  :"
          << setw(8) << setprecision(4) << fixed << GLB[10]
          << setw(8) << setprecision(4) << fixed << GLB[10].error
          << setw(8) << setprecision(4) << fixed << GLB[10].increase << endl
          << "SAMPLE TRANSPARENCY (TRANSP):"
          << setw(8) << setprecision(4) << fixed << GLB[11]
          << setw(8) << setprecision(4) << fixed << GLB[11].error
          << setw(8) << setprecision(4) << fixed << GLB[11].increase << endl
          << "ROUGHNESS PARAMETERS        :"
          << "             P              :"
          << setw(8) << setprecision(4) << fixed << GLB[8]
          << setw(8) << setprecision(4) << fixed << GLB[8].error
          << setw(8) << setprecision(4) << fixed << GLB[8].increase << endl
          << "             Q              :"
          << setw(8) << setprecision(4) << fixed << GLB[9]
          << setw(8) << setprecision(4) << fixed << GLB[9].error
          << setw(8) << setprecision(4) << fixed << GLB[9].increase << endl
          << "             R              :"
          << setw(8) << setprecision(4) << fixed << GLB[12]
          << setw(8) << setprecision(4) << fixed << GLB[12].error
          << setw(8) << setprecision(4) << fixed << GLB[12].increase << endl
          << "             T              :"
          << setw(8) << setprecision(4) << fixed << GLB[13]
          << setw(8) << setprecision(4) << fixed << GLB[13].error
          << setw(8) << setprecision(4) << fixed << GLB[13].increase << endl;



    file6 << " AMORPHOUS SCALE (SCAM):"
          << setw(8) << setprecision(4) << fixed << GLB[20]
          << setw(8) << setprecision(4) << fixed << GLB[20].error
          << setw(8) << setprecision(4) << fixed << GLB[20].increase << endl;

    file6 << endl << "MONOCROMATOR BANDPASS PARAMETERS (PMONI)"
          << setw(8) << setprecision(4) << fixed << GLB[18]
          << setw(8) << setprecision(4) << fixed << GLB[18].error
          << setw(8) << setprecision(4) << fixed << GLB[18].increase << endl
          << setw(8) << setprecision(4) << fixed << GLB[19]
          << setw(8) << setprecision(4) << fixed << GLB[19].error
          << setw(8) << setprecision(4) << fixed << GLB[19].increase << endl;
    if (nbckgd == 0)
    {
        file6 << endl << "BACKGROUND PARAMETERS" << endl
              << setw(12) << setprecision(6) << scientific << GLB[2]
              << setw(12) << setprecision(6) << scientific << GLB[2].error
              << setw(12) << setprecision(6) << scientific << GLB[2].increase << endl
              << setw(12) << setprecision(6) << scientific << GLB[3]
              << setw(12) << setprecision(6) << scientific << GLB[3].error
              << setw(12) << setprecision(6) << scientific << GLB[3].increase << endl
              << setw(12) << setprecision(6) << scientific << GLB[4]
              << setw(12) << setprecision(6) << scientific << GLB[4].error
              << setw(12) << setprecision(6) << scientific << GLB[4].increase << endl
              << setw(12) << setprecision(6) << scientific << GLB[5]
              << setw(12) << setprecision(6) << scientific << GLB[5].error
              << setw(12) << setprecision(6) << scientific << GLB[5].increase << endl
              << setw(12) << setprecision(6) << scientific << GLB[6]
              << setw(12) << setprecision(6) << scientific << GLB[6].error
              << setw(12) << setprecision(6) << scientific << GLB[6].increase << endl
              << setw(12) << setprecision(6) << scientific << GLB[7]
              << setw(12) << setprecision(6) << scientific << GLB[7].error
              << setw(12) << setprecision(6) << scientific << GLB[7].increase << endl;
    }
}

void DBWS::CEL000()
{
    //                             THIS SR IS USED TO FORCE A POINT XYZ TO
    //                           LIE IN THE UNIT CELL AT 000.
    blnk1.X[blnk1.MULTX-1] = AMOD(blnk1.X[blnk1.MULTX-1]+8.0,1.0);
    if ( blnk1.X[blnk1.MULTX-1]-0.99999 >= 0) blnk1.X[blnk1.MULTX-1] = 0.0;

    blnk1.Y[blnk1.MULTX-1] = AMOD(blnk1.Y[blnk1.MULTX-1]+8.0,1.0);
    if ( blnk1.Y[blnk1.MULTX-1]-0.99999 >= 0 ) blnk1.Y[blnk1.MULTX-1] = 0.0;

    blnk1.Z[blnk1.MULTX-1] = AMOD(blnk1.Z[blnk1.MULTX-1]+8.0,1.0);
    if ( blnk1.Z[blnk1.MULTX-1]-0.99999 >= 0 ) blnk1.Z[blnk1.MULTX-1] = 0.0;
}

void DBWS::OPERTR(int I, int L2)
{
//
//                             THIS SR GENERATES THE SYMMETRY EQUIVALENT
//                           POSITIONS. IT IS CALLED BY SYMOPR.
//
    int I1, I2, I3, I4, I5, I6, I7, I8;

    I1 = MOD(spgcom.NCONT[I],4)+1;
    I2 = MOD(spgcom.NCONT[I]/4,4)+1;
    I3 = MOD(spgcom.NCONT[I]/16,4)+1;
    I4 = MOD(spgcom.NCONT[I]/64,4)+1;
    I5 = MOD(spgcom.NCONT[I]/256,2);
    I6 = MOD(spgcom.NCONT[I]/512,4)+1;
    I7 = MOD(spgcom.NCONT[I]/2048,4)+1;
    I8 = spgcom.NCONT[I]/8192+1;
    switch (I8) {
    case 1:
        switch (I1) {
        case 1:
            blnk1.X[blnk1.MULTX] = blnk1.X[L2];
            break;
        case 2:
            blnk1.X[blnk1.MULTX] = blnk1.Y[L2];
            break;
        case 3:
            blnk1.X[blnk1.MULTX] = -blnk1.X[L2];
            break;
        case 4:
            blnk1.X[blnk1.MULTX] = -blnk1.Y[L2];
            break;
        default:
            GOTOER();
            break;
        }
        switch (I2) {
        case 1:
            break;
        case 2:
            blnk1.X[blnk1.MULTX] += 1.0/2.0;
            break;
        case 3:
            blnk1.X[blnk1.MULTX] += 1.0/4.0;
            break;
        case 4:
            blnk1.X[blnk1.MULTX] += 3.0/4.0;
            break;
        default:
            GOTOER();
            break;
        }
        switch (I3) {
        case 1:
            blnk1.Y[blnk1.MULTX] = blnk1.Y[L2];
            break;
        case 2:
            blnk1.Y[blnk1.MULTX] = blnk1.X[L2];
            break;
        case 3:
            blnk1.Y[blnk1.MULTX] = -blnk1.Y[L2];
            break;
        case 4:
            blnk1.Y[blnk1.MULTX] = -blnk1.X[L2];
            break;
        default:
            GOTOER();
            break;
        }
        switch (I4) {
        case 1:
            break;
        case 2:
            blnk1.Y[blnk1.MULTX] += 1.0/2.0;
            break;
        case 3:
            blnk1.Y[blnk1.MULTX] += 1.0/4.0;
            break;
        case 4:
            blnk1.Y[blnk1.MULTX] += 3.0/4.0;
            break;
        default:
            GOTOER();
            break;
        }
        blnk1.Z[blnk1.MULTX] = blnk1.Z[L2]*double(1-2*I5);
        switch (I6) {
        case 1:
            break;
        case 2:
            blnk1.Z[blnk1.MULTX] += 1.0/2.0;
            break;
        case 3:
            blnk1.Z[blnk1.MULTX] += 1.0/4.0;
            break;
        case 4:
            blnk1.Z[blnk1.MULTX] += 3.0/4.0;
            break;
        default:
            GOTOER();
            break;
        }
        switch (I7) {
        case 1:
            break;
        case 2:
            blnk1.Z[blnk1.MULTX] += 1.0/3.0;
            break;
        case 3:
            blnk1.Z[blnk1.MULTX] += 2.0/3.0;
            break;
        default:
            GOTOER();
            break;
        }
        blnk1.MULTX = blnk1.MULTX+1;
        CEL000();
        return;
        break;
    case 2:
        blnk1.X[blnk1.MULTX] = -blnk1.Y[L2];
        blnk1.Y[blnk1.MULTX] = blnk1.X[L2]-blnk1.Y[L2];
        blnk1.Z[blnk1.MULTX] = blnk1.Z[L2]+0.333333333*double(I2-2);
        blnk1.MULTX = blnk1.MULTX+1;
        CEL000();
        blnk1.X[blnk1.MULTX] = -blnk1.Y[blnk1.MULTX-1];
        blnk1.Y[blnk1.MULTX] = -blnk1.X[L2];
        blnk1.Z[blnk1.MULTX] = blnk1.Z[L2]-0.333333333*double(I2-2);
        blnk1.MULTX = blnk1.MULTX+1;
        CEL000();
        return;
        break;
    case 3:
        I1 = L2;
        goto L301;
        break;
    default:
        GOTOER();
        break;
    }


L301:
    blnk1.X[blnk1.MULTX] = blnk1.Z[I1];
    blnk1.Y[blnk1.MULTX] = blnk1.X[I1];
    blnk1.Z[blnk1.MULTX] = blnk1.Y[I1];
    if ( I1-L2 <= 0 ) {
        I1 = blnk1.MULTX;
        blnk1.MULTX = blnk1.MULTX+1;
        CEL000();
        goto L301;
    }
    else {
        blnk1.MULTX = blnk1.MULTX+1;
        CEL000();
        return;
    }

}

void DBWS::SYMOPR()
{
//
//                             THIS SR TAKES A POINT XYZ, DETERMINES THE
//                           SITE MULTIPLICITY, THE SITE SYMMETRY, AND
//                           THE SYMMETRY CONSTRAINTS ON THE POSITIONAL
//                           AND THERMAL PARAMETERS.
//

    int I, J, L1, L2, L3, L4, L5, L6,KX, KY, KZ, IOP, ISCK, ISRH;
    double X3;

//     INTEGER AND,OR
//     AND(I,J) = IAND(I,J)
//     OR(I,J) = IOR(I,J)

    ISCK = 0;
L103:
    blnk1.MULTX = 2;
    ISRH = 0;
    blnk1.IXB = 0;
    blnk1.XLT = 1.0;
    J = 1;
    CEL000();
    L1=J;
    for(I=1; I <= 8; I++)
    {
        IOP = 0;
        if ( spgcom.NCONT[I] == 0 ) goto L104;
        //L1:
        for(L2=J; L2 <= L1; L2++)
        {
            L3=blnk1.MULTX-1;
            if ( spgcom.NCONT[I]-8192 == 0 ) {
                blnk1.X[blnk1.MULTX]=blnk1.X[L2]+1.0/3.0;
                blnk1.Y[blnk1.MULTX]=blnk1.Y[L2]+2.0/3.0;
                blnk1.Z[blnk1.MULTX]=blnk1.Z[L2]+2.0/3.0;

                blnk1.X[blnk1.MULTX+1]=blnk1.X[L2]+2.0/3.0;
                blnk1.Y[blnk1.MULTX+1]=blnk1.Y[L2]+1.0/3.0;
                blnk1.Z[blnk1.MULTX+1]=blnk1.Z[L2]+1.0/3.0;

                blnk1.MULTX=blnk1.MULTX+1;
                CEL000();
                blnk1.MULTX=blnk1.MULTX+1;
                CEL000();
            }
            else {
                OPERTR(I,L2);
            }
            L5=blnk1.MULTX;
            L6=spgcom.NCONT[I];
            blnk1.MULTX = L3+1;
L8:
            L4 = 1;
            if ( abs(blnk1.X[blnk1.MULTX]-blnk1.X[L4])-0.0001 <= 0 ) {
                goto L2;
            }
            else {
                goto L90;
            }
L2:
            if ( abs(blnk1.Y[blnk1.MULTX]-blnk1.Y[L4])-0.0001 <= 0 ) {
                goto L3;
            }
            else {
                goto L90;
            }
L3:
            if ( abs(blnk1.Z[blnk1.MULTX]-blnk1.Z[L4])-0.0001 <= 0 ) {
                goto L91;
            }
            else {
                goto L90;
            }
L91:
            if ( (blnk1.NCTR[blnk1.MULTX]-8192) < 0)
            {
                goto L92;
            }
            else if ( (blnk1.NCTR[blnk1.MULTX]-8192) == 0)
            {
                goto L94;
            }
            else
            {
                goto L93;
            }
L92:
            KX = MOD(blnk1.NCTR[blnk1.MULTX],4)+1;
            KY = MOD(blnk1.NCTR[blnk1.MULTX]/16,4)+1;
            KZ = MOD(blnk1.NCTR[blnk1.MULTX]/256,2);
            if ( IOP == 0 ) blnk1.XLT=blnk1.XLT/2.0;
            IOP = 1;
            switch (KX) {
            case 1:
                goto L920;
                break;
            case 2:
                goto L930;
                break;
            case 3:
                goto L940;
                break;
            case 4:
                goto L950;
                break;
            }
            GOTOER();
L920:
            switch (KY) {
            case 1:
                goto L921;
                break;
            case 2:
                goto L1000;
                break;
            case 3:
                goto L922;
                break;
            case 4:
                goto L1000;
                break;
            }
            GOTOER();
L921:
            if ( KZ == 0 ) goto L1000;
            blnk1.IXB = ior(blnk1.IXB,2621450);
            goto L90;
L922:
            if ( KZ == 0 ) blnk1.IXB= ior(blnk1.IXB,2228292);
            if ( KZ == 1 ) blnk1.IXB= ior(blnk1.IXB, 655432);
            goto L90;
L930:
            blnk1.IXB = ior(blnk1.IXB,32768);
            switch (KY) {
            case 1:
                goto L1000;
                break;
            case 2:
                goto L931;
                break;
            case 3:
                goto L1000;
                break;
            case 4:
                goto L932;
                break;
            }
            GOTOER();
L931:
            if ( KZ == 0 ) blnk1.IXB= ior(blnk1.IXB, 4194464);
            if ( KZ == 1 ) blnk1.IXB= ior(blnk1.IXB,12583048);
            goto L90;
L932:
            blnk1.IXB = ior(blnk1.IXB,2753088);
            if ( KZ == 1 ) blnk1.IXB = ior(blnk1.IXB,8);
            goto L90;
L940:
            blnk1.IXB = ior(blnk1.IXB,512);
            switch (KY) {
            case 1:
                goto L941;
                break;
            case 2:
                goto L1000;
                break;
            case 3:
                goto L942;
                break;
            case 4:
                goto L1000;
                break;
            }
            GOTOER();
L941:
            blnk1.IXB = ior(blnk1.IXB,131072);
            if ( KZ == 1 ) goto L943;
            blnk1.IXB = ior(blnk1.IXB,525312);
            goto L90;
L942:
            blnk1.IXB = ior(blnk1.IXB,64);
            if ( KZ == 1 ) goto L944;
            blnk1.IXB = ior(blnk1.IXB,2623488);
            goto L90;
L943:
            blnk1.IXB = ior(blnk1.IXB,2097152);
L944:
            blnk1.IXB = ior(blnk1.IXB,8);
            goto L90;
L950:
            blnk1.IXB = ior(blnk1.IXB,32768);
            switch (KY) {
            case 1:
                goto L1000;
                break;
            case 2:
                goto L951;
                break;
            case 3:
                goto L1000;
                break;
            case 4:
                goto L952;
                break;
            }
            GOTOER();
L951:
            blnk1.IXB = ior(blnk1.IXB,2753088);
            if ( KZ == 1 ) blnk1.IXB = ior(blnk1.IXB,8);
            goto L90;
L952:
            if ( KZ == 0 ) blnk1.IXB = ior(blnk1.IXB,8388864);
            if ( KZ == 1 ) blnk1.IXB= ior(blnk1.IXB,4194568);
            goto L90;
L93:
            if ( MOD(blnk1.NCTR[blnk1.MULTX],16384) == 0 ) goto L95;
            ISRH = 1;
            if ( iand(307,blnk1.NCTR[blnk1.MULTX]-spgcom.NCONT[I]) == 0 ) goto L92;
            goto L90;
L94:
            blnk1.IXB = ior(blnk1.IXB,2916928);
            blnk1.XLT = blnk1.XLT/3.0;
            goto L99;
L95:
            blnk1.IXB = ior(blnk1.IXB,17924240);
            blnk1.XLT = blnk1.XLT/3.0;
            goto L99;
L90:
            if ( L6-8192 < 0) {
                goto L99;
            }
            else {
                goto L98;
            }
L98:
            L6=1;
            blnk1.MULTX = blnk1.MULTX+1;
            goto L8;
L99:
            blnk1.MULTX=L5;
        }
        //L100:
        L1=blnk1.MULTX-1;
    }
L104:
    if ( ISRH == 0 ) goto L200;
    if ( ISCK > 1 ) goto L2000;
    ISCK = ISCK+1;
    for(J=1; J <= I; J++) if ( spgcom.NCONT[J] == 16384 ) goto L1011;
    for(L2 = 1; L2 <= L1; L2++)
    {
        if ( abs(blnk1.X[L2]-blnk1.Y[L2]) <= 0.0001 ) goto L102;
        if ( abs(blnk1.X[L2]+blnk1.Y[L2]-1.0) <= 0.0002 ) goto L102;
    }
    ISCK = 2;
    file6 << endl << endl << "NO X,X,Z OR X,-X,Z SET WAS FOUND FOR"
          << setw(8) << setprecision(5) << fixed << blnk1.X[1]
          << setw(8) << setprecision(5) << fixed << blnk1.Y[1]
          << setw(8) << setprecision(5) << fixed << blnk1.Z[1]
          << setw(8) << setprecision(5) << fixed << blnk1.XLT << endl;
    goto L200;
L1011:
    if ( abs(blnk1.X[1]-blnk1.Y[1]) < 0.0001 ) goto L120;
    file6 << endl << endl <<  "THE ATOM AT "
          << setw(8) << setprecision(5) << fixed << blnk1.X[1]
          << setw(8) << setprecision(5) << fixed << blnk1.Y[1]
          << setw(8) << setprecision(5) << fixed << blnk1.Z[1]
          << " WAS PUT AT"
          << setw(8) << setprecision(5) << fixed << blnk1.Y[1]
          << setw(8) << setprecision(5) << fixed << blnk1.Z[1]
          << setw(8) << setprecision(5) << fixed << blnk1.X[1] << endl;
    X3 = blnk1.X[1];
    blnk1.X[1] = blnk1.Y[1];
    blnk1.Y[1] = blnk1.Z[1];
    blnk1.Z[1] = X3;
    goto L103;
L102:
    if ( L2 == 1 ) goto L120;
    file6 << endl << endl <<  "THE ATOM AT "
          << setw(8) << setprecision(5) << fixed << blnk1.X[1]
          << setw(8) << setprecision(5) << fixed << blnk1.Y[1]
          << setw(8) << setprecision(5) << fixed << blnk1.Z[1]
          << " WAS PUT AT"
          << setw(8) << setprecision(5) << fixed << blnk1.X[L2]
          << setw(8) << setprecision(5) << fixed << blnk1.Y[L2]
          << setw(8) << setprecision(5) << fixed << blnk1.Z[L2] << endl;
    blnk1.X[1] = blnk1.X[L2];
    blnk1.Y[1] = blnk1.Y[L2];
    blnk1.Z[1] = blnk1.Z[L2];
    goto L103;
L1000:
    file6 << endl << endl << "THE SYMMETRY OPERATOR " << setw(10) << blnk1.NCTR[blnk1.MULTX] << " IS WRONG" << endl;
    exit (EXIT_FAILURE); //  STOP 7701
L2000:
    file6 << endl << endl << "THERE ARE UNRESOLVABLE PROBLEMS WITH THE POSITION SET"
          << setw(8) << setprecision(5) << fixed << blnk1.X[1]
          << setw(8) << setprecision(5) << fixed << blnk1.Y[1]
          << setw(8) << setprecision(5) << fixed << blnk1.Z[1] << endl
          << " ATTEMPTS TO DEFINE THE TRUE SITE SYMMETRY WERE ABANDONED." << endl;
L120:
    if ( abs(blnk1.X[1]-blnk1.Y[1])+abs(blnk1.X[1]-blnk1.Z[1]) <= 0.0002 ) goto L200;
    for(L2=2; L2 <= L1; L2++) if ( abs(blnk1.X[L2]-blnk1.Y[L2])+abs(blnk1.X[L2]-blnk1.Z[L2]) <= 0.0002 ) goto L102;
L130:
L200:
    blnk1.IXB = max( iand(blnk1.IXB,18874367), iand(blnk1.IXB,16777215));
    if (  iand(blnk1.IXB,384) == 384 ) blnk1.IXB= ior(blnk1.IXB,512);
}

void DBWS::ITER()
{
    int IORDLIM2,I, J, K, L,IA, KS[50+1], ciclo,IOF,IPM,LIM,IPREV,IDERIV;
    double X, X1,YY,CSK[99+1], SDK,DYC, OOM,STH, THX, DISK[99+1], CISK, FPOL, DYCDD[99+1],
          VLAST[MSZ+1], TOTAS, TOTCS, TOTDS;


    for(I=1; I <= MSZ; I++) VLAST[I]=0.0;

    //     **** start cycles ****
    for(ciclo=1; ciclo <= mcycle; ciclo++)
    {
        ASSIGN();
        for(I=1; I <= MSZ; I++)
        {
            Fx[I]=0.0;
            for(J=1; J <= MSZ; J++) matrix[I][J]=0.0;
        }
        for(I=1; I <= NATS; I++) atoms[I].ISODER=0;
        g3.NUM=0;
        IPREV=1;
        if (nbckgd == 0)
        {
            g3.TH=THMIN-STEP;
            for(I=1; I <= NPTS; I++)
            {
                g3.TH=g3.TH+STEP;
                THX=g3.TH/BKPOS-1.0;
                BK_[I]=GLB[2];
                for(J=2; J <= 6; J++) BK_[I]=BK_[I]+GLB[J+1]* pow(THX,(J-1));
                if (mcycle == 1 && MAXS == 0 && r_iplpol == 1)BKPOL_[I]=BK_[I];
            }
        }

        g3.TH=THMIN-STEP;

        //           ****** START GREAT LOOP ON NPTS STEP-POINTS ******
        for(IPM=1; IPM <= NPTS; IPM++)
        {
            if ( MOD(IPM,NPTS/80+1) ==  0) cout << ".";

            g3.TH=g3.TH+STEP;

            if (cntrls.IBGD == 1)
            {
                CSK[1] = 1;
                DISK[1] = 1;
                DYCDD[1] = 1;
                atoms[1].ISODER = 1;
                TOTCS  = 1;
            }
            else
            {
                //-----COMPUTE FPOL = POLARIZATION FACTOR FOR THIS IPM POINT
                //     TH  = 2.0 * THETA
                //     STH = SIN(THETA)

                STH = sin( degtorad(2.0 * g3.TH) );

                FPOL = (1.0 + ( pow((1.0 - 2.0 * pow(STH,2)),2) ) * CTHM ) / 2.0;
                if (KR_[IPM] == IRS)
                {
                    // ----IDERIV = 1 MEANS ONLY BACKGROUND (FOR THE STEP-POINTS THAT ARE IN EXCLUDED REGIONS)
                    IDERIV = 1;
                }
                else
                {
                    //-----IDERIV = 2 MEANS BACKGROUND + DERIVATIVES (FOR STEP-POINTS THAT ARE IN INCLUDED REGIONS)
                    IDERIV = 2;
                }
                //-----IF NECESSARY COMPUTE TOTCS :
                //     TOTCS = TOTAL COMPTON INTENSITY SCATTERED BY ALL CRYSTALLINE
                //             PHASES AT THE IPM-TH POINT OF THE X-RAY PATTERN.
                TOTCS = 0.0;
                if ( fondo == 1  ||  fondo == 2 )
                {
                    for(K = 1; K <= nphase; K++)
                    {
                        COMPTON(K,STH,&CISK);
                        CSK[K] = CISK * FPOL;
                        TOTCS = TOTCS + bkgscale.SCABKG[K] * CSK[K];
                    }
                    //-----COMPTON UPDATE
                    if ( mcycle == 1  &&  MAXS == 0  &&  r_iplcom == 1 )  BKCOM_[IPM] = TOTCS;
                    BK_[IPM] = BK_[IPM] + TOTCS;
                }

                //-----IF NECESSARY CALL DIS = SUBROUTINE TO COMPUTE THERMAL AND LATTICE
                //                             DISORDER SCATTERING SDK  AND  DERIVATIVES
                //                             DYC IN THE K-TH PHASE
                //     TOTDS = TOTAL DISORDER SCATTERING
                TOTDS = 0.0;
                if (fondo == 1 || fondo == 2)
                {
                    for(K = 1; K <= nphase; K++)
                    {
                        IOF = 0;
                        if (K > 1)
                        {
                            for(I = 2; I <= K; I++) IOF = IOF + phases[I-1].NATOM;
                        }
                        for(I=1; I <= NATS; I++) atoms[I].DERISO=0;
                        DISORDER(K,STH,IDERIV,&SDK,&DYC,fondo);
                        DISK[K]  =   SDK * FPOL;
                        TOTDS    = TOTDS + bkgscale.SCABKG[K] * DISK[K];
                        //     UPDATING DERIVATE OF ISOTROPIC THERMAL FACTORS
                        if (fondo == 1)
                        {
                            for(I=1; I <= phases[K].NATOM; I++)
                            {
                                atoms[IOF+I].ISODER += bkgscale.SCABKG[K]*FPOL*atoms[IOF+I].DERISO;
                            }
                        }
                        //     UPDATING DERIVATE OF OVERALL THERMAL FACTOR
                        if (fondo == 2) DYCDD[K]=DYC*bkgscale.SCABKG[K]*FPOL;
                    }
                    //-----DISORDER UPDATE
                    if (mcycle == 1  &&  MAXS == 0  &&  r_ipldis == 1 ) BKDIS_[IPM] = TOTDS;
                    BK_[IPM] = BK_[IPM] + TOTDS;
                }


                //------AMORPHOUS EVALUATIONS
                TOTAS =0.0;
                TOTAS = GLB[20] * AMORPHOUS_[IPM];
                //-----AMORPHOUS UPDATE
                if ( mcycle == 1  &&  MAXS == 0  &&  r_iplam == 1 ) BKAM_[IPM] = TOTAS;
                //      if (MCYCLE == 1 && MAXS == 0 && IPLAIR == 1) BKAIR(IPM)=TOTAIR
                //      BK(IPM) = BK(IPM) + TOTAS + TOTAIR
                BK_[IPM] = BK_[IPM] + TOTAS;
            }


            if (KR_[IPM] != IRS )
            {
                g3.IORD1=MOD(KR_[IPM],IRS );
                g3.IORD2=MOD(KR_[IPM]/IRS ,IRS );
                if ( !((g3.IORD2 == 0  ||  g3.IORD1 == 0)  &&  nbckgd != 0) )
                {
                    g3.NUM=g3.NUM+1;
                    IORDLIM2=g3.IORD2;
                    if (IPREV <= IORDLIM2)
                    {
                        for(J=IPREV; J <= IORDLIM2; J++) CALCUL(J);
                    }

                    IPREV=max(IPREV,IORDLIM2+1);

                    SUMMAT(IPM,CSK,DISK,DYCDD,TOTCS);
                }
            }

            //     if (IX == 1) goto 15
            //     if ((IORD2-IORD1) < NOV) goto 15
            //     WRITE (6,1234) IORD2-IORD1,NOV,IPM
            //1234 FORMAT(1X,'NO.OF REFLECTIONS IS ',I4,2X,'AT STEP NO.',I6)
            //     STOP


        }
        cout << ":" << endl;

        if ( jobtyp > 2 ) return;

        for(I=1; I <= MAXS; I++)
        {
            for(J=I; J <= MAXS; J++) matrix[J][I] = matrix[I][J];
        }
        g3.COND = DPINV(MAXS);
        CHISQ();
        OOM=R_S2/double(g3.NUM-MAXS);
        for(I=1; I <= MAXS; I++)
        {
            for(J=1; J <= MAXS; J++) matrix[I][J] = matrix[I][J]*OOM;
        }

        //              CODE TO ATTEMPT TO STABILIZE OSCILLATIONS
        for(I=1; I <= MAXS; I++)
        {
            if (SIGN(1.0,Fx[I]) != SIGN(1.0,VLAST[I]))
            {
                if (abs(Fx[I]) <= 1.2*abs(VLAST[I]))
                {
                    if (abs(Fx[I]) >= 0.8*abs(VLAST[I]))
                    {
                        Fx[I]=Fx[I]/2.0;
                    }
                }
            }
            VLAST[I]=Fx[I];
        }

        OUTPTR(ciclo);
        for(I=1; I <= MAXS; I++)
        {
            X1=sqrt(abs(matrix[I][I]))*EPS;
            if (abs(Fx[I]) > X1)goto L10;
        }
        if (MAXS > 0) file6 << endl << "          ***** EPSED OUT *****" << endl;
        if (MAXS > 0) cntrls.ICYRUN = ciclo;
        goto L20;
L10:
        ;
    }
    //                 ***** END CYCLES *****



L20:
    //        DO 6 I=1,MAXS
    //        DO 6 J=1,MAXS
    //6         RJ(I,J)=RJAC(I,J)
    //     CODE FOR PRINTING CORRELATION MATRIX MOVED FROM EXPUT (65-85)
    if (r_mat == 0 || MAXS == 0) return;
    file6 << endl << endl << "CORRELATION MATRIX=";
    IA=1;
    LIM=19;
L38:
    LIM=min(MAXS,LIM);
    file6 << endl << endl << "    ";
    for(I=IA; I <= LIM; I++) file6 << setw(6) << I;
    file6 << endl;
    for(I=1; I <= MAXS; I++)
    {
        L=0;
        X=matrix[I][I];
        for(J=IA; J <= LIM; J++)
        {
            L=L+1;
            YY=matrix[J][J]*X;
            KS[L]=100.0*matrix[I][J]/(sqrt(abs(YY))*SIGN(1.0,YY))+0.5;
        }
        file6 << setw(5) << I;
        for(J=1; J <= L; J++) file6 << setw(6) << KS[J];
        file6 << endl;
    }
    if (LIM >= MAXS) goto L37;
    IA=LIM+1;
    LIM=LIM+19;
    goto L38;
L37:
    ;
}

void DBWS::RTMT(int IPRT, int IPHASE)
{
    //    THE MATRICES ARE IN THE FIRST THREE ROWS OF VCTR AND THE VECTORS
    //    ARE IN THE FOURTH ROW OF VCTR.
    //    THE MATRICES ARE PACKED INTO IVEC.
    int I, K, IX, IY, IZ;
    double VCTR[3+1][4+1];

    blnk1.X[1] = 2.0/108.0;
    blnk1.Y[1] = 3.0/108.0;
    blnk1.Z[1] = 4.0/108.0;
    SYMOPR();
    spgcom.MULTP = blnk1.MULTX-1;
    multip.MLTPHASE=spgcom.MULTP;
    for(I=1; I <= spgcom.MULTP; I++)
    {
        rtmtx.IVEC[IPHASE][I] = 0;
        for(K=1; K <= 3; K++)
        {
            switch (K) {
            case 1:
                IX = blnk1.X[I]* 108.0 + 0.1;
                break;
            case 2:
                IX = blnk1.Y[I] * 108.0 + 0.1;
                break;
            case 3:
                IX = blnk1.Z[I] * 108.0 + 0.1;
                break;
            default:
                break;
            }

            VCTR[K][4] = double((IX+4)/9)/12.0;
            VCTR[K][4] = AMOD(VCTR[K][4],1.0);
            IY = MOD(IX+4,9)-4;
            IZ = abs(IY);
            switch (IZ) {
            case 1:
                VCTR[K][1] = -1.0*double(ISIGN(1,IY));
                VCTR[K][2] =  1.0*double(ISIGN(1,IY));
                VCTR[K][3] = 0.0;
                break;
            case 2:
                VCTR[K][1] =  1.0*double(ISIGN(1,IY));
                VCTR[K][2] = 0.0;
                VCTR[K][3] = 0.0;
                break;
            case 3:
                VCTR[K][1] = 0.0;
                VCTR[K][2] =  1.0*double(ISIGN(1,IY));
                VCTR[K][3] = 0.00;
                break;
            case 4:
                VCTR[K][1] = 0.0;
                VCTR[K][2] = 0.0;
                VCTR[K][3] = 1.0*double(ISIGN(1,IY));
                break;
            default:
                GOTOER();
                break;
            }
            rtmtx.IVEC[IPHASE][I] = rtmtx.IVEC[IPHASE][I]+(9*(int(VCTR[K][1]+1.5))+3*(int(VCTR[K][2]+1.5))+int(VCTR[K][3]+1.5))*32768*pow(32,(3-K))+(int(VCTR[K][4]*12.0+0.5)+16)*pow(32,(3-K));
        }
        if ( IPRT > 0 )
        {
            if (simoper.ISIMOP != 1)
            {
                if ( MOD(I-1,15) == 0) file6 << endl << "\f" << "The operations of the space group are" << endl; // To next page?
                file6 << endl << endl
                      << " (" << setw(3) << setprecision(0) << fixed << VCTR[1][1] << setw(3) << setprecision(0) << fixed << VCTR[1][2] << setw(3) << setprecision(0) << fixed << VCTR[1][3] << " )    ( X )   ( " << setw(6) << setprecision(3) << VCTR[1][4] << " )    ( X2 )" << endl
                      << " (" << setw(3) << setprecision(0) << fixed << VCTR[2][1] << setw(3) << setprecision(0) << fixed << VCTR[2][2] << setw(3) << setprecision(0) << fixed << VCTR[2][3] << " ) *  ( Y ) + ( " << setw(6) << setprecision(3) << VCTR[2][4] << " ) =  ( Y2  )" << endl
                      << " (" << setw(3) << setprecision(0) << fixed << VCTR[3][1] << setw(3) << setprecision(0) << fixed << VCTR[3][2] << setw(3) << setprecision(0) << fixed << VCTR[3][3] << " )    ( Z )   ( " << setw(6) << setprecision(3) << VCTR[3][4] << " )    ( Z2 )          IVEC(" << setw(3) << I << ") =" << setw(15) << rtmtx.IVEC[IPHASE][I] << endl;
            }
        }
    }
    rtmtx.MLTPHS[IPHASE]=spgcom.MULTP;
    rtmtx.ICNTPHS[IPHASE]=1;
    if ( spgcom.NC == 0 ) rtmtx.ICNTPHS[IPHASE]=2;
}

void DBWS::OP1(int IPHASE)
{
    //                             THIS SR GENERATES THE OPERATORS FOR
    //                           SMTRY2, DETERMINES THE POLARITY OF THE SPACE
    //                           GROUP, NOTES THE PRESENCE OF A CENTER(1BAR),
    //                           AND GENERATES A SET OF PSEUDO-OPERATORS FOR
    //                           USE IN SYMOPR TO DEFINE SITE SYMMETRY.
    int I, J, K, L, N2;

    K = 2;
    spgcom.NPOL = 7;
    for(I=1; I <= 7; I++) hklctl.NC1[1][I][IPHASE] = 0;
    blnk1.NCTR[1] = 0;
    for(I=1; I <= 8; I++)
    {
        if ( spgcom.NCONT[I] <= 0 ) goto L101;
        if ( spgcom.NCONT[I] < 8192 ) goto L80;
        if ( spgcom.NCONT[I] <= 8192 ) goto L60; // ?????????? if ( NCONT[I] >= 08192 ) goto L60;
        if ( spgcom.NCONT[I] == 16384 ) goto L70;
        spgcom.NPOL = 4;
        hklctl.NC1[I][1][IPHASE] = 2;
L50:
        for(J=2; J <= 7; J++) hklctl.NC1[I][J][IPHASE] = 0;
        hklctl.NC1[I][6][IPHASE] = MOD(spgcom.NCONT[I]/4,32);
        goto L90;
L60:
        hklctl.NC1[I][1][IPHASE] = 3;
        spgcom.NPOL = 1;
        goto L50;
L70:
        hklctl.NC1[I][1][IPHASE] = 1;
        goto L50;
L80:
        hklctl.NC1[I][1][IPHASE] = 0;
        hklctl.NC1[I][2][IPHASE] = MOD(spgcom.NCONT[I],4);
        hklctl.NC1[I][3][IPHASE] = MOD(spgcom.NCONT[I]/4,4);
        hklctl.NC1[I][4][IPHASE] = MOD(spgcom.NCONT[I]/16,4);
        hklctl.NC1[I][5][IPHASE] = MOD(spgcom.NCONT[I]/64,4);
        hklctl.NC1[I][6][IPHASE] = MOD(spgcom.NCONT[I]/256,2);
        hklctl.NC1[I][7][IPHASE] = MOD(spgcom.NCONT[I]/512,16);
L90:
        L = K-1;
        for(J=1; J <= L; J++)
        {
            if ( spgcom.NCONT[I] == 8192 ) goto L95;
            blnk1.NCTR[K] = iand( ieor(spgcom.NCONT[I],blnk1.NCTR[J]),57651);
            if ( iand(spgcom.NCONT[I],17) == 0) goto L92;
            if ( iand(blnk1.NCTR[J],34) == 0) goto L92;
            if ( iand(blnk1.NCTR[J],34) == 34) goto L92;
            blnk1.NCTR[K]= ieor(blnk1.NCTR[K],34);
L92:
            K = K+1;
            if ( spgcom.NCONT[I] < 8192 ) goto L100;
            blnk1.NCTR[K] = blnk1.NCTR[K-1]+32768;
            K = K+1;
            goto L100;
L95:
            blnk1.NCTR[K] = 0;
            blnk1.NCTR[K+1] = 0;
            K = K+2;
L100:
            ;
        }
    }
L101:
    spgcom.MULTP = K-1;
    hklctl.N1HKL[IPHASE] = I-1;
    if ( hklctl.N1HKL[IPHASE] < 2 ) goto L105;
    for(N2=2; N2 <= hklctl.N1HKL[IPHASE]; N2++)
    {
        if ( hklctl.NC1[N2-1][1][IPHASE] == 1 ) goto L103;
    }
    goto L105;
L103:
    for(I=N2; I <= hklctl.N1HKL[IPHASE]; I++)
    {
        for(J=1; J <= 7; J++) hklctl.NC1[I-1][J][IPHASE] = hklctl.NC1[I][J][IPHASE];
    }
    hklctl.NC1[hklctl.N1HKL[IPHASE]][1][IPHASE] = 1;
L105:
    spgcom.NC = 1;
    for(I=1; I <= spgcom.MULTP; I++)
    {
        if ( ieor(blnk1.NCTR[I],290) == 0 ) spgcom.NC = 0;
        if ( iand(blnk1.NCTR[I],3) > 0 ) spgcom.NPOL = iand(spgcom.NPOL,6);
        if ( iand(blnk1.NCTR[I],48) > 0 ) spgcom.NPOL = iand(spgcom.NPOL,5);
        if ( iand(blnk1.NCTR[I],256) > 0 ) spgcom.NPOL = iand(spgcom.NPOL,3);
    }
}

void DBWS::LOOKUP(int K, int N, int NSCAT, int IXRAY, int JOB)
{
    int I, J, L, NS, IOF, IJI, NSL, IIPHAS, TBXPTR;

    IOF=0;
    NS=0;
    if (K > 1)
    {
        for(IIPHAS=2; IIPHAS <= K; IIPHAS++) IOF = IOF + phases[IIPHAS-1].NATOM;
    }
    if (K > 1)NS=dc.NSAVE;
    if (JOB == 2 || JOB == 4)goto L70;
    for(I=1; I <= N; I++)
    {
        NS=max(NSCAT,NS);
        for(J=1; J <= NS; J++) if (atoms[I+IOF].NTYP == NAM_[J])goto L30;
        for(J=1; J <= 212; J++) if (atoms[I+IOF].NTYP == TBXC[J])goto L50;
        file6 << " SCATTERING COEFFICIENTS NOT FOUND FOR " << atoms[I+IOF].NTYP << endl;
        cout << " SCATTERING DATA MISSING" << endl;
        exit(EXIT_FAILURE);
L30:
        atoms[I+IOF].PTR=J;
        goto L10;
L50:
        NS=NS+1;
        atoms[I+IOF].PTR=NS;
        for(L=1; L <= 9; L++) AC_[L][NS]=TBX[J][L];
        NAM_[NS]=TBXC[J];
        TBXPTR=TBX[J][10]+0.5;
        DFP[NS]=TBD[TBXPTR][IXRAY];
        //      DFPP(NS)=TBD(TBXPTR,IXRAY+5) !To 10 wavelenghts (june 98)
        DFPP[NS]=TBD[TBXPTR][IXRAY+10];
        //      XMAS(NS)=TBM(TBXPTR+1)       !To 10 wavelenghts (june 98)
        XMAS[NS]=TBM[TBXPTR];
        // TO CHECK THE  DFP, DFPP AND MASS VALUES (drx), UNCOMMENT THE LINES BELOW
        //      WRITE(*,9752)NAm(NS),DFP(NS),DFPP(NS), XMAS(NS),lamda(1)
        file6 << " ATOM =" << NAM_[NS] << " dfp,dfpp="
              << setw(10) << setprecision(5) << fixed << DFP[NS] << " "
              << setw(10) << setprecision(5) << fixed << DFPP[NS] << " "
              << " MASS=" << setw(8) << setprecision(3) << fixed << XMAS[NS]
              << "  Wlenght:"  << setw(8) << setprecision(6) << fixed << LAMDA[1] << endl;
        //      WRITE(*,9751) (AC(IJI,NS),IJI=1,9)
        file6 << " Scat Coef.=";
        for(IJI=1; IJI <= 9; IJI++)
        {
            file6 << setw(9) << setprecision(5) << fixed << AC_[IJI][NS] << " ";
        }
        // END OF CHECKING THE VALUES (drx)
L10:
        ;
    }
    dc.NSAVE=NS;
    return;
L70:
    for(I=1; I <= N; I++)
    {
        NS=max(NSCAT,NS);
        for(J=1; J <= NS; J++) if (atoms[I+IOF].NTYP == NAM_[J])goto L100;
        for(J=1; J <= 85; J++) if (atoms[I+IOF].NTYP == TABNC[J])goto L120;
        file6 << "SCATTERING LENGTHS NOT FOUND FOR " << atoms[I+IOF].NTYP << endl;
        cout << " SCATTERING DATA MISSING" << endl;
        exit(EXIT_FAILURE);
L100:
        atoms[I+IOF].PTR=J;
        goto L80;
L120:
        NS=NS+1;
        atoms[I+IOF].PTR=NS;
        DFP[NS]=TABN[J];
        NAM_[NS]=TABNC[J];
        if (J >= 61 && J <= 81) goto L81;
        if (J == 82) goto L82;
        if (J >= 83 && J <= 85) goto L83;
        goto L84;
L81:
        NSL = J+2;
        goto L180;
L82:
        NSL = 90;
        goto L180;
L83:
        NSL = J+9;
        goto L180;
L84:
        NSL = J;
L180:
        XMAS[NS]=TBM[NSL];
L80:
        ;
    }
    dc.NSAVE=NS;
}

void DBWS::CELL2(int NPHASE, double LAMDAM)
{
    string LAU[14+1] = {"",
                        "1BAR","2/M","MMM","4/M","4/MMM","3BAR   R","3BAR M R","3BAR",
                        "3BAR M 1","3BAR 1 M","6/M","6/MMM","M3","M3M"
                       };

    double COSA, COSB, COSC, SINA, SINB, SINC,COSASR, COSBSR, COSCSR,SINASR, SINBSR;

    file6 << endl << endl << "THE LAUE SYMMETRY IS " << LAU[spgcom.NSPGRP] << endl;
    if ( spgcom.NAXIS > 3 )
    {
        cout << "5001" << endl;
        exit(EXIT_FAILURE);
    }
    switch (spgcom.NSPGRP) {
    case 1:
        goto L1002;
        break;
    case 2:
        goto L1071;
        break;
    case 3:
        goto L1072;
        break;
    case 4:
        goto L1073;
        break;
    case 5:
        goto L1073;
        break;
    case 6:
        goto L1074;
        break;
    case 7:
        goto L1074;
        break;
    case 8:
        goto L1075;
        break;
    case 9:
        goto L1075;
        break;
    case 10:
        goto L1075;
        break;
    case 11:
        goto L1075;
        break;
    case 12:
        goto L1075;
        break;
    case 13:
        goto L1076;
        break;
    case 14:
        goto L1076;
        break;
    }
    GOTOER();
L1071:
    if ( spgcom.NAXIS != 1 ) cellx.alpha=90.0;
    if ( spgcom.NAXIS != 2 ) cellx.beta=90.0;
    if ( spgcom.NAXIS != 3 ) cellx.gamma=90.0;
    goto L1002;
L1073:
    cellx.b = cellx.a;
L1072:
    cellx.alpha = 90.0;
    cellx.beta = 90.0;
    cellx.gamma = 90.0;
    goto L1002;
L1074:
    cellx.b = cellx.a;
    cellx.c = cellx.a;
    cellx.beta = cellx.alpha;
    cellx.gamma = cellx.alpha;
    goto L1002;
L1075:
    cellx.b = cellx.a;
    cellx.alpha = 90.;
    cellx.beta = 90.0;
    cellx.gamma = 120.0;
    goto L1002;
L1076:
    cellx.b = cellx.a;
    cellx.c = cellx.a;
    goto L1072;
L1002:
    COSA = cos((cellx.alpha/360.0)*6.28318531);
L105:
    COSB = cos((cellx.beta/360.0)*6.28318531);
L1052:
    COSC = cos((cellx.gamma/360.0)*6.28318531);
L1053:
    SINA=sqrt(1.0-pow(COSA,2));
    SINB=sqrt(1.0-pow(COSB,2));
    SINC=sqrt(1.0-pow(COSC,2));

    //-----THE VOLUME OF THE CELL IN THE DIRECT SPACE OF THE REAL CELL OF
    //-----THE K-TH PHASE=NPHASE IS CALCULATED
    //-----AND THE RAY GMAX OF THE SPHERE WITH THE VOLUME EQUIVALENT TO THE
    //-----BRILLOUIN CELL 4/3*PI*GMAX**3=1/VOL

    volume.VOLI[NPHASE] = cellx.a * cellx.b * cellx.c * sqrt(1.0 - pow(COSA,2) - pow(COSB,2) - pow(COSC,2) + 2.0 * COSA * COSB * COSC );
    //
    volume.GCOM[NPHASE] = 0.877298169 * volume.VOLI[NPHASE] / pow(LAMDAM,3);
    //
    COSASR=(COSB*COSC-COSA)/(SINB*SINC);
    COSBSR=(COSA*COSC-COSB)/(SINA*SINC);
    COSCSR=(COSA*COSB-COSC)/(SINA*SINB);
    SINASR=sqrt(1.0-pow(COSASR,2));
    SINBSR=sqrt(1.0-pow(COSBSR,2));
    cellx.AL[1][1]=1.0/( cellx.a * SINC*SINBSR);
    cellx.AL[2][2]=1.0/( cellx.b * SINC*SINASR);
    cellx.AL[3][3]=1.0/( cellx.c * SINA*SINBSR);
    cellx.AL[2][3]=cellx.AL[2][2]*cellx.AL[3][3]*COSASR*2.0;
    cellx.AL[1][3]=cellx.AL[3][3]*cellx.AL[1][1]*COSBSR*2.0;
    cellx.AL[1][2]=cellx.AL[2][2]*cellx.AL[1][1]*COSCSR*2.0;
    cellx.AL[1][1]=cellx.AL[1][1]*cellx.AL[1][1];
    cellx.AL[2][2]=cellx.AL[2][2]*cellx.AL[2][2];
    cellx.AL[3][3]=cellx.AL[3][3]*cellx.AL[3][3];
}

double DBWS::MULT(int IH,int IK,int IL,int KXIS)
{
    double P;

    P = 2.0;
    switch (spgcom.NSPGRP) {
    case 1:
        goto L220;
        break;
    case 2:
        goto L100;
        break;
    case 3:
        goto L110;
        break;
    case 4:
        goto L120;
        break;
    case 5:
        goto L130;
        break;
    case 6:
        goto L150;
        break;
    case 7:
        goto L180;
        break;
    case 8:
        goto L140;
        break;
    case 9:
        goto L170;
        break;
    case 10:
        goto L160;
        break;
    case 11:
        goto L170;
        break;
    case 12:
        goto L190;
        break;
    case 13:
        goto L200;
        break;
    case 14:
        goto L210;
        break;
    }
    GOTOER();
L100:
    if ( IH <= 0 ) {
        goto L220;
    }
    else {
        goto L101;
    }
L101:
    if ( KXIS == 3 )
    {
        if ( IL > 0  &&  IH+abs(IK) > 0 ) P=2.0*P;
    }
    else
    {
        if ( IK > 0  &&  IH+abs(IL) > 0 ) P=2.0*P;
    }
    goto L220;
L110:
    P = 1.0;
    if ( IH <= 0 ) {
        goto L112;
    }
    else {
        goto L111;
    }
L111:
    P = 2.0*P;
L112:
    if ( IK <= 0 ) {
        goto L114;
    }
    else {
        goto L113;
    }
L113:
    P = 2.0*P;
L114:
    if ( IL <= 0 ) {
        goto L220;
    }
    else {
        goto L115;
    }
L115:
    P = 2.0*P;
    goto L220;
L120:
    if ( IK <= 0 ) {
        goto L220;
    }
    else {
        goto L121;
    }
L121:
    P = 2.0*P;
    if ( IL <= 0 ) {
        goto L220;
    }
    else {
        goto L122;
    }
L122:
    P = 2.0*P;
    goto L220;
L130:
    if ( IK <= 0 ) {
        goto L220;
    }
    else {
        goto L131;
    }
L131:
    P = 2.0*P;
    if ( IH <= 0 ) {
        goto L134;
    }
    else {
        goto L132;
    }
L132:
    if ( IH-IK < 0 ) {
        goto L133;
    }
    else {
        goto L134;
    }
L133:
    P = 2.0*P;
L134:
    if ( IL <= 0 ) {
        goto L220;
    }
    else {
        goto L135;
    }
L135:
    P = 2.0*P;
    goto L220;
L140:
    if ( IH+abs(IK) <= 0 ) {
        goto L142;
    }
    else {
        goto L141;
    }
L141:
    P = 3.0*P;
L142:
    if ( IL <= 0 ) {
        goto L220;
    }
    else {
        goto L143;
    }
L143:
    P = 2.0*P;
    goto L220;
L150:
    if ( IH+IK+IL == 0 ) {
        goto L152;
    }
    else {
        goto L151;
    }
L151:
    P = 2.0*P;
L152:
    if ( IH-IK == 0) {
        goto L154;
    }
    else {
        goto L153;
    }
L153:
    P = 3.0*P;
    goto L220;
L154:
    if ( IH-IL == 0 ) {
        goto L220;
    }
    else {
        goto L153;
    }
L160:
    if ( IK <= 0 ) {
        goto L220;
    }
    else {
        goto L161;
    }
L161:
    P = 3.0*P;
    if ( IK-IH <= 0 ) {
        goto L220;
    }
    else {
        goto L162;
    }
L162:
    if ( IH <= 0 ) {
        goto L220;
    }
    else {
        goto L135;
    }
L170:
    if ( IL <= 0 ) {
        goto L172;
    }
    else {
        goto L171;
    }
L171:
    P = 2.0*P;
L172:
    if ( IH <= 0 ) {
        goto L174;
    }
    else {
        goto L173;
    }
L173:
    P = 3.0*P;
    if ( IK <= 0 ) {
        goto L220;
    }
    else {
        goto L135;
    }
L174:
    if ( IK <= 0 ) {
        goto L220;
    }
    else {
        goto L153;
    }
L180:
    if ( IH-IK == 0 ) {
        goto L181;
    }
    else {
        goto L182;
    }
L181:
    if ( IH-IL == 0 ) {
        goto L220;
    }
    else {
        goto L183;
    }
L182:
    if ( IK-IL == 0 ) {
        goto L183;
    }
    else {
        goto L184;
    }
L183:
    P = P/2.0;
L184:
    P = 3.0*P;
    if ( IH+IK+IL == 0 ) {
        goto L220;
    }
    else {
        goto L135;
    }
L190:
    if ( IK <= 0 ) {
        goto L194;
    }
    else {
        goto L191;
    }
L191:
    P = 6.0*P;
    if ( IH == 0 ) {
        goto L194;
    }
    else {
        goto L192;
    }
L192:
    if ( IK-IH == 0 ) {
        goto L194;
    }
    else {
        goto L193;
    }
L193:
    P = 2.0*P;
L194:
    if ( IL == 0 ) {
        goto L220;
    }
    else {
        goto L135;
    }
L200:
    if ( IH-IK == 0 ) {
        goto L201;
    }
    else {
        goto L203;
    }
L201:
    if ( IK-IL == 0 ) {
        goto L202;
    }
    else {
        goto L203;
    }
L202:
    P = 4.0*P;
    goto L220;
L203:
    P = 3.0*P;
    if ( IK <= 0 ) {
        goto L205;
    }
    else {
        goto L204;
    }
L204:
    P = 2.0*P;
L205:
    if ( IH <= 0) {
        goto L220;
    }
    else {
        goto L135;
    }
L210:
    if ( IH == 0) {
        goto L214;
    }
    else {
        goto L211;
    }
L211:
    P = 4.0*P;
    if ( IH-IL == 0 ) {
        goto L220;
    }
    else {
        goto L212;
    }
L212:
    P = 3.0*P;
    if ( IH-IK == 0 ) {
        goto L220;
    }
    else {
        goto L213;
    }
L213:
    if ( IK-IL == 0 ) {
        goto L220;
    }
    else {
        goto L135;
    }
L214:
    P = 3.0*P;
    if ( IK == 0 ) {
        goto L220;
    }
    else {
        goto L215;
    }
L215:
    P = 2.0*P;
    if ( IK-IL == 0 ) {
        goto L220;
    }
    else {
        goto L135;
    }
    //-----THIS LINE ADDED TO CORRECT THE PROBLEMS WITH THE -3, -3M1, 6/M,
    //-----AND 6/MMM SPACE GROUPS THAT WERE OFF BY A FACTOR OF TWO
L220:
    if (spgcom.NSPGRP == 8  ||  spgcom.NSPGRP == 9  ||  spgcom.NSPGRP == 11  || spgcom.NSPGRP == 12) P=0.5*P;
    return  P;
}

void DBWS::REWRIT(int ISCALE, int IDIF)
{
    string s;
    int I, J, K, N, IOF, ISOF, IIPHAS;

    if (file5.is_open()) file5.close();
    file5.open(namefile5, ios::out);

    // line 1
    file5 << title << endl;

    jobtyp=jobtyp-1;
    nprof=nprof-1;
    instrm = instrm-1;

    // line 2.1
    file5 << setw(4) << jobtyp
          << setw(4) << nprof
          << setw(4) << nphase
          << setw(4) << codebck.IBCKCODE
          << setw(4) << nexcrg
          << setw(4) << nscat
          << setw(4) << instrm
          << setw(4) << ipref
          << setw(4) <<iasym
          << setw(4) << iabsr
          << setw(4) << idata
          << "             LINE 2.2" << endl;

    // line 2.2
    if (codebck.IBCKCODE == -1)
    {
        file5 << setw(4) << ias
              << setw(4) << fondo
              << "                                                 LINE 2.2" << endl;
    }

    // line 3
    file5 << setw(1) << r_iot
          << setw(1) << r_ipl
          << setw(1) <<r_ipc
          << setw(1) << r_mat
          << setw(1) << r_nxt
          << " "
          << setw(1) << r_lst1
          << setw(1) << r_lst2
          << setw(1) << r_lst3
          << setw(1) << r_ipl1
          << setw(1) << r_ipl2
          << " "
          << setw(1) << r_iplst
          << setw(1) << r_iploss
          << setw(1) << r_iplcal
          << setw(1) << r_iplpol
          << setw(1) << r_iplcom
          << " "
          << setw(1) << r_ipldis
          << setw(1) << r_iplam
          << setw(1) << r_ipbig
          << "                                    LINE 3" << endl;

    // line 4
    file5 << setw(8) << setprecision(5) << fixed << LAMDA[1]
          << setw(8) << setprecision(5) << fixed << LAMDA[2]
          << setw(8) << setprecision(5) << fixed << RATIO[2]
          << setw(8) << setprecision(4) << fixed << BKPOS
          << setw(8) << setprecision(4) << fixed << WDT
          << setw(8) << setprecision(4) << fixed << CTHM
          << setw(8) << setprecision(4) << fixed << TMV
          << setw(8) << setprecision(4) << fixed << RLIM
          << setw(8) << setprecision(4) << fixed << SW << endl;

    // line 5
    file5 << setw(4) << mcycle
          << setw(4) << setprecision(4) << fixed << EPS
          << setw(4) << setprecision(4) << fixed << RELAX[1]
          << setw(4) << setprecision(4) << fixed << RELAX[2]
          << setw(4) << setprecision(4) << fixed << RELAX[3]
          << setw(4) << setprecision(4) << fixed << RELAX[4]
          << "                                 CYCLS EPS RELAX P_CALC" << endl;

    if (nbckgd < 2)goto L120;
    // line 6(*)
    for (I = 1; I <= nbckgd; ++I)
    {
        file5 << setw(8) << setprecision(2) << fixed << POS_[I]
              << setw(8) << setprecision(2) << fixed << BCK_[I] << endl;
    }

L120:
    if (nexcrg <= 0)goto L122;

    // line 7(*)
    for (I = 1; I <= nexcrg; ++I)
    {
        file5 << setw(8) << setprecision(2) << fixed << ALOW[I]
              << setw(8) << setprecision(2) << fixed << AHIGH[I]
              << "                                         EXCLUDED REGION" << endl;
    }

L122:
    if (nscat <= 0)goto L124;
    for(I=1; I <= nscat; I++)
    {
        if (jobtyp  ==  1 || jobtyp == 3) goto L1228;
        // line 8.1 XRD (*)
        file5 << NAM_[I]
              << setw(8) << setprecision(4) << fixed << DFP[I]
              << setw(8) << setprecision(4) << fixed << DFPP[I]
              << setw(8) << setprecision(4) << fixed << XMAS[I]
              << "                             SCATTERING SET " << setw(2) << nscat << endl;
        goto L126;
        // line 8.1 ND(*)
L1228:
        file5 << NAM_[I]
              << setw(8) << setprecision(4) << fixed << DFP[I]
              << setw(8) << setprecision(4) << fixed << XMAS[I]
              << "                             SCATTERING SET " << setw(2) << nscat << endl;
        // line 8.2 XRD(*)
L126:
        if (jobtyp == 0 || jobtyp == 2)
        {
            for (J = 1; J <= 9; ++J) file5 << AC_[J][I];
            file5 << endl;
        }
L125:
        ;
    }
L124:
    ;

    // line 9
    file5 << setw(8) << MAXS << "                                                 PARAMS REFINED" << endl;
    N=0;
    for(IIPHAS=1; IIPHAS <= nphase; IIPHAS++) N=N+phases[IIPHAS].NATOM;
    for(I=1; I <= N; I++)
    {
        for(J=1; J <= 11; J++) atoms[I].AtomPAR[J].codeword=SIGN(1.0,atoms[I].AtomPAR[J].codeword)*(double(10*atoms[I].AtomPAR[J].codeword.L)+abs(atoms[I].AtomPAR[J].codeword));
    }
    for(I=1; I <= nphase; I++)
    {
        for(J=1; J <= 6; J++) phases[I].PAR[J+5]=dc.SAVE[I][J];
        for(J=1; J <= 27; J++) phases[I].PAR[J].codeword=SIGN(1.0,phases[I].PAR[J].codeword)*(double(10*phases[I].PAR[J].codeword.L)+abs(phases[I].PAR[J].codeword));
    }
    for(J=1; J <= 20; J++) GLB[J].codeword=SIGN(1.0,GLB[J].codeword)*(double(10*GLB[J].codeword.L)+abs(GLB[J].codeword));

    // line 10.1
    file5 << setw(8) << setprecision(4) << fixed << GLB[1]
          << setw(8) << setprecision(4) << fixed << GLB[10]
          << setw(8) << setprecision(4) << fixed << GLB[11]
          << setw(8) << setprecision(4) << fixed << GLB[8]
          << setw(8) << setprecision(4) << fixed << GLB[9]
          << setw(8) << setprecision(4) << fixed << GLB[12]
          << setw(8) << setprecision(4) << fixed << GLB[13]
          << " ZER DISP TRANS p q r t" << endl;

    // line 10.11
    file5 << setw(8) << setprecision(4) << fixed << GLB[1].codeword
          << setw(8) << setprecision(4) << fixed << GLB[10].codeword
          << setw(8) << setprecision(4) << fixed << GLB[11].codeword
          << setw(8) << setprecision(4) << fixed << GLB[8].codeword
          << setw(8) << setprecision(4) << fixed << GLB[9].codeword
          << setw(8) << setprecision(4) << fixed << GLB[12].codeword
          << setw(8) << setprecision(4) << fixed << GLB[13].codeword
          << " CODEWORDS" << endl;

    if (cntrls.IBGD == 1) goto L4600;
    //      if (iax == 0) then
    // line 10.2
    file5 << setw(8) << setprecision(4) << fixed << GLB[20]
          << setw(8) << setprecision(4) << fixed << GLB[18]
          << setw(8) << setprecision(4) << fixed << GLB[19]
          << "                                 AM MON1 MON2" << endl;

    // line 10.21
    file5 << setw(8) << setprecision(4) << fixed << GLB[20].codeword
          << setw(8) << setprecision(4) << fixed << GLB[18].codeword
          << setw(8) << setprecision(4) << fixed << GLB[19].codeword
          << "                                 CODEWORS" << endl;

L4600:
    if (nbckgd == 0)
    {
        file5 << setw(9) << setprecision(2) << fixed << GLB[2]
              << setw(9) << setprecision(2) << fixed << GLB[3]
              << setw(9) << setprecision(2) << fixed << GLB[4]
              << setw(9) << setprecision(2) << fixed << GLB[5]
              << setw(9) << setprecision(2) << fixed << GLB[6]
              << setw(9) << setprecision(2) << fixed << GLB[7]
              << "   BACKGROUND" << endl;
        file5 << setw(9) << setprecision(4) << fixed << GLB[2].codeword
              << setw(9) << setprecision(4) << fixed << GLB[3].codeword
              << setw(9) << setprecision(4) << fixed << GLB[4].codeword
              << setw(9) << setprecision(4) << fixed << GLB[5].codeword
              << setw(9) << setprecision(4) << fixed << GLB[6].codeword
              << setw(9) << setprecision(4) << fixed << GLB[7].codeword
              << "   CODEWORDS" << endl;
    }
L477:
    for(K=1; K <= nphase; K++)
    {
        IOF=0;
        if (K > 1)
        {
            for(IIPHAS=2; IIPHAS <= K; IIPHAS++) IOF = IOF + phases[IIPHAS-1].NATOM;
        }
        // line 11.1
        file5 <<  phases[K].name << "       PHASE NUMBER" << setw(2) << K << endl;

        // line 11-2
        file5 << setw(4) << phases[K].NATOM
              << setw(4) << phases[K].NMOL
              << setw(8) << setprecision(4) << fixed << phases[K].SAQF
              << setw(4) << setprecision(2) << fixed << phases[K].PREF[1]
              << setw(4) << setprecision(2) << fixed << phases[K].PREF[2]
              << setw(4) << setprecision(2) << fixed << phases[K].PREF[3]
              << "                             #ATMS #FU AFQPA PREFDIR" << endl;

        N=phases[K].NATOM;

        // line 11-3
        file5 <<  phases[K].SpaceGroup << "                                     SPACE GROUP" << endl;
        // Changing N to 'so'
        for(ISOF=1; ISOF <= N; ISOF++) atoms[ISOF+IOF].AtomPAR[5]=atoms[ISOF+IOF].AtomPAR[5]*multip.XMLTP[K]/atoms[ISOF+IOF].MURT;
        for (I = 1; I <= N; ++I)
        {
            file5 << atoms[I + IOF].ATEXT << " " << setw(4) << atoms[I + IOF].MURT << " "
                  << atoms[I+IOF].NTYP << "  "
                  << setw(8) << setprecision(5) << fixed << atoms[I + IOF].AtomPAR[1]
                  << setw(8) << setprecision(5) << fixed << atoms[I + IOF].AtomPAR[2]
                  << setw(8) << setprecision(5) << fixed << atoms[I + IOF].AtomPAR[3]
                  << setw(8) << setprecision(5) << fixed << atoms[I + IOF].AtomPAR[4]
                  << setw(8) << setprecision(5) << fixed << atoms[I+IOF].AtomPAR[5]
                  << "  At M At x y z B So" << endl
                  << "                "
                  << setw(8) << setprecision(2) << fixed << atoms[I + IOF].AtomPAR[1].codeword
                  << setw(8) << setprecision(2) << fixed << atoms[I + IOF].AtomPAR[2].codeword
                  << setw(8) << setprecision(2) << fixed << atoms[I + IOF].AtomPAR[3].codeword
                  << setw(8) << setprecision(2) << fixed << atoms[I + IOF].AtomPAR[4].codeword
                  << setw(8) << setprecision(2) << fixed << atoms[I+IOF].AtomPAR[5].codeword
                  << "  CODEWORDS" << endl
                  << setw(8) << setprecision(5) << fixed << atoms[I + IOF].AtomPAR[6]
                  << setw(8) << setprecision(5) << fixed << atoms[I + IOF].AtomPAR[7]
                  << setw(8) << setprecision(5) << fixed << atoms[I + IOF].AtomPAR[8]
                  << setw(8) << setprecision(5) << fixed << atoms[I + IOF].AtomPAR[9]
                  << setw(8) << setprecision(5) << fixed << atoms[I + IOF].AtomPAR[11]
                  << setw(8) << setprecision(5) << fixed << atoms[I + IOF].AtomPAR[11]
                  << "          BETAS" << endl
                  << setw(8) << setprecision(2) << fixed << atoms[I + IOF].AtomPAR[6].codeword
                  << setw(8) << setprecision(2) << fixed << atoms[I + IOF].AtomPAR[7].codeword
                  << setw(8) << setprecision(2) << fixed << atoms[I + IOF].AtomPAR[8].codeword
                  << setw(8) << setprecision(2) << fixed << atoms[I + IOF].AtomPAR[9].codeword
                  << setw(8) << setprecision(2) << fixed << atoms[I + IOF].AtomPAR[10].codeword
                  << setw(8) << setprecision(2) << fixed << atoms[I + IOF].AtomPAR[11].codeword
                  << "          CODEWORDS" << endl;
        }

        file5 << setw(8) << setprecision(3) << scientific << phases[K].PAR[1]
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[2]
              << "                                         SCALE Bo(OVERALL)" << endl
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[1].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[2].codeword
              << endl
              << setw(8) << setprecision(5) << fixed << phases[K].PAR[3]
              << setw(8) << setprecision(5) << fixed << phases[K].PAR[4]
              << setw(8) << setprecision(5) << fixed << phases[K].PAR[5]
              << setw(8) << setprecision(5) << fixed << phases[K].PAR[21]
              << setw(8) << setprecision(5) << fixed << phases[K].PAR[20]
              << setw(8) << setprecision(5) << fixed << phases[K].PAR[15]
              << setw(8) << setprecision(5) << fixed << phases[K].PAR[16]
              << " U V W CT Z X Y" << endl
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[3].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[4].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[5].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[21].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[20].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[15].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[16].codeword
              << endl
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[6]
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[7]
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[8]
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[9]
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[10]
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[11]
              << "         CELL PARAMETERS" << endl
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[6].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[7].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[8].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[9].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[10].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[11].codeword
              << endl
              << setw(8) << setprecision(5) << fixed << phases[K].PAR[12]
              << setw(8) << setprecision(5) << fixed << phases[K].PAR[13]
              << setw(8) << setprecision(5) << fixed << phases[K].PAR[14]
              << "                                 PREF1 PREF2 R/RCF_ASYM" << endl
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[12].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[13].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[14].codeword
              << endl
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[17]
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[18]
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[19]
              << "                                 NA NB NC (MIX_PARAMS)" << endl
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[17].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[18].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[19].codeword
              << endl
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[24]
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[25]
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[26]
              << "                                 NA NB NC (HIGH SIDE)" << endl
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[24].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[25].codeword
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[26].codeword
              << endl
              << setw(8) << setprecision(4) << fixed << phases[K].PAR[27]
              << "                                                 PEARSON ASYM.FACTOR" << endl
              << setw(8) << setprecision(2) << fixed << phases[K].PAR[27].codeword
              << endl;
    }

    if (r_ipl != 0) file5 << setw(8) << ISCALE << setw(8) << IDIF << "                                         LINE PRINTER INFO" << endl;
l151:
    jobtyp=jobtyp+1;
}

void DBWS::EXPUT()
{
    const char ISPACE = ' ';
    const char IDOT = '.';
    const char ISTAR = '*';
    const char IPLUS = '+';
    const char IMINUS = '0';
    const char IBAR = '-';


    string s;
    string line;

    int I, J, K, N,J20, KI[10+1], JJ, IX, IS,NP, IY, ICZ, MIN, MAX, IXX,
        IDIF, J20IK, IEXC,NCOL,IXXX,NLINES,NCOL1,NPTS2, LABEL[12+1],INUMB,ISCALE,IIPHAS, NPAGES,ISTART,IFINIS,L;
    double Z, BB,TH, HW,YX, TH2, DEL[10+1], RAD,ZER,TLG, TLL, TIC,RMIN, RMAX,XXXX, T2OBS, AFCAL, BFCAL,
          OMEGA, TFCAL, AFOBS, BFOBS,TDOBS, RFDNR, RFNMR, SHIFT, TIOBS, TFOBS,TLABEL,DUMMY[2*MSZ+1 +1];
    string IOUT;
    bool VERT;
    IOUT=string(150+1,ISPACE);
    FileRIT rit;

    if (r_nxt == 0 || jobtyp >= 3) nprof=nprof-1;
    RAD = 45.0/atan(1.0);
    ZER = GLB[1];
    if (r_ipl != 0)
    {
        getline(file5,s);
        ISCALE = stoi(s.substr(0,8));
        IDIF   = stoi(s.substr(8,8));
    }
    //10000 if (IPL2 != 0)READ(5,17,END=10001)IFY,IFYC,IFM,IFD,IFB,EXPAND
    //10000 if (JOBTYP > 2)IFY=0
    //      if (JOBTYP > 2)IFD=0
    //17    FORMAT(BZ,5I1,3X,F8.0)
L10000:
    if (r_nxt != 0 && jobtyp < 3)
    {
        //        CALL REWRIT(ISCALE,IDIF,IFY,IFYC,IFM,IFD,IFB,EXPAND)
        REWRIT(ISCALE,IDIF);
    }
    if (jobtyp > 2) goto L37;
    file6 << endl << endl << "AVERAGE INTENSITY DIFFERENCE FOR PATTERN," << endl
          << endl << "GIVEN FOR BLOCKS OF 20 OBSERVATIONS." << endl;
    for(I=1; I <= NPTS; I = I + 200)
    {
        for(J=1; J <= 10; J++)
        {
            J20=20*(J-1);
            DEL[J]=0;
            for(K=1; K <= 20; K++)
            {
                J20IK=J20+I+K-1;
                DEL[J]=DEL[J]+Y_[J20IK]-BK_[J20IK]-YC_[J20IK];
            }
            KI[J]=J+I/20;
            DEL[J]=DEL[J]/20.0;
            if (KI[J]*20 >= NPTS)goto L15;
        }
        J=10;
L15:
        file6 << endl << endl << "          ";
        for(JJ=1; JJ <= J; JJ++)
        {
            file6 << setw(4) << KI[JJ] << setw(5) << setprecision(1) << fixed << DEL[JJ];
        }
        file6 << endl;
    }
L37:
    for(I=1; I <= NPTS; I++)
    {
        YC_[I]=YC_[I]+BK_[I];
        if (jobtyp > 2) Y_[I]=YC_[I];
    }

    if (r_ipc == 0) goto L36;


    for (K = 1; K <= nphase; ++K)
    {
        for (I = 1; I <= NPTS; ++I) KR_[I] = 0.0;
        if (MOD(K,2) == 1) allp.ILOC = allp.ILOC + 1;
        //       GAM1=PAR(K,17)
        file6 << endl << "PHASE NO. = " << setw(3) << K << "     PHASE NAME " << phases[K].name << endl;
        T2OBS=0.0;
        TDOBS=0.0;
        RFNMR=0.0;
        RFDNR=0.0;
        ICZ=0;
        for (IIPHAS = 1; IIPHAS <= nphase; ++IIPHAS) ICZ += ICR_[IIPHAS];
        IXX=0;
        IXXX=0;


        for(IX=1; IX <= ICZ; IX++)
        {
            if ( K != refs[IX].iphase ) goto L481;
            SHIFT = GLB[10] * cos(refs[IX].refs[2]/2.0/57.2958) + GLB[11] * sin(refs[IX].refs[2]/57.2958);
            IXX=IXX+1;
            for(J=1; J <= nexcrg; J++)
            {
                //-----CHECK FOR SPLIT PEARSON VII PROFILE
                if (nprof+1 == 5)
                {
                    if ((refs[IX].refs[2]+SHIFT+GLB[1]) >= (ALOW[J]-WDT*refs[IX].FWHM[1]) && (refs[IX].refs[2]+SHIFT+GLB[1]) <= (AHIGH[J]+WDT*refs[IX].FWHM[2]))  goto L481;
                    //-----FOR ALL OTHER PROFILES
                }
                else
                {
                    if ((refs[IX].refs[2]+SHIFT+GLB[1]) >= (ALOW[J]-WDT*refs[IX].refs[1]) && (refs[IX].refs[2]+SHIFT+GLB[1]) <= (AHIGH[J]+WDT*refs[IX].refs[1])) goto L481;
                }
            }
            IXXX=IXXX+1;
            //----CHECK FOR THE SPLIT PEARSON VII PROFILE
            //-----IF SO CHANGE THE PROFILE LIMITS
            if (nprof+1 == 5)
            {
                RMIN=refs[IX].refs[2]+GLB[1]+SHIFT-WDT*refs[IX].FWHM[1];
                RMAX=refs[IX].refs[2]+GLB[1]+SHIFT+WDT*refs[IX].FWHM[2];
                //-----FOR ALL OTHER PROFILES
            }
            else
            {
                RMIN=refs[IX].refs[2]+GLB[1]+SHIFT-WDT*refs[IX].refs[1];
                RMAX=refs[IX].refs[2]+GLB[1]+SHIFT+WDT*refs[IX].refs[1];
            }
            MIN=(RMIN-THMIN)/STEP+1.5;
            MAX=(RMAX-THMIN)/STEP+1.5;
            MIN=max(MIN,1);
            MIN=min(MIN,NPTS);
            MAX=min(MAX,NPTS);
            //-----PATCH TO CALCULATE R-BRAGG
            prfx.TL=refs[IX].refs[1];
            VERT=refs[IX].refs[2] <= RLIM;
            if (nprof+1 == 6)
            {
                prfx.GAM1=phases[K].PAR[17] + phases[K].PAR[18] * refs[IX].refs[2];
            }
            else if (nprof+1 == 7)
            {
                prfx.GAM1=phases[K].PAR[17]+(phases[K].PAR[18]+phases[K].PAR[19]/refs[IX].refs[2])/refs[IX].refs[2];
                PRSVII(prfx.GAM1);
            }
            else if (nprof+1 == 8)
            {
                prfx.GAM1=refs[IX].GAM;
                TLG=refs[IX].HALFG;
                TLL=refs[IX].HALFL;
            }
            else if (nprof+1 == 5)
            {
                spvii.RL=phases[K].PAR[17]+(phases[K].PAR[18]+phases[K].PAR[19]/refs[IX].refs[2])/refs[IX].refs[2];
                spvii.RH=phases[K].PAR[24]+(phases[K].PAR[25]+phases[K].PAR[26]/refs[IX].refs[2])/refs[IX].refs[2];
                MSPVII(phases[K].PAR[27],prfx.TL);
            }
            BB=prfx.TL*prfx.TL;
            TIOBS =0.0;
            TIC=0.0;
            refs[IX].FMGNTD = refs[IX].FMGNTD*refs[IX].refs[3]*phases[K].PAR[1];
            for(IS=MIN; IS <= MAX; IS++)
            {
                TH=THMIN+double(IS-1)*STEP;
                if (nexcrg > 0)
                {
                    for(IEXC=1; IEXC <= nexcrg; IEXC++)
                    {
                        if (TH >= ALOW[IEXC] && TH <= AHIGH[IEXC]) goto L410;
                    }
                }
                TH2 = 0.5*TH/RAD;
                prfx.DELTA=TH-refs[IX].refs[2]-GLB[1]-SHIFT;
                prfx.DELT=prfx.DELTA*prfx.DELTA;
                //     NEXT LINE IS NECESSEARY FOR 2 PHASES WITH VERY DIFFERENT FWHM.
                if (prfx.DELT/BB > WDT*WDT) goto L410;
                if (!VERT)goto L4;
                if (iasym == 0)
                {
                    YX=prfx.DELT*SIGN(1.0,prfx.DELTA);
                    Z=1.0-phases[K].PAR[14]*YX/tan(TH2);
                }
                else
                {
                    YX=SIGN(1.0,prfx.DELTA)*prfx.DELTA/(2*prfx.TL);
                    if (TH2 > (45.0/RAD))
                    {
                        TH2 = TH2-(90.0/RAD);
                    }
                    Z=(phases[K].PAR[14]/tan(TH2)) * (2.0*(prfx.DELTA/(2*prfx.TL))*exp(-YX));
                    Z=1+Z;
                }
                if (Z <= 0.0) Z=0.0001;
                goto L5;
L4:
                Z=1.0;
L5:
                OMEGA= Z*PROFIL(nprof+1,prfx.DELT/BB);
                if (nprof+1 == 5)
                {
                    KR_[IS] = KR_[IS] + OMEGA*refs[IX].FMGNTD;
                }
                else
                {
                    KR_[IS] = KR_[IS] + OMEGA*refs[IX].FMGNTD/prfx.TL;
                }
                TIC   = TIC + OMEGA;
                TIOBS=TIOBS+OMEGA*(Y_[IS]-BK_[IS])/max((YC_[IS]-BK_[IS]),1.0);
L410:
                ;
            }
            TIC   = TIC   * refs[IX].FMGNTD/prfx.TL;
            TIOBS = TIOBS * refs[IX].FMGNTD/prfx.TL;
            //        ***************************************************************
            //        NEXT LINE IS FOR NOT EVALUATING R-BRAGG FOR REFLECTIONS
            //        WHICH ARE OUTSIDE THE MEASUREMENTS RANGE BUT WHOSE TAILS ARE
            //        IN THE PATTERN
            //        ***************************************************************
            if ((refs[IX].refs[2]+SHIFT+GLB[1]) <= THMAX)
            {
                T2OBS = T2OBS+TIOBS;
                TDOBS = TDOBS + abs(TIOBS-TIC);
                if (r_ipc == 2 ||r_ipc == 3)
                {
                    TFCAL= sqrt(abs(TIC/refs[IX].refs[3]/phases[K].PAR[1]/refs[IX].TAVIX/refs[IX].SRIX));
                    TFOBS= sqrt(abs(TIOBS/refs[IX].refs[3]/phases[K].PAR[1]/refs[IX].TAVIX/refs[IX].SRIX));
                    AFCAL=TFCAL*cos(refs[IX].APHASE);
                    BFCAL=TFCAL*sin(refs[IX].APHASE);
                    AFOBS=TFOBS*cos(refs[IX].APHASE);
                    BFOBS=TFOBS*sin(refs[IX].APHASE);
                    if (refs[IX].refs[2] <= THMAX)
                    {
                        RFNMR = RFNMR + abs(TFOBS-TFCAL);
                        RFDNR = RFDNR + abs(TFOBS);
                    }
                }
            }
            if (nprof+1 == 8) goto L9222;
            if (nprof+1 == 5) goto L9221;
            if (MOD(IXXX-1,60) == 0)
            {
                if (r_ipc == 1) file6 << "NO.  CODE    H   K   L   HW    POSN      ICALC     IOBS" << endl;
                if (r_ipc == 2) file6 << "NO.  CODE     H   K   L    FWHM    POSN    ICALC      IOBS      FCALC     FOBS   PHASE_C" << endl;
                if (r_ipc == 3) file6 << "NO.  CODE     H   K   L    FWHM    POSN    ICALC      IOBS     A_CALC    B_CALC     A_OBS     B_OBS" << endl;
            }
            HW=refs[IX].refs[1];
            if (r_ipc == 1)
            {
                file6 << setw(4) << IXX
                      << setw(4) << refs[IX].lambda << "   "
                      << setw(4) << refs[IX].l
                      << setw(4) << refs[IX].k
                      << setw(4) << refs[IX].l
                      << setw(8) << setprecision(3) << fixed << HW << " "
                      << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT << " "
                      << setw(8) << setprecision(3) << fixed << TIC << " "
                      << setw(10) << setprecision(3) << fixed << TIOBS << endl;
            }
            else if (r_ipc == 2)
            {
                if (refs[IX].lambda == 1)
                {
                    file6 << setw(4) << IXX
                          << setw(4) << refs[IX].lambda << "   "
                          << setw(4) << refs[IX].l
                          << setw(4) << refs[IX].k
                          << setw(4) << refs[IX].l
                          << setw(8) << setprecision(3) << fixed << HW
                          << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                          << setw(8) << setprecision(3) << fixed << TIC
                          << setw(10) << setprecision(0) << fixed << TIOBS
                          << setw(10) << setprecision(0) << fixed << TFCAL
                          << setw(10) << setprecision(3) << fixed << TFOBS
                          << setw(10) << setprecision(3) << fixed << RAD * refs[IX].APHASE << endl;
                }
                else
                {
                    file6 << setw(4) << IXX
                          << setw(4) << refs[IX].lambda << "   "
                          << setw(4) << refs[IX].l
                          << setw(4) << refs[IX].k
                          << setw(4) << refs[IX].l
                          << setw(8) << setprecision(3) << fixed << HW
                          << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                          << setw(8) << setprecision(3) << fixed << TIC
                          << setw(10) << setprecision(0) << fixed << TIOBS << endl;
                }
            }
            else if (r_ipc == 3)
            {
                if (refs[IX].lambda == 1)
                {
                    file6 << setw(4) << IXX
                          << setw(4) << refs[IX].lambda << "   "
                          << setw(4) << refs[IX].l
                          << setw(4) << refs[IX].k
                          << setw(4) << refs[IX].l
                          << setw(8) << setprecision(3) << fixed << HW
                          << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                          << setw(8) << setprecision(3) << fixed << TIC
                          << setw(10) << setprecision(0) << fixed << TIOBS
                          << setw(10) << setprecision(0) << fixed << AFCAL
                          << setw(10) << setprecision(3) << fixed << BFCAL
                          << setw(10) << setprecision(3) << fixed << AFOBS
                          << setw(10) << setprecision(3) << fixed << BFOBS << endl;
                }
                else
                {
                    file6 << setw(4) << IXX
                          << setw(4) << refs[IX].lambda << "   "
                          << setw(4) << refs[IX].l
                          << setw(4) << refs[IX].k
                          << setw(4) << refs[IX].l
                          << setw(8) << setprecision(3) << fixed << HW
                          << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                          << setw(8) << setprecision(3) << fixed << TIC
                          << setw(10) << setprecision(0) << fixed << TIOBS << endl;
                }
            }
            goto L481;
L9221:
            if (MOD(IXXX-1,60) == 0)
            {
                if (r_ipc == 1) file6 << " NO. CODE     H   K   L     HW     POSN    ICALC    IOBS       HG      HL      ETA   PHASE" << endl;
                if (r_ipc == 2) file6 << " NO. CODE     H   K   L     HW     POSN    ICALC      IOBS      HG      HL      ETA     FCALC     FOBS   PHASE" << endl;
                if (r_ipc == 3) file6 << " NO. CODE     H   K   L     HW     POSN    ICALC      IOBS     HG      HL      ETA    A_CALC    B_CALC     A_OBS     B_OBS" << endl;
            }
            if (r_ipc == 1)
            {
                file6 << setw(4) << IXX
                      << setw(4) << refs[IX].lambda << "   "
                      << setw(4) << refs[IX].l
                      << setw(4) << refs[IX].k
                      << setw(4) << refs[IX].l
                      << setw(8) << setprecision(3) << fixed << refs[IX].FWHM[1]
                      << setw(8) << setprecision(3) << fixed << refs[IX].FWHM[2]
                      << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                      << setw(10) << setprecision(0) << fixed << TIC
                      << setw(10) << setprecision(0) << fixed << TIOBS << endl;
            }
            else if (r_ipc == 2)
            {
                if (refs[IX].lambda == 1)
                {
                    file6 << setw(4) << IXX
                          << setw(4) << refs[IX].lambda << "   "
                          << setw(4) << refs[IX].l
                          << setw(4) << refs[IX].k
                          << setw(4) << refs[IX].l
                          << setw(8) << setprecision(3) << fixed << refs[IX].FWHM[1]
                          << setw(8) << setprecision(3) << fixed << refs[IX].FWHM[2]
                          << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                          << setw(10) << setprecision(0) << fixed << TIC
                          << setw(10) << setprecision(0) << fixed << TIOBS
                          << setw(10) << setprecision(3) << fixed << TFCAL
                          << setw(10) << setprecision(3) << fixed << RAD * refs[IX].APHASE << endl;
                }
                else
                {
                    file6 << setw(4) << IXX
                          << setw(4) << refs[IX].lambda << "   "
                          << setw(4) << refs[IX].l
                          << setw(4) << refs[IX].k
                          << setw(4) << refs[IX].l
                          << setw(8) << setprecision(3) << fixed << refs[IX].FWHM[1]
                          << setw(8) << setprecision(3) << fixed << refs[IX].FWHM[2]
                          << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                          << setw(10) << setprecision(0) << fixed << TIC << endl;
                }
            }
            else if (r_ipc == 3)
            {
                if (refs[IX].lambda == 1)
                {
                    file6 << setw(4) << IXX
                          << setw(4) << refs[IX].lambda << "   "
                          << setw(4) << refs[IX].l
                          << setw(4) << refs[IX].k
                          << setw(4) << refs[IX].l
                          << setw(8) << setprecision(3) << fixed << refs[IX].FWHM[1]
                          << setw(8) << setprecision(3) << fixed << refs[IX].FWHM[2]
                          << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                          << setw(10) << setprecision(0) << fixed << TIC
                          << setw(10) << setprecision(0) << fixed << TIOBS
                          << setw(10) << setprecision(3) << fixed << AFCAL
                          << setw(10) << setprecision(3) << fixed << BFCAL
                          << setw(10) << setprecision(3) << fixed << AFOBS
                          << setw(10) << setprecision(3) << fixed << BFOBS << endl;
                }
                else
                {
                    file6 << setw(4) << IXX
                          << setw(4) << refs[IX].lambda << "   "
                          << setw(4) << refs[IX].l
                          << setw(4) << refs[IX].k
                          << setw(4) << refs[IX].l
                          << setw(8) << setprecision(3) << fixed << refs[IX].FWHM[1]
                          << setw(8) << setprecision(3) << fixed << refs[IX].FWHM[2]
                          << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                          << setw(10) << setprecision(0) << fixed << TIC
                          << setw(10) << setprecision(0) << fixed << TIOBS << endl;
                }
            }
            goto L481;
L9222:
            if (MOD(IXXX-1,60) == 0)
            {
                if (r_ipc == 1) file6 << " NO. CODE     H   K   L     HW     POSN    ICALC    IOBS       HG      HL      ETA   PHASE_C" << endl;
                if (r_ipc == 2) file6 << " NO. CODE     H   K   L     HW     POSN    ICALC      IOBS      HG      HL      ETA     FCALC     FOBS   PHASE_C" << endl;
                if (r_ipc == 3) file6 << " NO. CODE     H   K   L     HW     POSN    ICALC      IOBS     HG      HL      ETA    A_CALC    B_CALC     A_OBS     B_OBS" << endl;
            }
            HW=refs[IX].refs[1];
            if (r_ipc == 1)
            {
                file6 << setw(4) << IXX
                      << setw(4) << refs[IX].lambda
                      << "   "
                      << setw(4) << refs[IX].l
                      << setw(4) << refs[IX].k
                      << setw(4) << refs[IX].l
                      << setw(8) << setprecision(3) << fixed << HW
                      << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                      << setw(10) << setprecision(0) << fixed << TIC
                      << setw(10) << setprecision(0) << fixed << TIOBS
                      << setw(8) << setprecision(3) << fixed << TLG
                      << setw(8) << setprecision(3) << fixed << TLL
                      << setw(8) << setprecision(3) << fixed << prfx.GAM1
                      << setw(10) << setprecision(3) << fixed << RAD * refs[IX].APHASE << endl;
            }
            else if (r_ipc == 2)
            {
                if (refs[IX].lambda == 1)
                {
                    file6 << setw(4) << IXX
                          << setw(4) << refs[IX].lambda
                          << "   "
                          << setw(4) << refs[IX].l
                          << setw(4) << refs[IX].k
                          << setw(4) << refs[IX].l
                          << setw(8) << setprecision(3) << fixed << HW
                          << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                          << setw(10) << setprecision(0) << fixed << TIC
                          << setw(10) << setprecision(0) << fixed << TIOBS
                          << setw(8) << setprecision(3) << fixed << TLG
                          << setw(8) << setprecision(3) << fixed << TLL
                          << setw(8) << setprecision(3) << fixed << prfx.GAM1
                          << setw(10) << setprecision(3) << fixed << TFCAL
                          << setw(10) << setprecision(3) << fixed << TFOBS
                          << setw(10) << setprecision(3) << fixed << refs[IX].APHASE << endl;
                }
                else
                {
                    file6 << setw(4) << IXX
                          << setw(4) << refs[IX].lambda
                          << "   "
                          << setw(4) << refs[IX].l
                          << setw(4) << refs[IX].k
                          << setw(4) << refs[IX].l
                          << setw(8) << setprecision(3) << fixed << HW
                          << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                          << setw(10) << setprecision(0) << fixed << TIC
                          << setw(10) << setprecision(0) << fixed << TIOBS
                          << setw(8) << setprecision(3) << fixed << TLG
                          << setw(8) << setprecision(3) << fixed << TLL
                          << setw(8) << setprecision(3) << fixed << prfx.GAM1 << endl;
                }
            }
            else if (r_ipc == 3)
            {
                if (refs[IX].lambda == 1)
                {
                    file6 << setw(4) << IXX
                          << setw(4) << refs[IX].lambda
                          << "   "
                          << setw(4) << refs[IX].l
                          << setw(4) << refs[IX].k
                          << setw(4) << refs[IX].l
                          << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                          << setw(8) << setprecision(3) << fixed << TIC
                          << setw(10) << setprecision(0) << fixed << TIOBS
                          << setw(10) << setprecision(0) << fixed << TLG
                          << setw(8) << setprecision(3) << fixed << TLL
                          << setw(8) << setprecision(3) << fixed << prfx.GAM1
                          << setw(8) << setprecision(3) << fixed << AFCAL
                          << setw(10) << setprecision(3) << fixed << BFCAL
                          << setw(10) << setprecision(3) << fixed << AFOBS
                          << setw(10) << setprecision(3) << fixed << BFOBS << endl;
                }
                else
                {
                    file6 << setw(4) << IXX
                          << setw(4) << refs[IX].lambda
                          << "   "
                          << setw(4) << refs[IX].l
                          << setw(4) << refs[IX].k
                          << setw(4) << refs[IX].l
                          << setw(8) << setprecision(3) << fixed << HW
                          << setw(8) << setprecision(3) << fixed << refs[IX].refs[2] + GLB[1] + SHIFT
                          << setw(10) << setprecision(0) << fixed << TIC
                          << setw(10) << setprecision(0) << fixed << TIOBS
                          << setw(8) << setprecision(3) << fixed << TLG
                          << setw(8) << setprecision(3) << fixed << TLL
                          << setw(8) << setprecision(3) << fixed << prfx.GAM1 << endl;
                }
            }
L4810:
L481:
            ;
        }
        TDOBS=100.0*TDOBS/T2OBS;
        file6 << "DERIVED BRAGG R-FACTOR = " << setw(8) << setprecision(2) << fixed << TDOBS << endl;
        if (r_ipc != 1) file6 << "DERIVED R-F            = " << setw(8) << setprecision(2) << fixed << RFNMR * 100.0 / RFDNR << endl;
        allp.FINAL[allp.ILOC][2-MOD(K,2)] = TDOBS;
    }
L36:
    ;
    for(I=1; I <= NPTS; I++)
    {
        BK_[I]=THMIN+double(I-1)*STEP;
    }

    if (r_iploss == 1 && r_ipbig == 0) write_file31();              //     IT BUILDS THE OBSERVED DATA FILE CORRECTED FOR ABSORPTION
    if (r_iplcal == 1 && r_ipbig == 0) write_file32();              //     IT BUILDS THE CALCULATED DATA FILE (BRAGG+COMPTON+DISORDINE+AMORPHOUS)
    if (r_iplcom == 1 && r_ipbig == 0) write_file33();              //     IT BUILDS THE TOTAL COMPTON SCATTERING FILE FOR ALL PHASES
    if (r_ipldis == 1 && r_ipbig == 0) write_file34();              //     IT BUILDS THE TOTAL DISORDER SCATTERING FILE FOR ALL PHASES
    if (r_iplpol == 1 && r_ipbig == 0) write_file37();              //     IT BUILDS THE POLYNOMIAL BACKGROUND FILE
    if (r_iplam  == 1 && r_ipbig == 0) write_file36();              //     IT BUILDS THE AMORPHOUS FILE
    if (r_ipbig == 1)   write_file38();                             //     IT BUILDS THE TOTAL PLOT FILE

    NPTS2=NPTS-NP*240;
    if (NPTS2 == 0)goto L30;
    NCOL=NPTS2/60;
    file6 << " 2THETA   YOBS    YCALC VARIANCE" << endl;
    NLINES=NPTS2-NCOL*60;
    if (NLINES == 0)goto L33;
    NCOL1=NCOL+1;
    NP=240*NP-60;
    for(J=1; J <= NLINES; J++)
    {
        for(I=1; I <= NCOL1; I++)
        {
            file6 << setw(7) << setprecision(3) << fixed << BK_[NP+60*I+J]
                  << setw(8) << setprecision(0) << fixed << Y_[NP+60*I+J]
                  << setw(8) << setprecision(0) << fixed << YC_[NP+60*I+J]
                  << setw(8) << setprecision(0) << fixed << VAR_[NP+60*I+J];
        }
        file6 << endl;
    }
    NP=NP+NLINES;
    NLINES=60-NLINES;
L33:
    for(J=1; J <= NLINES; J++)
    {
        for(I=1; I <= NCOL1; I++)
        {
            file6 << setw(7) << setprecision(3) << fixed << BK_[NP+60*I+J]
                  << setw(8) << setprecision(0) << fixed << Y_[NP+60*I+J]
                  << setw(8) << setprecision(0) << fixed << YC_[NP+60*I+J]
                  << setw(8) << setprecision(0) << fixed << VAR_[NP+60*I+J];
        }
        file6 << endl;
    }
L30:
    if (r_ipl == 0)goto L45;
    for (I = 1; I <= 12; ++I) LABEL[I] = 10*I*ISCALE;
    file6 << endl << "                              " << title << endl << endl;
    for (I = 1; I <= 12; ++I) file6 << setw(10) << LABEL[I];
    file6 << endl;
    for (I = 1; I <= 12; ++I)
    {
        LABEL[I] = -60*IDIF+10*I*IDIF;
    }
    for (I = 1; I <= 12; ++I) file6 << setw(10) << LABEL[I];
    file6 << endl;
    for(I=1; I <= NPTS; I++)
    {
        for(J=1; J <= 120; J++)
        {
            IOUT[J]=ISPACE;
        }
    }
    IOUT[1]=IDOT;
    IOUT[61]=IDOT;
    IOUT[120]=IDOT;
L200:
    IY=int(Y_[I])/ISCALE+2;
    IY=max(min(IY,120),2);
    IOUT[IY-1]=IBAR;
    IOUT[IY]=IPLUS;
    if (IY <= 119) IOUT[IY+1]=IBAR;
    IY=int(YC_[I])/ISCALE+2;
    IY=max(min(IY,120),2);
    IOUT[IY]=IMINUS;
    IY=int(Y_[I]-YC_[I])/IDIF+61;
    IY=max(min(IY,120),2);
    IOUT[IY]=ISTAR;
    if (MOD(I-1,10) != 0) goto L55;
    TLABEL=THMIN+STEP*double(I-1);
    file6 << IOUT.substr(1,113) << setw(6) << setprecision(2) << TLABEL << IOUT[120] << endl;
    goto L60;
L55:
    file6 << IOUT.substr(1,120) << endl;
L60:
L45:
    if (jobtyp >= 3)
    {
        if ( file4.is_open() ) file4.close();
        rit.thetamin = THMIN;
        rit.step = STEP;
        rit.thetamax = THMAX;
        rit.set(YC_,1,NPTS);
        rit.write(namefile4);
    }


    // 72    if (IPL2 != 0)CALL CALPLT(IFY,IFYC,IFM,IFD,IFB,EXPAND,params.GLB(1))
    if (r_iplst != 0 && MAXS != 0)
    {
        INUMB = cntrls.ICYRUN + 1;
        NPAGES = MAXS/12;
        if (MOD(MAXS,12) != 0) NPAGES = NPAGES+1;
        //     LIST PARAMETERS IN EACH CYCLE
        file6 << endl << "PARAMETERS IN EACH CYCLE" << endl;
        for(J=1; J <= NPAGES; J++)
        {
            ISTART = 1 + (J-1)*12;
            IFINIS  = min(MAXS,12 + (J-1)*12);
            file6 << "CYCLE";
            for(L=ISTART; L <= IFINIS; L++) file6 << "   " << setw(2) << L << "     ";
            file6 << endl;
            for(K=1; K <= INUMB; K++)
            {
                file6 << " " << setw(2) << K-1 << ")  ";
                for(I=ISTART; I <= IFINIS; I++) file6 << setw(10) << setprecision(4) << scientific << DUMMY[I];
                file6 << endl;
            }
        }
        //     LIST R-VALUES  IN EACH CYCLE
        file6 << "R-VALUE VARIATION WITH CYCLE" << endl;
        file6 << "CYCLE    R-P     R-WP      S      D-W D" << endl;
        for(K=1; K <= INUMB; K++)
        {
            file6 << setw(2) << K-1 << ")  ";
            for(I=2*MAXS+1; I <= 2*MAXS+4; I++) file6 << setw(8) << setprecision(2) << fixed << DUMMY[I];
            file6 << endl;
        }
        //     LIST PARAMETER SHIFTS IN EACH CYCLE
        if (INUMB == 1) goto L88880;
        file6 << "APPLIED PARAMETER SHIFT IN EACH CYCLE" << endl;
        for(J=1; J <= NPAGES; J++)
        {
            ISTART = 1 + MAXS+ (J-1)*12;
            IFINIS = min(2*MAXS,12 + MAXS+ (J-1)*12);
            file6 << "CYCLE";
            for(L=ISTART-MAXS; L <= IFINIS-MAXS; L++) file6 << "   " << setw(2) << L << "     ";
            file6 << endl;
            for(K=1; K <= INUMB-1; K++)
            {
                if (K == 1) goto L7964;
L7964:
                file6 << " " << setw(2) << K << ")  ";
                for(I=ISTART; I <= IFINIS; I++) file6 << setw(10) << setprecision(4) << scientific << DUMMY[I];
            }
        }
    }
L88880:
    //     CODE FOR PRINTING PARAMETERS AND STD. DEV. IN THE FINAL CYCLE
    if (r_iplst == 2 && MAXS != 0)
    {
        file6 << "PARAMETERS AND STANDARD DEVIATIONS IN THE FINAL CYCLE FOR DATA BASE" << endl;
        file6 << " \" " << title << " \" " << endl;
        for(I=1; I <= allp.ILOC; I++)
        {
            for(J=1; J <= 2; J++)
            {
                file6 << setw(10) << setprecision(4) << scientific << allp.FINAL[I][J] << endl;
            }
        }
    }
    return;
L99990:
    cout << "ERROR IN WRITING TO FILE 6 IN SUBROUTINE EXPUT" << endl;
    exit(EXIT_FAILURE);
L99991:
    cout << "ERROR WRITING PARAMS,ST.DEV. IN SUBROUTINE EXPUT" << endl;
    exit(EXIT_FAILURE);
L99992:
    cout << "ERROR IN READING FROM UNIT 8 IN SUBROUTINE EXPUT" << endl;
    exit(EXIT_FAILURE);
}

void DBWS::REFGEN(int IPHASE, double ZERO, double DIS, double TRANS, double PREFOR)
{
    string LAU[14+1] = {
        "",
        "1BAR","2/M","MMM","4/M","4/MMM","3BAR   R","3BAR M R","3BAR",
        "3BAR M 1","3BAR 1 M","6/M","6/MMM","M3","M3M"
    };


    double ANGTTETA,SQ, SQH, POS,TLR,TAN2,XABS, TMIN, SMAX,TANX, PLOR,SMAX1,SHIFT,THMAX1,THMAXX;
    int I, J, N, H1, H2, H3, I1, L1, I2, I3, IC,I1D, I2D, I3D,LX1, I12D, I13D, I23D,LXN,I123D,
        KXIS,I2DEL, I3DEL, I1MAX, I2MAX, I3MAX,IORDR1, IORDR2,IORDR3,IIPHAS;
    bool ORH1, ORH2, ORH3;


    if ( spgcom.NAXIS > 3 )
    {
        cout << "5001" << endl;
        exit(EXIT_FAILURE);
    }
    KXIS = spgcom.NAXIS;
    spgcom.NAXIS = 1;

    N = 0;
    J = 0;
    I2D = 0;
    I3D = 0;
    I1D = 1;
    I12D = 1;
    I13D = 1;
    I123D = 1;
    I23D = 1;
    I2DEL = 1;
    I3DEL = 1;
    for(I=1; I <= 8; I++)
    {
        if ( spgcom.NCONT[I] == 0 ) break;
        if ( spgcom.NCONT[I]-8192 < 0)
        {
            if ( spgcom.NCONT[I]-576 == 0 )
            {
                I3DEL = 2;
                I23D = 2;
            }
            else
            {
                if ( spgcom.NCONT[I]-516 == 0 )
                {
                    I3DEL = 2;
                    I13D = 2;
                }
                else
                {
                    if ( spgcom.NCONT[I]-68 == 0 )
                    {
                        I2DEL = 2;
                        I12D = 2;
                    }
                    else
                    {
                        if ( spgcom.NCONT[I]-580 == 0 )
                        {
                            I123D = 2;
                            I3DEL = 2;
                        }
                    }
                }
            }
        }
        else if ( spgcom.NCONT[I]-8192 == 0)
        {
            I3DEL = 3;
            I1D = 2;
            I123D = 3;
            break;
        };
    }
    N = J-1;
L97:
    TMIN = pow((  sin((THMIN/720.0)*6.28318531) /LAMDA[1]),2);

    IC = 0;
    if ( IPHASE >= 2 )
    {
        for(IIPHAS=2; IIPHAS <= IPHASE; IIPHAS++) IC = IC+ICR_[IIPHAS-1];
    }
    //     if (IPHASE == 2)IC=ICR(1)
    SMAX = pow((  sin((THMAX/720.0)*6.28318531)  /LAMDA[1]),2);
    //
    //     **************************************************************
    //     SMAX IS CHANGED TO ACCOUNT FOR THE LEFT TAILS OF THE REFLECTIONS
    //     THAT ARE PRESENT AT ANGLES GREATER THAN THMAX
    //     **************************************************************
    //     PRINT *,'THMAX=',THMAX
    //      THMAX1=(U*(TAN(THMAX*RAD))**2+V*TAN(THMAX*RAD)+W+ZZZ*(1+*(TAN(THMAX*RAD))**2))
    // also incorporating the cotg^2 term

    THMAX1=(g1.U*pow(( tan( degtorad(2.0*THMAX) ) ),2)+g1.V*tan(  degtorad(2.0*THMAX) )+g1.W+g1.ZZZ*(1+pow((tan(  degtorad(2.0*THMAX)  )),2)) + g1.UC/(tan(  degtorad(2.0*THMAX)  )));

    if ( THMAX1 > 0.0 )
    {
        THMAX1= WDT*sqrt(THMAX1)/2;
    }
    else
    {
        file6 << "   SQUARE OF FWHM NEGATIVE AT TWO-THETA" << setw(8) << setprecision(3) << fixed << POS << "FOR PHASE NO. " << setw(4) << IPHASE << endl;
        cout << "SQUARE OF FWHM IS NEGATIVE" << endl;
        exit(EXIT_FAILURE);
    }
    ANGTTETA=THMAX+THMAX1;
    if ( (THMAX+THMAX1) >= 180.0 ) ANGTTETA=180.0;
    SMAX1 = pow((  sin(((ANGTTETA)/720.0)*6.28318531) /LAMDA[1]),2);

    SMAX = SMAX1;

    THMAXX=ANGTTETA;
    if ( LAMDA[2] > LAMDA[1] ) TMIN=TMIN*pow((LAMDA[1]/LAMDA[2]),2);
    if ( LAMDA[2] > 0.0  &&  LAMDA[2] < LAMDA[1] ) SMAX=SMAX*pow((LAMDA[1]/LAMDA[2]),2);
    OP1(IPHASE);
    file6 << "LAUE SYMMETRY " << LAU[spgcom.NSPGRP] << " WILL BE USED TO GENERATE INDICES" << endl;
    I1MAX= cellx.a * 2.0 * sqrt(SMAX);
    if ( KXIS < 3 )
    {
        I2MAX= cellx.b * 2.0*sqrt(SMAX);
        I3MAX= cellx.c * 2.0*sqrt(SMAX);
    }
    else
    {
        I2MAX = 2.0 * cellx.c * sqrt(SMAX);
        I3MAX = 2.0 * cellx.b * sqrt(SMAX);
    }
    L1 = spgcom.NSPGRP;
    if ( L1 >= 13 && spgcom.NCONT[1] == 580 ) L1=L1+2;
    if ( I12D+I13D+I23D == 5 )
    {
        I12D = 2;
        I13D = 1;
        I23D = 2;
        I2DEL = 2;
        I3DEL = 2;
    }

    if ( L1 == 6 ) I2D=1;
    if ( L1 == 7 ) I2D=2;
    I3D = I2D;
    I1 = -1;
L2200:
    I1 = 1+I1;
    if ( I1-I1MAX <= 0 )
    {
        goto L2201;
    }
    else
    {
        goto L2303;
    }
L2201:
    H1 = I1;
    if ( I2D > 0 ) I2MAX=I1;
    switch (L1) {
    case 1:
        goto L2203;
    case 2:
        goto L2204;
    case 3:
        goto L2204;
    case 4:
        goto L2205;
    case 5:
        goto L2206;
    case 6:
        goto L2208;
    case 7:
        goto L2209;
    case 8:
        goto L2207;
    case 9:
        goto L2204;
    case 10:
        goto L2206;
    case 11:
        goto L2204;
    case 12:
        goto L2206;
    case 13:
        goto L2206;
    case 14:
        goto L2206;
    case 15:
        goto L2206;
    case 16:
        goto L2206;
    default:
        GOTOER();
    }

L2203:
    I2= -min(I2MAX,I1*I2MAX);
    goto L2210;
L2204:
    I2 = 0;
    goto L2210;
L2205:
    I2= min(I1,1);
    goto L2210;
L2206:
    I2 = I1;
    goto L2210;
L2207:
    I2= min(-I1+1,0);
    goto L2210;
L2208:
    I2 = -2*I1;
    goto L2210;
L2209:
    I2 = -I1/2;
L2210:
    I2= I2DEL*(I2/I2DEL)+MOD(I1,I12D);
    goto L2221;
L2220:
    I2 = I2DEL+I2;
L2221:
    H2 = I2;
    if ( I2-I2MAX <= 0)
    {
        goto L2222;
    }
    else
    {
        goto L2200;
    }
L2222:
    switch (L1) {
    case 1:
        goto L2223;
    case 2:
        goto L2223;
    case 3:
        goto L2224;
    case 4:
        goto L2224;
    case 5:
        goto L2224;
    case 6:
        goto L2225;
    case 7:
        goto L2225;
    case 8:
        goto L2224;
    case 9:
        goto L2224;
    case 10:
        goto L2223;
    case 11:
        goto L2224;
    case 12:
        goto L2224;
    case 13:
        goto L2226;
    case 14:
        goto L2227;
    case 15:
        goto L2236;
    case 16:
        goto L2235;
    }
    GOTOER();
L2223:
    I3= -min(I3MAX,(I1+abs(I2))*I3MAX);
    //C2223 I3= -MIN0(I3MAX,I1*I3MAX)  !(ALLEN MADE THIS CHANGE,REVERTED LATER)
    goto L2228;
L2224:
    I3 = 0;
    goto L2228;
L2225:
    I3 = -I1-I2;
    goto L2228;
L2226:
    I3= min(I2,I1+I3DEL);
    goto L2228;
L2227:
    I3 = I2;
L2228:
    I3= I3DEL*(I3/I3DEL)+MOD(MOD(I1+I1D*I2,I123D)+I123D,I123D) +MOD(I1,I13D)+MOD(I2,I23D);
    if ( I3D-1 < 0 )
    {
        goto L2232;
    }
    else if ( I3D-1== 0 )
    {
        goto L2229;
    }
    else
    {
        goto L2231;
    }
L2229:
    I3MAX = I1;
    if ( I2-I1 == 0 )
    {
        goto L2232;
    }
    else
    {
        goto L2230;
    }
L2230:
    I3MAX = I3MAX-1;
    goto L2232;
L2231:
    I3MAX = I2;
    goto L2232;
L2235:
    I3= I2+MOD(I1,2);
    goto L2232;
L2236:
    I3 = I1+2-MOD(I2,2);
    if ( I1 == I2 && MOD(I1,2) == 0 ) I3=I1;
    goto L2232;
L2233:
    I3 = I3DEL+I3;
L2232:
    H3 = I3;
    if ( KXIS != 3 ) goto L2240;
    H3 = I2;
    H2 = I3;
L2240:
    if ( I3-I3MAX <= 0 )
    {
        goto L113;
    }
    else
    {
        goto L2220;
    }
L113:
    SQ=double(H1*H1)*cellx.AL[1][1]+double(H2*H2)*cellx.AL[2][2]+double(H3*H3)*cellx.AL[3][3]+double(H1*H2)*cellx.AL[1][2]+double(H1*H3)*cellx.AL[1][3]+double(H2*H3)*cellx.AL[2][3];
    SQ=SQ/4.0;
L2234:
    if ( SQ-SMAX <= 0 )
    {
        goto L3000;
    }
    else
    {
        goto L2233;
    }
L2303:
    ICR_[IPHASE]=IC;
    if (IPHASE >= 2)
    {
        for(IIPHAS=2; IIPHAS <= IPHASE; IIPHAS++) ICR_[IPHASE] = ICR_[IPHASE]-ICR_[IIPHAS-1];
    }
    //     if (IPHASE == 2)ICR(IPHASE)=IC-ICR(1)
    SORT(IPHASE);
    return;
L3000:
    if ( SQ - TMIN < 0 )
    {
        goto L2233;
    }
    else
    {
        goto L3117;
    }
L3117:
    if ( IC > IRS-2 ) goto L6001;
    //     NEXT IF BLOCK FOR PHASE WITH DISTINCT ORIENTATION ALONG PREF(NAXIS,I)
    if (PREFOR > 99.0)
    {
        ORH1 = IFIX(phases[IPHASE].PREF[1]) == H1;
        if (!(ORH1) && H1 != 0 && IFIX(phases[IPHASE].PREF[1]) != 0) ORH1 = MOD(H1,IFIX(phases[IPHASE].PREF[1])) == 0;
        if (!ORH1) goto L2233;

        ORH2 = IFIX(phases[IPHASE].PREF[2]) == H2;
        if (!(ORH2) && H2 != 0 && IFIX(phases[IPHASE].PREF[2]) != 0) ORH2 = MOD(H2,IFIX(phases[IPHASE].PREF[2])) == 0;
        if (!ORH2) goto L2233;

        ORH3 = IFIX(phases[IPHASE].PREF[3]) == H3;
        if (!(ORH3) && H3 != 0 && IFIX(phases[IPHASE].PREF[3]) != 0) ORH3 = MOD(H3,IFIX(phases[IPHASE].PREF[3])) == 0;
        if (!ORH3) goto L2233;

        IORDR1=0;
        IORDR2=0;
        IORDR3=0;
        if (H1 != 0) IORDR1 = int(H1/IFIX(phases[IPHASE].PREF[1]));
        if (H2 != 0) IORDR2 = int(H2/IFIX(phases[IPHASE].PREF[2]));
        if (H3 != 0) IORDR3 = int(H3/IFIX(phases[IPHASE].PREF[3]));
        if (IORDR1 == IORDR2 && IORDR2 == IORDR3) goto L9257;
        if (IORDR1 == 0 && (IORDR2 == IORDR3)) goto L9257;
        if (IORDR2 == 0 && (IORDR3 == IORDR1)) goto L9257;
        if (IORDR3 == 0 && (IORDR1 == IORDR2)) goto L9257;
        if (IORDR1 == 0 && IORDR2 == 0) goto L9257;
        if (IORDR2 == 0 && IORDR3 == 0) goto L9257;
        if (IORDR3 == 0 && IORDR1 == 0) goto L9257;
    }
L9257:
    //     SEPARATE PHASE FOR ORIENTATION COMPLETE
    hklctl.IHKL[1][1]=H1;
    hklctl.IHKL[2][1]=H2;
    hklctl.IHKL[3][1]=H3;
    hklctl.AZ[1]=0.0;
    hklctl.IER=0;
    SMTRY2(IPHASE);
    if (hklctl.IER != 0)goto L2233;
    LXN=2;
    if (LAMDA[2] == 0.0 || LAMDA[2] == LAMDA[1]) LXN=1;
    for(LX1=1; LX1 <= LXN; LX1++)
    {
        SQH=SQ*LAMDA[LX1]*LAMDA[LX1];
        TAN2=SQH/(1.0-SQH);
        if (SQH >= 1.0) goto L3118;
        TANX=sqrt(TAN2);
        //     SHIFT DUE TO SAMPLE DISPLACEMENT AND TRANSPARENCY
        SHIFT =  DIS*sqrt(1-SQH)+TRANS*sqrt(1.0-(1.0-2.0*SQH)*(1.0-2.0*SQH));
        POS = 2.0 * radtodeg(atan(TANX)) + ZERO + SHIFT;
        //     if (POS > THMAX || POS > THMIN)goto 3118
        if ( POS > THMAXX  ||  POS < THMIN ) goto L3118;
        IC=IC+1;
        XABS=1.0;
        if (TMV <= 0.000001) XABS=1.0;
        PLOR=1.0/(2.0*SQH*sqrt(1.0-SQH))*XABS;
        if (instrm == 2)
        {
            PLOR = PLOR * (0.95+0.05*(1.0-2.0*SQH)*(1.0-2.0*SQH));
            goto L4000;
        }
        if (jobtyp == 3) PLOR=PLOR*(1.0+(1.0-2.0*SQH)*(1.0-2.0*SQH)*CTHM);
        if (jobtyp == 1) PLOR=PLOR*(1.0+(1.0-2.0*SQH)*(1.0-2.0*SQH)*CTHM);
L4000:
        refs[IC].h = H1;
        refs[IC].k = H2;
        refs[IC].l = H3;
        refs[IC].lambda = LX1;
        refs[IC].iphase = IPHASE;
        refs[IC].phase = &phases[IPHASE];
        //IREFS[IC]=256*(256*(256*(8*IPHASE+LX1)+128+H1)+128+H2)+128+H3;
        refs[IC].FMGNTD=MULT(H1,H2,H3,KXIS);

        //------CALCULATE FWHM FOR PSEUDOVOIGT WITH GAUSS AND LORENTZ
        if (nprof == 8)
        {
            refs[IC].HALFG =    (g1.U*TAN2+g1.V*TANX+g1.W+g1.ZZZ*(1+TAN2));
            if (refs[IC].HALFG > 0.0)
            {
                refs[IC].HALFG = sqrt(refs[IC].HALFG);
            }
            else
            {
                file6 << "   SQUARE OF FWHM NEGATIVE AT TWO-THETA" << setw(8) << setprecision(3) << fixed << POS << "FOR PHASE NO. " << setw(4) << IPHASE << endl;
                cout << "SQUARE OF FWHM IS NEGATIVE" << endl;
                exit(EXIT_FAILURE);
            }
            refs[IC].HALFL = g1.ULOR*TANX+g1.VLOR/sqrt(1.0-SQH);
            refs[IC].refs[1] = pow(
                                    (pow(refs[IC].HALFG,5.0)+2.69269*pow(refs[IC].HALFG,4.0)*refs[IC].HALFL+2.42843*pow(refs[IC].HALFG,3.0)*pow(refs[IC].HALFL,2.0)+
                                     4.47163*pow(refs[IC].HALFG,2.0)*pow(refs[IC].HALFL,3.0)+0.07842*refs[IC].HALFG*pow(refs[IC].HALFL,4.0)+pow(refs[IC].HALFL,5.0))
                                    ,0.2);
            TLR = refs[IC].HALFL/refs[IC].refs[1];
            refs[IC].GAM = 1.36603*TLR-0.47719*TLR*TLR+0.11116*pow(TLR,3.0);
        }
        else if (nprof == 5)
        {
            refs[IC].refs[1] = (g1.U*TAN2+g1.V*TANX+g1.W);
        }
        else
        {
            refs[IC].refs[1]=(g1.U*TAN2+g1.V*TANX+g1.W+g1.ZZZ*(1+TAN2)+g1.UC/TAN2);              // incorporating cotg^2
        }
        if (refs[IC].refs[1] > 0.0)
        {
            refs[IC].refs[1]= sqrt(refs[IC].refs[1]);
        }
        else
        {
            file6 << "   SQUARE OF FWHM NEGATIVE AT TWO-THETA" << setw(8) << setprecision(3) << fixed << POS << "FOR PHASE NO. " << setw(4) << IPHASE << endl;
            cout << "SQUARE OF FWHM IS NEGATIVE" << endl;
            exit(EXIT_FAILURE);
        }
L7000:
        refs[IC].refs[2]=POS;
        refs[IC].refs[3]=PLOR;
L3118:
        ;
    }
    goto L2233;
L6001:
    file6 << endl << endl << " TOO MANY REFLECTIONS, INCREASE *IRS* IN THE PARAMETER STATEMENT IN THE SOURCE CODE" << endl;
    exit(EXIT_FAILURE);
}


//  SUBROUTINE FINDC and SUBROUTINE COMPTON subroutine DISORDER: by Canton et all.
void DBWS::FINDC(int K,int NSCAT)
{

    // ----THIS SUBROUTINE ASSIGNS AUTOMATICALLY TO ATOMS
    //     THE RIGHT CONSTANTS TO CALCULATE THE COMPTON SCATTERING

    char PIU = '+';
    char MENO = '-';
    int I, J, L, NA, NK, NN, NS, IOF;
    string NOME,NOM;

    IOF = 0;
    NS  = 0;
    //-----K = NUMBER OF PHASE UNDER CONSIDERATION
    if (K > 1)
    {
        //-----CALCULATE IOF = ALL ATOMS OF THE K-1 PHASES
        for(I = 2; I <= K; I++) IOF = IOF + phases[I-1].NATOM;
        NS = dc.NSAVE;
    }
    //-----DEFINE NK = NUMBER OF ATOMS OF THE K-TH PHASE
    NK = phases[K].NATOM;
    for(I = 1; I <= NK; I++)
    {
        //                      if (NS == 0) goto 25
        for(J = 1; J <= NSCAT; J++)
        {
            if (atoms[I+IOF].NTYP == NAM_[J]) goto L30;
        }
        //-----212 = ALL THE POSSIBLE NAMES OF ATOMS AND IONS
L25:
        for(J = 1; J <= 212; J++)
        {
            if (atoms[I+IOF].NTYP == TBXC[J]) goto L50;
        }
        file6 << "COMPTON SCATTERING COEFFICIENT NOT FOUND FOR " << atoms[I+IOF].NTYP << endl;
        cout << "COMPTON SCATTERING DATA MISSING" << endl;
        exit(EXIT_FAILURE);
L30:
        atoms[I+IOF].PTC = J;
        goto L9999;
L50:
        NOME = TBXC[J];
        //-----FIND NA = THE ATOMIC NUMBER OF I-TH ATOM
        if (J == 1 || J == 2 || J == 3)
        {
            NA = TBX[J][10];
        }
        else
        {
            NA = TBX[J][10] + 1.0;
        }
        NS = NS + 1;
        atoms[I+IOF].PTC = NS;
        //-----PUT IN CC THE 4 COMPTON COEFFICIENTS
        for(L = 1; L <= 4; L++) comp.CC[L][NS] = TCS[NA][L];
        NAM_[NS] = NOME;
        NOM = NOME;

        //     FIND IN WHAT COLUMN THERE IS + OR -
        for(L=1; L <= 4; L++)
        {
            if (NOM[L] == PIU)  goto L90;
            if (NOM[L] == MENO) goto L95;
        }
        // CASE WITH NOR + NOR -
        comp.ZEFF[NS] = NA;
        goto L9999;
        //-----CASE WITH PLUS
L90:
        L = L + 1;
        if (L > 4)
        {
            cout << "  SOMETHING IS WRONG IN ATOMIC NAME " << endl;
            exit(EXIT_FAILURE);
        }
        NN = stoi(NOM.substr(L,1));
        comp.ZEFF[NS] = NA - NN;
        goto L9999;
        //-----CASE WITH MINUS
L95:
        L = L + 1;
        if (L > 4)
        {
            cout << "  SOMETHING IS WRONG IN ATOMIC NAME " << endl;
            exit(EXIT_FAILURE);
        }
        NN = stoi(NOM.substr(L,1));
        comp.ZEFF[NS] = NA + NN;
L9999:
        ;
    }
    dc.NSAVE = NS;
}


// SUBROUTINE TO READ PHILIPS UDF DATA FILE
void DBWS::PHILIPSREAD()
{
}


// SUBROUTINE GSASREAD * READ GSAS FORMATTED DATA FILE
void DBWS::GSASREAD()
{
}

void DBWS::SCINTAG()
{
}


void DBWS::READASC()
{
}

//  SUBROUTINE ABSORP and SUBROUTINE ARIA: by Canton et all. Added by cps between
//  march-may 1997
void DBWS::ABSORP(double MU, double SW, double TH, double *ABC)
{

//-----THIS SUBROUTINE CORRECTS THE EXPERIMENTAL INTENSITIES FOR THE
//                ABSORPTION EFFECTS AS REPORTED BY:
//     1) H. P. KLUG & L. E. ALEXANDER, X-RAY DIFFRACTION PROCEDURES,
//        1970, PAG.487.
//     2) A. IMMIRZI, ACTA CRYST. , 1980, B36, 2378-2385.
//
//     IT IS WRITTEN TAKING INTO ACCOUNT THE SYMMETRIC REFLECTION ARRANGEMENT
//     ( KLUG & ALEXANDER, 1970, FIG. 5-52 PAG. 390) AND  THE  FINITE
//     THICKNESS OR WIDTH OF THE SLAB, IN THIS SITUATION THE ABSORPTION
//     IS GENERALLY LOW AND INCREASES SLIGHTLY WITH 2 THETA.
//     MU = LINEAR ABSORPTION COEFFICIENT IN CM-1.
//     SW = SAMPLE THICKNESS IN CM.
    double EX;

    EX  = ( 2.0 * MU * SW ) / sin( degtorad( 2 * TH ) );
    *ABC = 1.0 - exp(-EX);
}

void DBWS::INPTR()
{

    FileRIT rit;

    string line,s;
    string DATE,DATAID;
    int i,j, K, KK,IX, N2X,NBC, IOF, ICY, ICZ,NBX, KKS, IXX, IYY, NXX,IBDG,
        NINC,IPTS,MLTT,IXDEL,IXRAY, ISTOP,NRANGE,IIPHAS,NATOMS, LCOUNT;
    double X,TH,ABC,THX,DIFB,TAUK,BSTEP,FLEET1, FLEET2, OFSTI0, OFSTI1, CHMBRI,ANGLEP, ANGMIN,
          ANGMAX,STPTIM;

    // line 1
    getline(file5,line);
    if (file5.bad()) goto L99999;
    read_icf_line1(line);


    // line 2
    getline(file5,line);
    if (file5.bad()) goto L99999;
    read_icf_line2(line);


    if (nbckgd == -1)
    {
        codebck.IBCKCODE=nbckgd;
        nbckgd = 0;
        IBDG   = 0;
    }
    else
    {
        fondo  = 0;
        cntrls.IBGD   = 1;
        //            iax    = 0
        codebck.IBCKCODE=nbckgd;
    }
    if (nphase == 0) nphase=1;
    instrm=instrm+1;
    jobtyp=jobtyp+1;
    nprof=nprof+1;
    file6 << "DBWS " << versao << endl;
    file6 << " PROGRAM PARAMETERS:" << endl
          << " IDSZ=" << setw(5) << IDSZ << "    IRS=" << setw(5) << IRS << "    NATS=" << setw(4) << NATS << "     MSZ=" << setw(3) << MSZ << "     NOV=" << setw(4) << NOV << endl;
    file6 << title << endl;
    file6 << "DBWS " << versao << endl;
    cout << " PROGRAM PARAMETERS:" << endl
         << " IDSZ=" << setw(5) << IDSZ << "    IRS=" << setw(5) << IRS << "    NATS=" << setw(4) << NATS << "     MSZ=" << setw(3) << MSZ << "     NOV=" << setw(4) << NOV << endl;
    cout << title << endl;

    if (jobtyp == 1) file6 << "FOR X-RAY DATA" << endl;
    if (jobtyp == 1 && instrm == 2) file6 << "COLLECTED IN SYNCHROTRON AT NSLS OR SRS" << endl;
    if (jobtyp == 2) file6 << "FOR NEUTRON DATA, NUCLEAR INTENSITIES ONLY" << endl;
    if (jobtyp == 2 && instrm == 2) file6 << "VARYING NO. OF COUNTERS AT EACH STEP" << endl;
    if (jobtyp == 3) file6 << "PATTERN CALCULATION,XRAY" << endl;
    if (jobtyp == 4) file6 << "PATTERN CALCULATION,NEUTRON" << endl;
    if (jobtyp < 1 || jobtyp > 4) {
        cout << "7777" << endl;
        exit(EXIT_FAILURE);
    }
    if (idata == 0) file6 << "READ DATA IN TRADITIONAL DBWS FORMAT" << endl;
    if (idata == 1) file6 << "READ DATA IN FREE FORMAT" << endl;
    if (idata == 2) file6 << "READ DATA IN GSAS STD FORMA" << endl;
    if (idata == 3) file6 << "READ DATA IN PHILIPS UDF FORMAT" << endl;
    if (idata == 4) file6 << "READ DATA IN SCINTAG TXT FORMAT" << endl;
    file6 << "NUMBER OF PHASES=  " << setw(4) << nphase << endl
          << "NUMBER OF EXCLUDED REGIONS=  " << setw(4) << nexcrg << endl
          << "NUMBER OF SCATTERING SETS=  " << setw(4) << nscat << endl;
    if (nbckgd - 1 < 0)
    {
        file6 << "BACKGROUND TO BE REFINED " << endl;
    } else if (nbckgd - 1 == 0) {
        file6 << "BACKGROUND DATA TO BE READ FROM FILE" << endl;
    } else {
        file6 << "BACKGROUND CORRECTION BY INTERPOLATION BETWEEN THE " << setw(4) << nbckgd << "POINTS GIVEN" << endl;
    }

    if (nprof - 1 == 0) {
        file6 << "GAUSSIAN PROFILE, NPROF = " << setw(4) << nprof - 1 << endl;
    } else if (nprof - 1 == 1) {
        file6 << "LORENTZIAN (CAUCHY) PROFILE, NPROF = " << setw(4) << nprof - 1 << endl;
    } else if (nprof - 1 == 2) {
        file6 << "MOD 1 LORENTZIAN PROFILE, NPROF = " << setw(4) <<nprof - 1  << endl;
    } else if (nprof - 1 == 3) {
        file6 << "MOD 2 LORENTZIAN PROFILE, NPROF = " << setw(4) << nprof - 1 << endl;
    } else if (nprof - 1 == 4) {
        file6 << "SPLIT PEARSON VII PROFILE, NPROF = " << setw(4) << nprof - 1 << endl;
    } else if (nprof - 1 == 5) {
        file6 << "PSEUDO-VOIGT (PV) PROFILE, NPROF = " << setw(4) << nprof - 1 << endl;
    } else if (nprof - 1 == 6) {
        file6 << "PEARSON VII PROFILE, NPROF = " << setw(4) << nprof - 1 << endl;
    } else if (nprof - 1 == 7) {
        file6 << "THOMPSON-COX-HASTINGS (PV) PROFILE, NPROF = " << setw(4) << nprof - 1 << endl;
    }
    if (ipref == 0) {
        file6 << "IPREF=0, UDA-RIETVELD PREFERRED ORIENTATION FUNCTION" << endl;
    } else {
        file6 << "IPREF=1, MARCH-DOLLASE PREFERRED ORIENTATION FUNCTION" << endl;
    }

    // SURFACE ROUGHNESS

    switch (iabsr) {
    case 1:
        file6 << "IABSR=1, CORRECTION OF SURFACE ROUGHNESS BY YOUNG" << endl;
        break;
    case 2:
        file6 << "IABSR=2, CORRECTION OF SURFACE ROUGHNESS BY, SPARKS, ET AL." << endl;
        break;
    case 3:
        file6 << "IABSR=3, CORRECTION OF SURFACE ROUGHNESS BY SUORTTI" << endl;
        break;
    case 4:
        file6 << "IABSR=4, CORRECTION OF SURFACE ROUGHNESS BY PITSCHKE, HERMANN, AND MATTERN" << endl;
        break;
    }

    //  asymmetry correction  Test for asymmetry model included
    if (iasym == 0) {
        file6 << "IASYM=0, Usual Rietveld Asymmetry" << endl;
    }
    if (iasym == 1) {
        file6 << "IASYM=1, Asymmetry by Riello et al.: Powder Diffraction,10,204-206,1995" << endl;
    }

    //-----FONDO=0 :BKG EVALUATED USING STANDARD METHODS
    //-----FONDO=1 :BKG EVALUATED USING THE ISOTROPIC THERMAL FACTORS
    //-----FONDO=2 :BKG EVALUATED USING THE OVERAL THERMAL FACTORS
    //-----AIR SCATTERING,IAXX= 1 AIR SCATTERING ADDED TO THE BACKGROUND IF SCAIR<>0
    //                    IAXX= -1 AIR SCATT. EVALUATED AND SUBTRACTED FROM DATA
    //                    IAXX= 0 AIR SCATT NOT EVALUATED and ibgd = 1
    //-----LINEAR ABSORP.CORR., IAS= 1  DATA CORRECTED FOR LINEAR ABSORPTION
    //
    //-----FI = AIR FRACTION INSIDE THE SAMPLE
    if (codebck.IBCKCODE == -1)
    {
        // line 2.2
        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line2_2(line);
    }

    if (cntrls.IBGD != 1)
    {
        if (ias == 0) {
            file6 << "IAS = 0, NO LINEAR ABSORPTION CORRECTION" << endl;
        }
        if (ias == 1) {
            file6 << "IAS = 1, LINEAR ABSORPTION CORRECTION IS APPLIED" << endl;
        }
        if (fondo == 1) {
            file6 << "FONDO = 1,ISOTROPIC B FACTOR USED FOR BKG EVALUATION" << endl;
        }
        if (fondo == 2) {
            file6 << "FONDO = 2,OVERALL Q USED FOR BKG EVALUATION" << endl;
        }
    }
    else
    {
        file6 << "NO AMOPHOUS AND COMPTON CORRECTION TO THE BGD" << endl;
    }



    // line 3
    getline(file5,line);
    if (file5.bad()) goto L99999;
    read_icf_line3(line);


    if (codebck.IBCKCODE != -1) {
        r_iploss = 0;
        r_iplcal = 0;
        r_iplpol = 0;
        r_iplcom = 0;
        r_ipldis = 0;
        r_iplam = 0;
        //IPLAIR=0
        r_ipbig = 0;
    }
    simoper.ISIMOP = 0;
    if (r_iot != 0)  file6 << "OUTPUT OBSERVED AND CALCULATED INTENSITIES ON, LAST CYCLE" << endl;
    if (r_ipl != 0) file6 << "GENERATE LINE PRINTER PLOT" << endl;
    // ipl2 is UNUSED in this release
    if (r_ipl2 != 0) file6 << "GENERATE CALCOMP PLOT" << endl;
    if (r_ipl2 != 0) r_ipl2=0;
    if (r_iplst == 1) file6 << "GENERATE PARAMETER LIST" << endl;
    if (r_iplst == 2) {
        file6 << "GENERATE PARAMETER LIST" << endl
              << "GENERATE PARAMETERS AND STD.DEV. IN FINAL CYCLE FOR DATA BASE" << endl;
    }
    if (r_ipc == 1) file6 << "OUTPUT INTENSITIES" << endl;
    if (r_ipc == 2) file6 << "OUTPUT ABSOLUTE VALUES OF STRUCTURE FACTORS + PHASE ANGLE" << endl;
    if (r_ipc == 3) file6 << "OUTPUT A AND B (CALC + OBS) STRUCTURE FACTORS" << endl;
    if (r_mat != 0 && jobtyp < 3) file6 << "OUTPUT CORRELATION MATRIX" << endl;
    if (r_nxt != 0 && jobtyp < 3) file6 << "GENERATE NEW INPUT FILE" << endl;
    if (r_lst1 != 0) file6 << "PRINT REFLECTION LIST" << endl;
    if (nphase == 1) r_lst3 = 0;
    if (r_lst3 != 0) file6 << "Print merged reflection list" << endl;
    if (r_lst2 != 0) file6 << "Print corrected data" << endl;

    // line 4
    getline(file5,line);
    if (file5.bad()) goto L99999;
    read_icf_line4(line);



    RATIO[1] = 1.0;
    LAMDAM=calc_lambdam();          // Calcula λ médio

    file6 << "WAVELENGTHS= "
          << setw(9) << setprecision(5) << fixed << LAMDA[1]
          << setw(9) << setprecision(5) << fixed << LAMDA[2]
          << "  LAMDA MEAN = " << setw(9) << setprecision(5) << fixed << LAMDAM << endl;
    file6 << "ALPHA2:ALPHA1 RATIO =  " << setw(8) << setprecision(4) << fixed << RATIO[2] << endl;


    IXRAY=search_wavelengths();

    file6 << "BASE OF PEAK = 2.0*HW*"  << setw(8) << setprecision(2) << fixed << WDT << endl;
    file6 << "MONOCHROMATOR CORRECTION = " << setw(8) << setprecision(4) << fixed << CTHM << endl;
    file6 << "ABSORPTION CORRECTION=-0.1*" << setw(8) << setprecision(4) << fixed << TMV << " CM-1" << endl;
    file6 << "SLAB-WIDTH = " << setw(8) << setprecision(4) << fixed << SW << " CM." << endl;

    if (iasym == 0) {
        file6 << "RIETVELD ASYMMETRY CORRECTION FOR ANGLES LESS THAN "
              << setw(8) << setprecision(3) << fixed << RLIM << " DEGREES" << endl;
    } else {
        file6 << "ASYMMETRY CORRECTION FOR ANGLES LESS THAN "
              << setw(8) << setprecision(3) << fixed << 90.0 - RLIM << " DEGREES" << endl
              << "                          AND GREATER THAN "
              << setw(8) << setprecision(3) << fixed << RLIM + 90.0 << " DEGREES" << endl;
    }

    // line 5
    getline(file5,line);
    if (file5.bad()) goto L99999;
    read_icf_line5(line);


    if (jobtyp > 2) mcycle = 1;
    cntrls.ICYRUN = mcycle;
    file6 << "NUMBER OF CYCLES = " << setw(4) << mcycle << endl;
    file6 << "RELAXATION FACTORS" << endl
          << "FOR COORDINATES=" << setw(5) << setprecision(2) << fixed << RELAX[1] << endl
          << "FOR ANISOTRPIC TEMPERATURE FACTORS=" << setw(5) << setprecision(2) << fixed << RELAX[2] << endl
          << "FOR FWHM PARAMETERS=" << setw(5) << setprecision(2) << fixed << RELAX[3] << endl
          << "FOR LATTICE CONSTANTS=" << setw(5) << setprecision(2) << fixed << RELAX[4] << endl;
    file6 << "EPS-VALUE=" << setw(6) << setprecision(1) << fixed << EPS << endl;

    // line 6(*)
    if (nbckgd >= 2)
    {
        for (i = 1; i <= nbckgd; ++i) {
            getline(file5,line);
            if (file5.bad()) goto L99999;
            read_icf_line6(line,i);
        }
    }


    // line 7(*)
    if (nexcrg > 0)
    {
        for (i = 1; i <= nexcrg; ++i) {
            getline(file5,line);
            if (file5.bad()) goto L99999;
            read_icf_line7(line,i);
        }
        file6 << "EXCLUDED REGIONS" << endl
              << "FROM     TO" << endl;
        for (i = 1; i <= nexcrg; ++i) {
            file6 << setw(9) << setprecision(4) << fixed << ALOW[i]
                  << setw(9) << setprecision(4) << fixed << AHIGH[i] << endl;
        }
    }


    if (nscat > 0)
    {
        for(i=1; i <= nscat; i++)
        {
            if (jobtyp == 2 || jobtyp == 4)
            {
                // line 8.1 ND(*)

                getline(file5,line);
                if (file5.bad()) goto L99999;
                read_icf_line8_1_neutron(line,i);
            }
            else
            {
                // line 8.1 XRD(*)
                getline(file5,line);
                if (file5.bad()) goto L99999;
                read_icf_line8_1_xray(line,i);
                K = 0;

        L126:
                // line 8.2 XRD(*)
                getline(file5,line);
                if (file5.bad()) goto L99999;
                read_icf_line8_2_xray(line,i);

                if (AC_[1][i] == -100.0) COEF(i, K);

                if (AC_[3][i] == 0.0)
                {
                    K=K+1;
                    coeff.POSI[K]=AC_[1][i];
                    coeff.SCAT[K]=AC_[2][i];
                    if (K <= 29) goto L126;
                    file6 << "TOO MANY SCATTERING TABLE ENTRIES" << endl;
                    cout << "7700" << endl;
                    exit(EXIT_FAILURE);
                }
            }
        }
        if (jobtyp == 1 || jobtyp == 3)
        {
            file6 << "FORMFACTORS" << endl;
            for (i = 1; i <= nscat; ++i)
            {
                file6 << " FOR " << NAM_[i]
                      << " DFP=" << setw(10) << setprecision(6) << fixed << DFP[i]
                      << " DFPP=" << setw(10) << setprecision(6) << fixed << DFPP[i] << endl
                      << "COEFFICIENTS= ";
                for (j = 1; j <= 9; ++j) file6 << setw(10) << setprecision(6) << fixed <<  AC_[j][i];
                file6 << endl;
            }
        }
        else
        {
            file6 << "SCATTERING LENGTHS" << endl;
            for (i = 1; i <= nscat; ++i)
            {
                file6 << " FOR " << NAM_[i] << "     " << setw(10) << setprecision(6) << fixed << DFP[i] << endl;
            }
            for (i = 1; i <= nscat; ++i) {
                for (j = 1; j <= 9; ++j) {
                    AC_[j][i] = 0.0;
                }
                DFPP[i] = 0.0;
            }
        }
    }



    // line 9
    getline(file5,line);
    if (file5.bad()) goto L99999;
    read_icf_line9(line);

    if (MAXS > MSZ) {
        file6 << endl
              << "* YOU HAVE DECLARED MORE CODEWORDS THAN WILL FIT INTO *" << endl
              << "* THE -MSZ- ARRAY.  EITHER DECREASE THE # OF CODEWORD *" << endl
              << "* OR  INCREASE  THE  -MSZ-  ARRAY  SIZE AND RECOMPILE *" << endl;
        cout << endl
             << "* YOU HAVE DECLARED MORE CODEWORDS THAN WILL FIT INTO *" << endl
             << "* THE -MSZ- ARRAY.  EITHER DECREASE THE # OF CODEWORD *" << endl
             << "* OR  INCREASE  THE  -MSZ-  ARRAY  SIZE AND RECOMPILE *" << endl;
        goto L99995;
    }
    cout << "INPUT:    CYCLES =" <<setw(4) << mcycle << "     REFINABLE PARAMETERS =" << setw(4) << MAXS << endl;
    /*     CHECK DIMENSIONING FOR SOME EQUIVALENCED ARRAYS */
    if (IDSZ < MSZ*MAXS) {
        file6 << "CHANGE IDSZ OR MSZ SO THAT IDSZ IS EQUAL TO OR GREATER THAN MSZ*MAXS" << endl
              << "IDSZ, MAXIMUM NO. OF DATA POINTS = " << setw(6) << IDSZ << endl
              << "MSZ,  MATRIX SIZE                = " << setw(6) << MSZ << endl
              << "MAXS, NO. OF PARAMETERS VARIED   = " << setw(6) << MAXS << endl
              << "*** JUST A DIMENSIONING ERROR ***" << endl;
        cout << "IDSZ IS LESS THAN MSZ*MAXS" << endl;
        exit(EXIT_FAILURE);
    }

    if (jobtyp > 2) MAXS=0;
    file6 << "NUMBER OF PARAMETERS VARIED= " << setw(5) << MAXS << endl;

    // line 10.1
    getline(file5,line);
    if (file5.bad()) goto L99999;
    read_icf_line10_1(line);

    // line 10.11
    getline(file5,line);
    if (file5.bad()) goto L99999;
    read_icf_line10_1_1(line);


    file6 << "GLOBAL PARAMETERS AND CODEWORDS" << endl
          << "ZEROPOINT= "
          << setw(8) << setprecision(2) << GLB[1]
          << " " << GLB[1].codeword << endl;

    //-----PMON1,PMON2=PARAMETER OF THE MONOCHROMATOR
    //-----IT READS PARAMETER OF THE MONOCHROMATOR AND AIR SCALE
    //-----IF THE MONOCHROMATOR WORKS ON THE INCIDENT BEAM PUT :
    //-----PMON1=1;PMON2=0;
    // next 2 'READ' are for amorphous bkg codes
    // SCAIR=glb(17), FLSCAIR=aglb(17), SCAM =glb(20), FLSCAM=aglb(20)
    // PMON1=glb(18), FLMON1 =aglb(18), PMON2=glb(19), FLMON2=aglb(19)
    //      READ(5,455,END=99999)SCAIR,FLSCAIR,SCAM,FLSCAM,
    //     *  PMON1,FLMON1,PMON2,FLMON2
    //
    if (cntrls.IBGD != 1)
    {
        // line 10.2 and line 10.21
        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_2(line);

        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_2_1(line);


        file6 << "AMORPHOUS SCALE and CODEWORD= "
              << setw(8) << setprecision(2) << GLB[20]
              << " " << GLB[20].codeword << endl;
        file6 << "MONOCROMATOR BANDPASS PARAMETERS AND CODEWORDS" << endl
              << "PARAMETERS MONOC="<< endl
              << setw(8) << setprecision(2) << GLB[18]
              << " " << GLB[18].codeword
              << "                 "
              << setw(8) << setprecision(2) << GLB[19]
              << " " << GLB[19].codeword << endl;
    }


    if (nbckgd == 0)
    {
        // line 10.4(*)
        // line 10.3 and line 10.31
        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_3(line);

        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_3_1(line);


        file6 << "BACKGROUND PARAMETERS AND CODEWORDS" << endl
              << "ORIGIN OF BACKGROUND POLYNOMIAL AT TWO-THETA = " << setw(8) <<setprecision(3) << fixed << BKPOS << "DEGREES" << endl
              << setw(12) << setprecision(6) << scientific << GLB[2] << endl
              << setw(12) << setprecision(6) << scientific << GLB[3] << endl
              << setw(12) << setprecision(6) << scientific << GLB[4] << endl
              << setw(12) << setprecision(6) << scientific << GLB[5] << endl
              << setw(12) << setprecision(6) << scientific << GLB[6] << endl
              << setw(12) << setprecision(6) << scientific << GLB[7] << endl
              << " " << GLB[2].codeword << "    "
              << " " << GLB[3].codeword << "    "
              << " " << GLB[4].codeword << "    "
              << " " << GLB[5].codeword << "    "
              << " " << GLB[6].codeword << "    "
              << " " << GLB[7].codeword << "    " << endl;
    }


    file6 << "DISPLACEMENT PEAKSHIFT PARAMETER AND CODEWORD"
          << setw(8) << setprecision(2) << GLB[10]
          << " " << GLB[10].codeword << endl
          << "TRANSPARENCY PEAKSHIFT PARAMETER AND CODEWORD"
          << setw(8) << setprecision(2) << GLB[11]
          << " " << GLB[11].codeword << endl;
    file6 << "SURFACE ROUGHNESS P PARAMETER AND CODEWORD"
          << setw(9) << setprecision(4) << fixed << GLB[8]
          << " " << GLB[8].codeword << endl
          << "SURFACE ROUGHNESS Q PARAMETER AND CODEWORD"
          << setw(9) << setprecision(4) << fixed << GLB[9]
          << " " << GLB[9].codeword << endl
          << "SURFACE ROUGHNESS R PARAMETER AND CODEWORD"
          << setw(9) << setprecision(4) << fixed << GLB[12]
          << " " << GLB[12].codeword << endl
          << "SURFACE ROUGHNESS T PARAMETER AND CODEWORD"
          << setw(9) << setprecision(4) << fixed << GLB[13]
          << " " << GLB[13].codeword << endl;

    if (jobtyp <= 2)
    {
        if (jobtyp == 1 && instrm == 2)
        {
            //-----IF PATTERN CALCULATION ONLY FOR SYNCHROTRON X-RAY DATA goto 501

            //       READ DATA FROM SYNCHROTRON SOURCE AND CORRECT DATA FOR DEAD TIME,
            //      CALCULATE VARIANCE FOR EACH OF THE DATA POINTS
            //     DATE IS OCT85,FEB86,AUG86,SRS83,SRS91
            //     NRANGE IS THE NO OF BLOCKS IN WHICH THE DATA ARE GIVEN
            //     OFSTI0 - DARK BEAM CURRENT, READING WITH NO ELECTRONS IN THE CHAMBER
            //     OFSTI1 - DETECTOR DARK BEAM CURRENT
            //     CHMBRI - ALL CURRENTS ARE  NORMALISED TO CHMBRI

            getline(file4,line);
            if (file4.bad()) goto L99998;
            DATE = line.substr(0,5);
            DATAID = line.substr(5,56);
            file6 << "DATA ID " << DATAID << endl;
            getline(file4,line);
            if (file4.bad()) goto L99998;
            NRANGE = stoi(line.substr(0,8));
            CHMBRI = stof(line.substr(8,8));
            TAUK   = stof(line.substr(8*2,10));

            //     NPTS IS THE COUNTER FOR TOTAL NO OF POINTS IN ALL THE RANGES
            NPTS = 0;
            for(j=1; j <= NRANGE; j++)
            {
                //     READ INFORMATION ABOUT EACH RANGE
                getline(file4,line);
                if (file4.bad()) goto L99998;
                ANGMIN  = stof(line.substr(0*8,8));
                STEP = stof(line.substr(1*8,8));
                ANGMAX  = stof(line.substr(2*8,8));
                STPTIM  = stof(line.substr(3*8,8));
                OFSTI0  = stof(line.substr(4*8,8));
                OFSTI1  = stof(line.substr(5*8,8));
                IPTS= (ANGMAX-ANGMIN)/STEP +1.5;
                //     FIND MAXIMUM AND MINIMUM TWO THETA IN ALL RANGES
                if (j == 1) THMIN = ANGMIN;
                if (j == NRANGE) THMAX = ANGMAX;
                if (j > 1) {
                    getline(file4,line);
                    if (file4.bad()) goto L99998;
                    IPTS = IPTS - 1;
                }
                if (NPTS + IPTS > IDSZ) {
                    file6 << "PROGRAM CAN HANDLE " << IDSZ << " POINTS" << endl
                          << NPTS + IPTS << "POINTS WERE INPUT" << endl
                          << "INCREASE IDSZ IN PARAMETER STATEMENT" << endl;
                    cout << " TOO MANY DATA POINTS " << endl;
                    exit(EXIT_FAILURE);
                }

                //     VAR(I) IS USED FOR TWO QUANTITIES, JUST TO SAVE SOME SPACE.
                if ( DATE == "OCT85" ) {
                    for (i = 1; i <= IPTS; ++i) {
                        getline(file4,line);
                        if (file4.bad()) goto L99998;
                        Y_[i + NPTS] = stof(line.substr(24,7));
                        VAR_[i + NPTS] = stof(line.substr(24+7,7));
                    }
                } else if ( DATE == "FEB86" ) {
                    for (i = 1; i <= IPTS; ++i) {
                        getline(file4,line);
                        if (file4.bad()) goto L99998;
                        Y_[i + NPTS] = stof(line.substr(24,7));
                        VAR_[i + NPTS] = stof(line.substr(24+7,7));
                    }
                } else if ( DATE == "AUG86" ) {
                    for (i = 1; i <= IPTS; ++i) {
                        getline(file4,line);
                        if (file4.bad()) goto L99998;
                        Y_[i + NPTS] = stof(line.substr(51,10));
                        VAR_[i + NPTS] = stof(line.substr(51+10,10));
                    }
                } else if ( DATE == "SRS83" ) {
                    for (i = 1; i <= IPTS; ++i) {
                        getline(file4,line);
                        if (file4.bad()) goto L99998;
                        Y_[i + NPTS] = stof(line.substr(37,9));
                        VAR_[i + NPTS] = stof(line.substr(37+9,9));
                    }
                } else if ( DATE == "SRS91" ) {
                    for (i = 1; i <= IPTS; ++i) {
                        getline(file4,line);
                        if (file4.bad()) goto L99998;
                        Y_[i + NPTS] = stof(line.substr(29,9));
                        VAR_[i + NPTS] = stof(line.substr(29+9,9));
                    }
                } else {
                    file6 << "     WHEN AND WHERE WERE THESE DATA TAKEN. OCT85,FEB86,AUG86,SRS83,SRS91" << endl;
                }
                //     TAUK = 2.4621E-6
                for(i=NPTS+1; i <= IPTS+NPTS; i++)
                {
                    Y_[i] = Y_[i]/STPTIM;
                    FLEET1 = VAR_[i]-OFSTI0;
                    FLEET2= FLEET1/CHMBRI;
                    FLEET2= pow((FLEET2*STPTIM*(1-TAUK*Y_[i])),2.0);
                    VAR_[i] = (STPTIM*Y_[i])/FLEET2;
                    Y_[i] = (Y_[i]/(1-TAUK*Y_[i])-OFSTI1)*CHMBRI/FLEET1;
                    if (abs(Y_[i]) < 0.01) Y_[i]=1.0;
                }
                NPTS=NPTS+IPTS;
            }
            cout << "DATA RANGE (2THETA):  START =" << setw(8) << setprecision(2) << THMIN << ", STOP =" << setw(8) << setprecision(2) << THMAX << ", STEP =" << setw(8) << setprecision(2) << STEP << endl;
            file6 << "DATA RANGE (2THETA):  START =" << setw(8) << setprecision(2) << THMIN << ", STOP =" << setw(8) << setprecision(2) << THMAX << ", STEP =" << setw(8) << setprecision(2) << STEP << endl;
        }
        if (jobtyp == 2 && instrm == 2)
        {
            //-----IF PATTERN CALCULATION ONLY FOR MULTIPLE NEUTRON DATA goto 601


            //       ENDS SYNCHROTRON DATA MODIFICATION
            //     BEGIN VARIANCE CALCULATION FOR VARYING NO. OF COUNTERS AT EACH STEP

            getline(file4,line);
            if (file4.bad()) goto L99998;
            THMIN = stof(line.substr(0,8));
            STEP  = stof(line.substr(8,8));
            THMAX = stof(line.substr(8*2,8));
            DATAID   = line.substr(8*3,56);
            file6 << "DATA ID " << DATAID << endl;
            cout << "DATA RANGE (2THETA):  START =" << setw(8) << setprecision(2) << THMIN << ", STOP =" << setw(8) << setprecision(2) << THMAX << ", STEP =" << setw(8) << setprecision(2) << STEP << endl;
            file6 << "DATA RANGE (2THETA):  START =" << setw(8) << setprecision(2) << THMIN << ", STOP =" << setw(8) << setprecision(2) << THMAX << ", STEP =" << setw(8) << setprecision(2) << STEP << endl;
            NPTS = (THMAX - THMIN) / STEP + 1.5;
            if (NPTS > IDSZ) {
                file6 << "PROGRAM CAN HANDLE " << IDSZ << " POINTS" << endl
                      << NPTS + IPTS << "POINTS WERE INPUT" << endl
                      << "INCREASE IDSZ IN PARAMETER STATEMENT" << endl;
                cout << " TOO MANY DATA POINTS " << endl;
                exit(EXIT_FAILURE);
            }
            s = "";
            while(getline(file4,line))
            {
                if (file4.bad()) goto L99998;
                s += line.substr(0,10*8);
            }
            for (i = 1; i <= NPTS; ++i) {
                VAR_[i] = stof(line.substr((i-1)*8,2));
                Y_[i]   = stof(line.substr((i-1)*8+2,6));
            }
            for (i = 1; i <= NPTS; ++i) {
                VAR_[i] = Y_[i] / VAR_[i];
            }
        }
        else
        {
            switch (idata) {
            case 0:
                // read DBWS formated
                rit.read(namefile4);
                THMIN = rit.thetamin;
                STEP  = rit.step;
                THMAX = rit.thetamax;
                DATAID = rit.title;
                NPTS = rit.count;
                rit.get(Y_);

                cout << "DATA RANGE (2THETA):  START =" << setw(8) << setprecision(3) << THMIN << ", STOP =" << setw(8) << setprecision(3) << THMAX << ", STEP ="  << setw(8) << setprecision(3) << STEP << endl;
                file6 << "    DATA ID " << DATAID << endl;
                file6 << "DATA RANGE (2THETA):  START =" << setw(8) << setprecision(3) << THMIN << ", STOP =" << setw(8) << setprecision(3) << THMAX << ", STEP ="  << setw(8) << setprecision(3) << STEP << endl;

                if (NPTS > IDSZ) {
                    file6 << "PROGRAM CAN HANDLE " << IDSZ << " POINTS" << endl
                          << NPTS << "POINTS WERE INPUT" << endl
                          << "INCREASE IDSZ IN PARAMETER STATEMENT" << endl;
                    cout << " TOO MANY DATA POINTS " << endl;
                    exit(EXIT_FAILURE);
                }
                break;
            case 1:
                // read DBWS free format
                getline(file4,line);
                if (file4.bad()) goto L99998;
                THMIN = stof(line.substr(0,8));
                STEP  = stof(line.substr(1*8,8));
                THMAX = stof(line.substr(2*8,8));
                DATAID   = line.substr(3*8,56);
                cout << "DATA RANGE (2THETA):  START =" << setw(8) << setprecision(3) << THMIN << ", STOP =" << setw(8) << setprecision(3) << THMAX << ", STEP ="  << setw(8) << setprecision(3) << STEP << endl;
                file6 << "    DATA ID " << DATAID << endl;
                file6 << "DATA RANGE (2THETA):  START =" << setw(8) << setprecision(3) << THMIN << ", STOP =" << setw(8) << setprecision(3) << THMAX << ", STEP ="  << setw(8) << setprecision(3) << STEP << endl;

                NPTS = (THMAX - THMIN) / STEP + 1.5;
                if (NPTS > IDSZ) {
                    file6 << "PROGRAM CAN HANDLE " << IDSZ << " POINTS" << endl
                          << NPTS << "POINTS WERE INPUT" << endl
                          << "INCREASE IDSZ IN PARAMETER STATEMENT" << endl;
                    cout << " TOO MANY DATA POINTS " << endl;
                    exit(EXIT_FAILURE);
                }
                s = "";
                while(getline(file4,line))        // Erro aqui mudar para free format
                {
                    if (file4.bad()) goto L99998;
                    s += line.substr(0,8*8);
                }
                for (i = 1; i <= NPTS; ++i) {
                    Y_[i] = stof(s.substr((i-1)*8,7));
                }
                break;
            case 2:
                // read GSAS data file (read start,stop,step and data)
                GSASREAD();
                s = "";
                while(getline(file4,line))        // Erro aqui mudar para free format
                {
                    if (file4.bad()) goto L99998;
                    s += line.substr(0,8*8);
                }
                for (i = 1; i <= NPTS; ++i) {
                    Y_[i] = stof(s.substr((i-1)*8,7));
                }
                break;
            case 3:
                // read Philips data file (read start,stop,step and data)
                PHILIPSREAD();
                break;
            case 4:
                // read sCINTAG data file (read start,stop,step and data)
                SCINTAG();
                break;
            default:
                break;
            }


            for (i = 1; i <= NPTS; ++i) {
                //     BUILD UP AMORPHOUS-VECTOR
                //     IF REQUIRED MAKE ABSORPTION CORRECTION
                // -----COMPUTE TWO-THETA
                TH = THMIN + (double) (i - 1) * STEP;
                VAR_[i] = Y_[i];
                // -----COMPUTE SAMPLE ABSORPTION CORRECTION
                if (ias == 1)
                {
                    ABSORP(TMV, SW, TH, &ABC);
                    Y_[i] = Y_[i] / ABC;
                    VAR_[i] = VAR_[i] / ABC;
                }
            }
        }
    }
    else
    {
        NPTS = (THMAX - THMIN) / STEP + 1.5;
        if (NPTS > IDSZ) {
            file6 << "PROGRAM CAN HANDLE " << IDSZ << " POINTS" << endl
                  << NPTS + IPTS << "POINTS WERE INPUT" << endl
                  << "INCREASE IDSZ IN PARAMETER STATEMENT" << endl;
            cout << " TOO MANY DATA POINTS " << endl;
            exit(EXIT_FAILURE);
        }
    }
    if (nbckgd - 1 < 0) {
        TH = THMIN - STEP;
        for (i = 1; i <= NPTS; ++i) {
            TH += STEP;
            THX = TH / BKPOS - 1.0;
            BK_[i] = GLB[2];
            for (j = 2; j <= 6; ++j) {
                BK_[i] += GLB[j+1] * pow(THX, j - 1);
            }
        }
    } else if (nbckgd - 1 == 0) {
        file3.open(namefile3, ios::out);
        s = "";
        while(getline(file3,line))
        {
            if (file3.bad()) goto L99997;
            s += line.substr(0,8*8);
        }
        for (i = 1; i <= NPTS; ++i) {
            BK_[i] = stof(s.substr((i-1)*8,7));
        }
    } else {
        DIFB = POS_[1] - THMIN;
        if (DIFB >= 0.0) {
            NBX = DIFB / STEP + 2.5;
            for (i = 1; i <= NBX; ++i) {
                BK_[i] = BCK_[1];
            }
            NXX = 1;
        } else {
            NBX=(POS_[2]-THMIN)/STEP+1.5;
            BK_[1]=BCK_[1]-DIFB/(POS_[2]-POS_[1])*(BCK_[2]-BCK_[1]);
            BSTEP=STEP/(POS_[2]-POS_[1])*(BCK_[2]-BCK_[1]);
            for (i = 2; i <= NBX; ++i) BK_[i] = BK_[i - 1] + BSTEP;
            NXX=2;
        }

        NBC=nbckgd-1;
        if (POS_[nbckgd] < THMAX) {
            POS_[nbckgd+1]=THMAX;
            BCK_[nbckgd+1]=BCK_[nbckgd];
            NBC=NBC+1;
        }
        for(j=NXX; j <= NBC; j++)
        {
            BSTEP=STEP*(BCK_[j+1]-BCK_[j])/(POS_[j+1]-POS_[j]);
            NINC=(POS_[j+1]-POS_[j])/STEP+1.5;
            N2X=min(NPTS,NBX+NINC);
            for(i=NBX; i <= N2X; i++) BK_[i]=BK_[i-1]+BSTEP;
            NBX=N2X;
            if (NBX == NPTS) break;
        }
    }

    for(K=1; K <= nphase; K++) ICR_[K]=0;

    // start loop on phase
    for (K = 1; K <= nphase; ++K)
    {
        // line 11.1
        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_1(line,K);
        file6 << endl << "PHASE  " << setw(2) << K << endl << " " << phases[K].name << endl;

        // line 11.2
        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_2(line,K);

        if (phases[K].SAQF <= 0.0)
        {
            phases[K].SAQF=1.0;
            cout << "Particle absorption factor (phase " << K << ") is now 1." << endl;
        }
        file6 << "NUMBER OF ATOMS= " << phases[K].NATOM << endl
              << "NUMBER OF FORMULA UNITS PER UNIT CELL= " << phases[K].NMOL << endl
              << "PARTICLE ABSORPTION FACTOR = " << setw(8) << setprecision(4) << fixed << phases[K].SAQF << endl
              << "PREFERRED ORIENTATION VECTOR=  "
              << setw(8) << setprecision(4) << fixed << phases[K].PREF[1]
              << setw(8) << setprecision(4) << fixed << phases[K].PREF[2]
              << setw(8) << setprecision(4) << fixed << phases[K].PREF[3] << endl;

        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_3(line,K);

        SPGP(phases[K].SpaceGroup);

        // getting multiplicity of each phase
        simoper.ISIMOP=1;
        RTMT(r_ipl1,K);
        multip.XMLTP[K]=multip.MLTPHASE;
        file6 << "The multiplicity of the general site is " << multip.MLTPHASE << endl;

        //-----READ AND PRINT FOR EACH ATOM
        IOF=0;
        if (K > 1)
        {
            for (IIPHAS = 2; IIPHAS <= K; ++IIPHAS) IOF += phases[IIPHAS - 1].NATOM;
        }
        file6 << endl << "***INITIAL PARAMETERS***" << endl
              << "ATOM    M NTYP              X         Y         Z         B        So" << endl
              << "                           B11       B22       B33       B12       B13       B23" << endl;
        // line 11-4i
        // READ and WRITE, and respectives FORMAT command lines below were
        // changed to incorporate the parameter MURT(I+IOF)
        for (i = 1; i <= phases[K].NATOM; ++i)
        {
            getline(file5,line);
            if (file5.bad()) goto L99999;
            read_icf_line10_11_4_1(line,i + IOF);

            getline(file5,line);
            if (file5.bad()) goto L99999;
            read_icf_line10_11_4_2(line,i + IOF);


            getline(file5,line);
            if (file5.bad()) goto L99999;
            read_icf_line10_11_4_3(line,i + IOF);


            getline(file5,line);
            if (file5.bad()) goto L99999;
            read_icf_line10_11_4_4(line,i + IOF);
        }
        for (i = 1; i <= phases[K].NATOM; ++i)
        {
            file6 << atoms[i + IOF].ATEXT << " " << setw(4) << atoms[i + IOF].MURT << " " << atoms[i+IOF].NTYP
                  << "       "
                  << setw(10) << setprecision(5) << fixed << atoms[i + IOF].AtomPAR[1]
                  << setw(10) << setprecision(5) << fixed << atoms[i + IOF].AtomPAR[2]
                  << setw(10) << setprecision(5) << fixed << atoms[i + IOF].AtomPAR[3]
                  << setw(10) << setprecision(5) << fixed << atoms[i + IOF].AtomPAR[4]
                  << setw(10) << setprecision(5) << fixed << atoms[i+IOF].AtomPAR[5] << endl
                  << "                      "
                  << setw(10) << setprecision(5) << fixed << atoms[i + IOF].AtomPAR[6]
                  << setw(10) << setprecision(5) << fixed << atoms[i + IOF].AtomPAR[7]
                  << setw(10) << setprecision(5) << fixed << atoms[i + IOF].AtomPAR[8]
                  << setw(10) << setprecision(5) << fixed << atoms[i + IOF].AtomPAR[9]
                  << setw(10) << setprecision(5) << fixed << atoms[i + IOF].AtomPAR[10]
                  << setw(10) << setprecision(5) << fixed << atoms[i + IOF].AtomPAR[11] << endl;
        }
        //  (CONVERT sof MULTIPLICITY)(also changed in OUTPTR)
        for(i=1; i <= phases[K].NATOM; i++)
        {
            if (int(atoms[i+IOF].AtomPAR[5].codeword/10) != 0 && atoms[i+IOF].AtomPAR[5] == 0) atoms[i+IOF].AtomPAR[5]=1E-6;
            atoms[i+IOF].AtomPAR[5] = atoms[i+IOF].AtomPAR[5] * atoms[i+IOF].MURT / multip.XMLTP[K];
        }
        // par(k,21) introduced below. It is for the term cot**2 in the pv-5 FWHM
        // line 11-5, line 11-6, line 11-7, line 11-8 and line 11-9
        // S  O_B (line 11-5)
        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_5(line,K);


        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_5_1(line,K);


        // !FWHM   (line 11-6)
        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_6(line,K);


        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_6_1(line,K);


        // Unit cell (line 11-7)
        getline(file5,line);
        read_icf_line10_11_7(line,K);
        if (file5.bad()) goto L99999;


        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_7_1(line,K);


        // G1 G2 P (line 11-8)
        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_8(line,K);


        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_8_1(line,K);


        // NA NB NC (line 11-91)
        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_91(line,K);


        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_91_1(line,K);


        // NA NB NC HS (line 11-93)
        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_93(line,K);


        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_93_1(line,K);


        // s-PVII (line 11-95)
        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_95(line,K);


        getline(file5,line);
        if (file5.bad()) goto L99999;
        read_icf_line10_11_95_1(line,K);



        // checking for zeros if TCH-PV is being used
        if (nprof == 8)
        {
            if (phases[K].PAR[15] == 0) phases[K].PAR[15]=1e-6;
            if (phases[K].PAR[16] == 0) phases[K].PAR[16]=1e-6;
        }

        // checking for zeros in PV #5
        if (nprof == 6)
        {
            if (phases[K].PAR[17] == 0) phases[K].PAR[17] = 1e-6;
        }
        //      if (int(apar(k,20)/10) != 0 && par(k,20) == 0)par(k,20)=1e-9
        // CHECKING FOR NON-REFINABLE PARAMETERS
        //CCC                        FOR  CT  IN TCHZ AND SPVII FUNCTIONS
        if (nprof == 8 || nprof == 5)
        {
            phases[K].PAR[21]=0.0;
            if (phases[K].PAR[21].codeword != 0.)
            {
                cout << "NON-REFINABLE PARAMETER TURNED ON (CT) WITH SPLIT PEARSON VII OR TCHZ PROFILE FUNCTION" << endl;
                file6 << "NON-REFINABLE PARAMETER TURNED ON (CT) WITH SPLIT PEARSON VII OR TCHZ PROFILE FUNCTION" << endl;
                exit(EXIT_FAILURE);
            }
        }
        //CCC                             FOR  X,Y,Z IN NON-TCHZ FUNCTION
        if (nprof != 8)
        {
            if (phases[K].PAR[20] != 0.0 || phases[K].PAR[16] != 0.0 || phases[K].PAR[15].codeword != 0.0) {
                file6 << "NON-REFINABLE PARAMETER RESET TO ZERO (Z,X,Y) FOR" << endl
                      << "      NON TCHZ PROFILE FUNCTION" << endl;
                phases[K].PAR[20] = 0.0;
                phases[K].PAR[16] = 0.0;
                phases[K].PAR[15] = 0.0;
            }
            if (phases[K].PAR[20].codeword != 0.0 || phases[K].PAR[16].codeword != 0.0 || phases[K].PAR[15].codeword != 0.0) {
                cout << "NON-REFINABLE PARAMETER TURNED ON (Z,X,Y) WITH NOT TCHZ PROFILE FUNCTION" << endl;
                file6 << "NON-REFINABLE PARAMETER TURNED ON (Z,X,Y) WITH NOT TCHZ PROFILE FUNCTION" << endl;
                exit(EXIT_FAILURE);
            }
        }

        //CCCC                            FOR  RIET_ASYM,X,Y,Z,CT IN SPVII
        if (nprof == 5) {
            for (KKS = 1; KKS <= 3; ++KKS) {
                if (phases[K].PAR[13+KKS] != 0.0) {
                    phases[K].PAR[13+KKS] = 0.0;
                    file6 << "RIET_ASYM X Y RESET TO ZERO FOR SPVII FUNCTION" << endl;
                }
                if (phases[K].PAR[13 + KKS].codeword != 0.0) {
                    cout << "NON-REFINEABLE PARAMETER TURNED ON (X,Y,R/RCF_ASYM)" << endl
                         << "WITH SPLIT PEARSON VII PROFILE FUNCTION" << endl;
                    file6 << "NON-REFINEABLE PARAMETER TURNED ON (X,Y,R/RCF_ASYM)" << endl
                          << "WITH SPLIT PEARSON VII PROFILE FUNCTION" << endl;
                    exit(EXIT_FAILURE);
                }
            }

            for (KKS = 1; KKS <= 2; ++KKS) {
                if (phases[K].PAR[19+KKS] != 0.0) {
                    phases[K].PAR[19+KKS] = 0.0;
                    file6 << "CT,Z  RESET TO ZERO FOR SPVII FUNCTION" << endl;
                }
                if (phases[K].PAR[19 + KKS].codeword != 0.0) {
                    cout << "NON-REFINEABLE PARAMETER TURNED ON (CT,Z)" << endl
                         << ", WITH SPLIT PEARSON VII PROFILE FUNCTION" << endl;
                    file6 << "NON-REFINEABLE PARAMETER TURNED ON (CT,Z)" << endl
                          << ", WITH SPLIT PEARSON VII PROFILE FUNCTION" << endl;
                    exit(EXIT_FAILURE);
                }
            }
        }

        //CCCC             FOR HIGH SIDE PARAMETERS IN NON-PVII PROFILE FUNCTION
        if (nprof != 5) {
            for (KK = 1; KK <= 4; ++KK) {
                if (phases[K].PAR[23+KK] != 0.0) {
                    phases[K].PAR[23+KK] = 0.0;
                    file6 << "NA NB NC (HIGH SIDE) AND PEARSON ASYMMETRY RESET TO ZERO FOR A" << endl
                          << "NON-SPLIT PEARSON VII FUNCTION" << endl;
                }
                if (phases[K].PAR[23 + KK].codeword != 0.0) {
                    cout << "NA NB NC (HIGH SIDE) AND PEARSON ASYMMETRY ONLY REFINABLE FOR A" << endl
                         << ",            SPLIT PEARSON VII FUNCTION" << endl;
                    file6 << "NA NB NC (HIGH SIDE) AND PEARSON ASYMMETRY ONLY REFINABLE FOR A" << endl
                          << ",            SPLIT PEARSON VII FUNCTION" << endl;
                    exit(EXIT_FAILURE);
                }
            }
        }
        //CCCCC END OF CHECKING NON-REFINABLE PARAMETERS


        file6 << " OVERALL SCALE FACTOR=" << setw(12) << setprecision(6) << scientific << phases[K].PAR[1] << endl
              << " OVERALL TEMP. FACTOR=" << setw(12) << setprecision(6) << fixed << phases[K].PAR[2] << endl
              << " DIRECT CELL PARAMETERS="
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[6]
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[7]
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[8]
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[9]
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[10]
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[11] << endl
              << " PREFERRED ORIENTATION PARAMETERS="
              << setw(7) << setprecision(3) << fixed << phases[K].PAR[12]
              << setw(7) << setprecision(3) << fixed << phases[K].PAR[13] << endl
              << " ASYMMETRY PARAMETER=" << setw(7) << setprecision(3) << fixed << phases[K].PAR[14] << endl;


        //-----CHECK FOR SPLIT PEARSON PROFILE
        if (nprof == 5) {
            file6 << "  LOW SIDE EXPONENT COEFFICIENTS="
                  << setw(12) << setprecision(4) << fixed << phases[K].PAR[17]
                  << setw(12) << setprecision(4) << fixed << phases[K].PAR[18]
                  << setw(12) << setprecision(4) << fixed << phases[K].PAR[191] << endl
                  << "  HIGH SIDE EXPONENT COEFFICIENTS="
                  << setw(12) << setprecision(4) << fixed << phases[K].PAR[24]
                  << setw(12) << setprecision(4) << fixed << phases[K].PAR[25]
                  << setw(12) << setprecision(4) << fixed << phases[K].PAR[26] << endl
                  << "  SPLIT PEARSON VII ASYMMETRY PARAMETER="
                  << setw(12) << setprecision(4) << fixed << &phases[K].PAR[27] << endl;
            /* -----IF NOT THE SPLIT PEARSON VII PROFILE */
        } else {
            file6 << "  MIXING PARAMETERS = "
                  << setw(8) << setprecision(3) << scientific << phases[K].PAR[17]
                  << setw(8) << setprecision(3) << scientific << phases[K].PAR[18]
                  << setw(8) << setprecision(3) << scientific << phases[K].PAR[19] << endl;
        }
        file6 << " FWHM PARAMETERS (U,V,W,CT,Z,X,Y)="
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[3]
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[4]
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[5]
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[21]
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[20]
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[15]
              << setw(9) << setprecision(4) << fixed << phases[K].PAR[16] << endl;


        cellx.a = phases[K].PAR[6];
        cellx.b = phases[K].PAR[7];
        cellx.c = phases[K].PAR[8];
        cellx.alpha = phases[K].PAR[9];
        cellx.beta = phases[K].PAR[10];
        cellx.gamma = phases[K].PAR[11];

        CELL2(K,LAMDAM);
        if (fondo == 1 || fondo == 2)
        {
            bkgscale.SCABKG[K] = volume.GCOM[K] * phases[K].PAR[1];
        }
        file6 << " CELL VOLUME PHASE(" << K << " ) = " << setw(12) << setprecision(4) << fixed << volume.VOLI[K] << endl;
        for (i = 1; i <= 6; ++i) dc.SAVE[K][i] = phases[K].PAR[i + 5];
        for (i = 1; i <= 3; ++i) phases[K].PAR[i + 5] = cellx.AL[i][i];
        phases[K].PAR[9] = cellx.AL[2][3];
        phases[K].PAR[10] = cellx.AL[1][3];
        phases[K].PAR[11] = cellx.AL[1][2];
        file6 << "***Coding of variables***" << endl
              << " ATOM                        X         Y         Z         B         So" << endl
              << "                           B11       B22       B33       B12       B13       B23" << endl;

        //-----PRINT CODEWORDS FOR ATOMIC PARAMETERS
        for (i = 1; i <= phases[K].NATOM; ++i)
        {
            file6 << atoms[i + IOF].ATEXT << "                 "
                  << " " << atoms[i + IOF].AtomPAR[1].codeword
                  << " " << atoms[i + IOF].AtomPAR[2].codeword
                  << " " << atoms[i + IOF].AtomPAR[3].codeword
                  << " " << atoms[i + IOF].AtomPAR[4].codeword
                  << " " << atoms[i+IOF].AtomPAR[5].codeword << endl
                  << "                      "
                  << " " << atoms[i + IOF].AtomPAR[6].codeword
                  << " " << atoms[i + IOF].AtomPAR[7].codeword
                  << " " << atoms[i + IOF].AtomPAR[8].codeword
                  << " " << atoms[i + IOF].AtomPAR[9].codeword
                  << " " << atoms[i + IOF].AtomPAR[10].codeword
                  << " " << atoms[i + IOF].AtomPAR[11].codeword << endl;
        }
        for (i = 1; i <= phases[K].NATOM; ++i) {
            for (j = 1; j <= 11; ++j) {
                X = atoms[i+IOF].AtomPAR[j].codeword;
                IYY = (int) (abs(X) / 10.0);
                if (IYY > MSZ) goto L99996;
                atoms[i+IOF].AtomPAR[j].codeword.L = IYY;
                atoms[i+IOF].AtomPAR[j].codeword = (abs(X) - (double)IYY * 10.0) * copysign(1.0, X);
            }
        }

        //-----PRINT CODEWORDS FOR PROFILE PARAMETERS
        file6 << " OVERALL SCALE FACTOR=" << " " << phases[K].PAR[1].codeword << endl
              << " OVERALL TEMP. FACTOR=" << " " << phases[K].PAR[2].codeword << endl
              << " DIRECT CELL PARAMETERS="
              << " " << phases[K].PAR[6].codeword
              << " " << phases[K].PAR[7].codeword
              << " " << phases[K].PAR[8].codeword
              << " " << phases[K].PAR[9].codeword
              << " " << phases[K].PAR[10].codeword
              << " " << phases[K].PAR[11].codeword << endl
              << " PREFERRED ORIENTATION PARAMETERS="
              << " " << phases[K].PAR[12].codeword
              << " " << phases[K].PAR[13].codeword << endl
              << " ASYMMETRY PARAMETER=" << " " << phases[K-1].PAR[14].codeword << endl;


        if (fondo == 1 && (phases[K].PAR[2] != 0.0 || phases[K].PAR[2].codeword != 0.0)) goto L88888;
        if (fondo == 2 && phases[K].PAR[2] == 0.0 && phases[K].PAR[2].codeword == 0.0) goto L88889;
        //-----CHECK FOR SPLIT PEARSON PROFILE
        if (nprof == 5)
        {
            file6 << " LOW SIDE EXPONENT COEFFICIENTS="
                  << " " << phases[K].PAR[17].codeword
                  << " " << phases[K].PAR[18].codeword
                  << " " << phases[K].PAR[19].codeword << endl
                  << " HIGH SIDE EXPONENT COEFFICIENTS="
                  << " " << phases[K].PAR[24].codeword
                  << " " << phases[K].PAR[25].codeword
                  << " " << phases[K].PAR[26].codeword << endl
                  << " SPLIT PEARSON VII ASSYMETRY PARAMETER="
                  << " " << phases[K].PAR[27].codeword << endl;

            //-----IF NOT THE SPLIT PEARSON VII PROFILE
        }
        else
        {
            file6 << " MIXING PARAMETERS = "
                  << " " << phases[K].PAR[17].codeword
                  << " " << phases[K].PAR[18].codeword
                  << " " << phases[K].PAR[19].codeword << endl;
        }
        file6 << " FWHM PARAMETERS (U,V,W,CT,Z,X,Y)="
              << " " << phases[K].PAR[3].codeword
              << " " << phases[K].PAR[4].codeword
              << " " << phases[K].PAR[5].codeword
              << " " << phases[K].PAR[21].codeword
              << " " << phases[K].PAR[20].codeword
              << " " << phases[K].PAR[15].codeword
              << " " << phases[K].PAR[16].codeword << endl;
        for (i = 1; i <= 27; ++i) {
            X = phases[K].PAR[i].codeword;
            IYY = (int) (abs(X) / 10.0);
            phases[K].PAR[i].codeword.L = IYY;
            phases[K].PAR[i].codeword = (abs(X) - 10.0 * (double) IYY ) * copysign(1.0, X);
        }

        LOOKUP(K,phases[K].NATOM,nscat,IXRAY,jobtyp);
        if (fondo == 1 || fondo == 2) FINDC(K,nscat);
        g1.U=phases[K].PAR[3];
        g1.V=phases[K].PAR[4];
        g1.W=phases[K].PAR[5];
        g1.ZZZ = phases[K].PAR[20];
        g1.UC = phases[K].PAR[21];
        if (nprof == 8)
        {
            g1.ULOR=phases[K].PAR[15];
            g1.VLOR=phases[K].PAR[16];
        }
        REFGEN(K,GLB[1],GLB[10],GLB[11],phases[K].PAR[12]);
        simoper.ISIMOP=0;
        RTMT(r_ipl1,K);
        //         mltp(k)=MLTPHASE
        ICY=1;
        ICZ=0;
        for (IIPHAS = 1; IIPHAS <= K; ++IIPHAS) ICZ += ICR_[IIPHAS];
        if (K >= 2) ICY=1+ICZ-ICR_[K];
        if (r_lst1 == 1)
        {
            IXDEL=0;
            for(IXX=ICY; IXX <= ICZ; IXX++)
            {
                IX=IXX-IXDEL;
                MLTT = NINT(refs[IXX].FMGNTD);
                if (nprof == 8)
                {
                    if ((IX - 1) % 60 == 0) file6 << " NO.  CODE    H   K   L  MULT   HW     POSN      FACTOR,       HWL       HWG     ETA" << endl;
                    file6 << " " << setw(4) << IX
                          << setw(4) << refs[IXX].lambda << "   "
                          << setw(4) << refs[IXX].h
                          << setw(4) << refs[IXX].k
                          << setw(4) << refs[IXX].l
                          << setw(6) << MLTT
                          << setw(8) << setprecision(3) << fixed << refs[IXX].refs[1]
                          << setw(8) << setprecision(3) << fixed << refs[IXX].refs[2]
                          << setw(8) << setprecision(3) << fixed << refs[IXX].refs[3]
                          << setw(10) << setprecision(6) << fixed << refs[IXX].HALFL
                          << setw(8) << setprecision(3) << fixed << refs[IXX].HALFG
                          << setw(8) << setprecision(3) << fixed << refs[IXX].GAM << endl;
                }
                else if (nprof == 5)
                {
                    refs[IXX].FWHM[1]=2.0*(refs[IXX].refs[1])*phases[K].PAR[27]/(1.0+phases[K].PAR[27]);
                    refs[IXX].FWHM[2]=2.0*(refs[IXX].refs[1])/(1.0+phases[K].PAR[27]);
                    if ((IX - 1) % 60 == 0) file6 << "NO.  CODE    H   K   L  MULT      HWL    HWH     FWHM   POSN    FACTOR" << endl;
                    file6 << " " << setw(4) << IX << setw(4) << refs[IXX].lambda << "   "
                          << setw(4) << refs[IXX].h
                          << setw(4) << refs[IXX].k
                          << setw(4) << refs[IXX].l
                          << setw(6) << MLTT
                          << setw(8) << setprecision(3) << fixed << refs[IXX].FWHM[1]
                          << setw(8) << setprecision(3) << fixed << refs[IXX].FWHM[2]
                          << setw(8) << setprecision(3) << fixed << refs[IXX].refs[1]
                          << setw(8) << setprecision(3) << fixed << refs[IXX].refs[2]
                          << setw(10) << setprecision(6) << fixed << refs[IXX].refs[3] << endl;
                }
                else
                {
                    if ((IX - 1) % 60 == 0) file6 << "NO.  CODE    H   K   L  MULT     HW   POSN    FACTOR" << endl;
                    file6 << " " << setw(4) << IX << setw(4) << refs[IXX].lambda << "   "
                          << setw(4) << refs[IXX].h
                          << setw(4) << refs[IXX].k
                          << setw(4) << refs[IXX].l
                          << setw(6) << MLTT
                          << setw(8) << setprecision(3) << fixed << refs[IXX].refs[1]
                          << setw(8) << setprecision(3) << fixed << refs[IXX].refs[2]
                          << setw(10) << setprecision(6) << fixed << refs[IXX].refs[3] << endl;
                }
            }
        }
        for (IX = ICY; IX <= ICZ; ++IX) refs[IX].refs[3] *= refs[IX].FMGNTD; // double(MLTT(IX))
    }
    // end of great loop on phases

    // FIND CODEWORDS FOR GLOBAL PARAMETERS: LGLB(I) & AGLB(I)
    for(i=1; i <= 20; i++)
    {
        X=GLB[i].codeword;
        IYY=int(abs(X)/10.0);
        GLB[i].codeword.L=IYY;
        GLB[i].codeword=(abs(X)-10.0*double(IYY))*copysign(1.0, X);
    }
    if (jobtyp > 2) return;
    NATOMS = 0;
    for (K = 1; K <= nphase; ++K) NATOMS += phases[K].NATOM;
    //     COUNT NO. OF USES OF SAME LOCATION IN NORMAL MATRIX
    for (i = 1; i <= MAXS; ++i) {
        LCOUNT = 0;
        for (j = 1; j <= 20; ++j) {
            if (i == GLB[j].codeword.L) ++LCOUNT;
        }
        for (K = 1; K <= nphase; ++K) {
            for (j = 1; j <= 27; ++j) {
                if (i == phases[K].PAR[j].codeword.L) ++LCOUNT;
            }
        }
        for (K = 1; K <= NATOMS; ++K) {
            for (j = 1; j <= 11; ++j) {
                if (i == atoms[K].AtomPAR[j].codeword.L) ++LCOUNT;
            }
        }
        if (LCOUNT >= 2) file6 << "******* CODEWORD " << i << " is used " << LCOUNT << " times **" << endl;
    }
    //     END COUNT NO. OF USES OF SAME LOCATION IN NORMAL MATRIX

    //     CHECK FOR HOLES IN THE NORMAL MATRIX
    ISTOP=0;
    for (i = 1; i <= MAXS; ++i) {
        for (j = 1; j <= 20; ++j) {
            if (i == GLB[j].codeword.L) goto L7200;
        }
        //  HOLES IN PHASE PARAMETER
        for (K = 1; K <= nphase; ++K) {
            for (j = 1; j <= 27; ++j) {
                if (i == phases[K].PAR[j].codeword.L) goto L7200;
            }
        }
        // HOLES IN ATOMS PARAMETERS
        for (K = 1; K <= NATOMS; ++K) {
            for (j = 1; j <= 11; ++j) {
                if (i == atoms[K].AtomPAR[j].codeword.L) goto L7200;
            }
        }
        file6 << "     ***** HOLE IN THE MATRIX ******. ELEMENT " << i << " IN THE NORMAL MATRIX IS MISSING" << endl;
        cout << "     ***** HOLE IN THE MATRIX ******. ELEMENT " << i << " IN THE NORMAL MATRIX IS MISSING" << endl;
        ISTOP = 1;
L7200:
        ;
    }

    if (ISTOP == 1) exit(EXIT_FAILURE);
    //      if (ISTOP == 1) STOP 'HOLE IN THE MATRIX'
    //     END CHECKING FOR HOLE IN THE NORMAL MATRIX
    //     CHECK FOR NON-ZERO COUNTS AT ALL POINTS
    for (i = 1; i <= NPTS; ++i) {
        if (VAR_[i] <= 1E-6) {
            ANGLEP = THMIN + (double) (i - 1) * STEP;
            file6 << "ZERO COUNTS AT STEP NO." << i << " AT TWO THETA" << setw(8) << setprecision(3) << ANGLEP << endl;
            cout << "*** ZERO COUNTS IN DATA FILE AT A STEP ***" << endl;
            exit(EXIT_FAILURE);
        }
    }
    return;
L99999:
    cout << "END OF FILE TAPE5" << endl;
    exit(EXIT_FAILURE);
L99998:
    cout << "END OF FILE TAPE4" << endl;
    exit(EXIT_FAILURE);
L99997:
    cout << "END OF FILE TAPE3" << endl;
    exit(EXIT_FAILURE);
L99996:
    cout << "MATRIX SIZE IS TOO SMALL" << endl;
    exit(EXIT_FAILURE);
L99995:
    cout << "MAXS > MSZ" << endl;
    exit(EXIT_FAILURE);
L88888:
    cout << "WITH FONDO=1 YOU MUST USE ISOTROPIC THERMAL FACTORS" << endl;
    exit(EXIT_FAILURE);
L88889:
    cout << "IF FONDO=2 YOU MUST USE THE OVERALL THERMAL FACTOR" << endl;
    exit(EXIT_FAILURE);
L88088:
    if (file4.is_open()) file4.close();
    if (file5.is_open()) file5.close();
    if (file6.is_open()) file6.close();
    exit(EXIT_FAILURE);
    //      stop 'CHECK MULTIPLICITIES IN NEWINP.INP * CONVERSION DONE'
    //88887 STOP 'IF IAX =1 YOU MUST SET AIR AND FLAIR EQUAL ZERO'
}






void DBWS::INPAM()
{
    string line,s;

    int I;
    double TH, SW1, ABC, TMV1, STEP1, THMIN1, THMAX1;
    string DATAID1;

    // unit 11 = amorphous file
    file11.open(namefile11, ios::in);
    //-----CONTROL IF THERE IS THE AMORPHOUS FILE 0.
    //-----AND IF IT IS ON THE SAME POINTS OF THE DATA FILE
    getline(file11,line);
    if (file11.bad()) goto L99999;
    THMIN1 = stof(line.substr(0,8));
    STEP1  = stof(line.substr(1*8,8));
    THMAX1 = stof(line.substr(2*8,8));
    TMV1   = stof(line.substr(3*8,8));
    SW1    = stof(line.substr(4*8,8));
    DATAID1= line.substr(5*8,16);
    file6 << "    DATA AMORPHOUS " << DATAID1 << endl;
    if (THMIN1 != THMIN) {
        file6 << "AMORPHOUS THMIN=" << setw(8) << setprecision(2) << THMIN1
              << "IS DIFFERENT FROM THE DATA THMIN=" << setw(8) << setprecision(2) << THMIN << endl;
    }
    if (STEP1 != STEP) {
        file6 << "AMORPHOUS STEP=" << setw(8) << setprecision(2) << STEP1
              << "IS DIFFERENT FROM THE DATA STEP=" << setw(8) << setprecision(2) << STEP << endl;
    }
    if (THMAX1 != THMAX) {
        file6 << "AMORPHOUS THMAX=" << setw(8) << setprecision(2) << THMAX1
              << "IS DIFFERENT FROM THE DATA THMAX=" << setw(8) << setprecision(2) << THMAX << endl;
    }

    //      READ(11,4481,END=99999)(AMORPHOUS(I),I=1,NPTS)
    //4481   FORMAT(BZ,8(F7.0,1X))
    //      read the rest of the file in free format

    s = "";
    while(getline(file11,line))
    {
        if (file11.bad()) goto L99999;
        s += line.substr(0,8*8);
    }
    for (I = 1; I <= NPTS; ++I) {
        AMORPHOUS_[I] = stof(s.substr((I-1)*8,7));
    }
    for (I = 1; I <= NPTS; ++I) {
        TH = THMIN + (I - 1) * STEP;
        /* ------AMORPHOUS CORRECTION FOR AIR SCATTERING */
        /*       CALL ARIA(TMV1,SW1,FI1,TH,SCA) */
        AMORPHOUS_[I] = 0.0;
        if (ias == 1) {
            ABSORP(TMV1, SW1, TH, &ABC);
            AMORPHOUS_[I] /= ABC;
        }
    }
    return;
L99999:
    file6 << "END OF FILE ENCOUNTERED AT START ON TAPE 11 OF PHASE AMORPHUS" << endl;
    cout << "   *** END OF FILE ENCOUNTERED FOR AMORPHOUS FILE *** " << endl;
    exit(EXIT_FAILURE);
}








void show_help()
{
    cout << "DBWS [options] N" << endl;
    cout << "N is the name of the ICF file" << endl;
    cout << "Options:" << endl;
    cout << "-d,--drx,--file4 <file name>        set diffractogram file name" << endl;
    cout << "--help                              show this text" << endl;
    cout << "-o,--output,--file6 <file name>     set output file name" << endl;
    cout << "--version                           show DBWS version" << endl;
}

bool readcomandline(int argc,  char **argv)
{
    int i;
    string option;
    bool error = false;
    bool readcomplement = false;
    bool showhelp = false;
    bool showversion = false;
    bool setoutputfile = false;
    bool setdatafile = false;
    string icffilename,outputfilename,datafilename;

    for (i=1; i < argc; i++)
    {
        option = argv[i];
        if (option == "--" || option == "-")
        {
            error = true;
        }
        else
        {
            if (readcomplement)
            {
                readcomplement = false;
                if (setoutputfile)
                {
                    outputfilename = option;
                }
                else if (setdatafile)
                {
                    datafilename = option;
                }
            }
            else
            {
                if (option.substr(0,2) == "--")                // Verifica se é um argumento de nome longo
                {
                    option = option.substr(2);                // Remove os caracteres -- do inicio do texto

                    if ( option == "help")
                    {
                        showhelp = true;
                    }
                    else if ( option == "version")
                    {
                        showversion = true;
                    }
                    else if (option == "output" || option == "file6")
                    {
                        setoutputfile = true;
                        readcomplement = true;
                    }
                    else if (option == "data" || option == "drx" || option == "file4")
                    {
                        setdatafile = true;
                        readcomplement = true;
                    }
                    else
                    {
                        error = true;
                    }
                }
                else if (option.substr(0,1) == "-")            // Verifica se é um argumento de nome curto
                {
                    option = option.substr(1);                // Remove o caracter - do inicio do texto

                    if (option == "o")
                    {
                        setoutputfile = true;
                        readcomplement = true;
                    }
                    else if (option == "d")
                    {
                        setdatafile = true;
                        readcomplement = true;
                    }
                    else
                    {
                        error = true;
                    }
                }
                else
                {
                    // Lê o nome do arquivo ICF.
                    icffilename = option;
                }
            }
        }
    }

    if (error)
    {
        cout << "Error on the command line." << endl;
    }
    else if (showhelp)
    {
        show_help();
        error = true;
    }
    else if (showversion)
    {
        cout << versao << endl;
        error = true;
    }
    else
    {
        namefile5 = icffilename;

        if(setoutputfile)
        {
            namefile6 = outputfilename;
        }

        if (setdatafile)
        {
            namefile4 = datafilename;
        }
    }

    return error;
}

int main(int argc, char* *argv)
{
    DBWS dbws;

    /*
           Interpretando a linhaa de comando. Note que houve muitas aterações em relação ao
           a versão 5.0 e anteriores.

           A sintaxe segue as orientações POSIX. Baseado em:
           https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html
           http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html


         */



    if (!readcomandline(argc,argv))
    {
        if (!namefile5.empty())
        {
            if (namefile6.empty())
            {
                namefile6 = "dbws.out";
                cout << "Output file name moved to " << namefile6 << endl;
            }

            // unit 6 = output file
            file6.open(namefile6, ios::out);
            if (file6.is_open())
            {
                // unit 5 Input control File
                file5.open(namefile5, ios::in);
                if (file5.is_open())
                {
                    // unit 4=data file
                    file4.open(namefile4, ios::in);

                    dbws.INPTR();

                    //      if(icnvt.eq.1) goto 800
                    // Canton et all code starts here
                    //-----OPEN,IF NECESSARY, FILE CONTAINING AMORPHOUS SCATTERING

                    if( dbws.GLB[20] != 0.0 || dbws.GLB[20].codeword != 0.0) dbws.INPAM();



                    // Canton et all code stops here

                    dbws.ITER();
                    if (dbws.MAXS > 0)
                    {
                        cntrls.MCYCLX = dbws.mcycle;
                        cntrls.MAXSX  = dbws.MAXS;
                        dbws.mcycle = 1;
                        dbws.MAXS   = 0;
                        //-------LAST CALL TO ITER IF MCYCLE = 1 & MAXS = 0
                        dbws.ITER();
                        dbws.mcycle = cntrls.MCYCLX;
                        dbws.MAXS   = cntrls.MAXSX;
                    }
                    dbws.EXPUT();




                }
                else
                {
                    file6 << "Error opening input control file." << endl;
                    cout << "Error opening input control file." << endl;
                }
                if (file4.is_open()) file4.close();
                if (file5.is_open()) file5.close();
                if (file6.is_open()) file6.close();
                if (file11.is_open()) file11.close();
            }
            else
            {
                cout << "Error opening output file." << endl;
            }
        }
        else
        {
            cout << "Error on the command line. Missing name ICF file." << endl;
        }
    }

    return 0;
}
